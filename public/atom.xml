<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘健超(Jc)&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-13T11:54:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘健超</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的第一次移动端页面制作 — 总结与思考</title>
    <link href="http://yoursite.com/2016/11/13/2016-11-08-first-mobile-rebuild/"/>
    <id>http://yoursite.com/2016/11/13/2016-11-08-first-mobile-rebuild/</id>
    <published>2016-11-13T11:52:51.000Z</published>
    <updated>2016-11-13T11:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近被分配到移动端开发组，支持某活动的页面页面制作。这算是我第一次真正接触移动端页面制作，下面就谈谈个人总结和思考。</p>
<a id="more"></a>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>开会大体讲解、讨论与排期 -&gt; 交互设计 -&gt; 视觉设计 -&gt; 页面页面制作 -&gt; 前端开发 -&gt; 测试</p>
<p>每个步骤环环相扣，每个职位都需要和其前后的人沟通协调。</p>
<p>测试遇到问题则会反馈到相应环节负责人。</p>
<p>当然，涉及的职位也不仅于此，还有法务同事审核内容是否符合当前法规等等。</p>
<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><h3 id="Athena"><a href="#Athena" class="headerlink" title="Athena"></a>Athena</h3><p>前端开发离不开构建工具，除了敲代码，其余都交给构建工具（如组件开发、CSS 兼容处理、图片 Base64、图片雪碧图和压缩处理等）。<br>在 <a href="https://athena.aotu.io/" target="_blank" rel="external">Athena</a> 中，文件层级结构如下：项目 project -&gt; 模块 module（具体每个活动） -&gt; 页面 page -&gt; 部件 widget。  </p>
<p>举例： 某项目 -&gt; X、Y 活动 -&gt; 预热页和高潮页 -&gt; 头部、弹框等 widget。一般文件目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Xproject</div><div class="line">    - gb (公共部分，如初始化样式和一些常用 widget)</div><div class="line">    - X活动</div><div class="line">        - page</div><div class="line">            - 预热页</div><div class="line">            - 高潮页</div><div class="line">        - widget</div><div class="line">            - header</div><div class="line">            - footer</div><div class="line">            - diglog</div><div class="line">    - Y 活动</div><div class="line">    - ...</div></pre></td></tr></table></figure></p>
<p>刚开始接触时，存在这样的一个疑惑：什么是 widget，一个不可复用的页面头部可以作为 widget 吗？<br>答：我最初的想法是：“错误地把 widget 当成 component，component 一直被强调的 特性之一是<strong>可复用性</strong>。对于不可复用的部分就不应该抽出为一个widget了？”<strong>其实对于一个相对独立的功能，我们就可把它抽出来。</strong>这无疑会增强程序的可维护性。 </p>
<p>对于一个项目，一般一个模块由一个人负责。但考虑到每个模块间可能存在（或未来存在）可复用的 widget，需要规范命名以形成命名空间，防止冲突（具体会在下面的规范-命名中阐述）。</p>
<blockquote>
<p>Component 与 Widget 的区别<br>Component 是更加广义抽象的概念，而Widget是更加具体现实的概念。所以Component的范围要比Widget大得多，通常 Component 是由多个 Widget 组成。<br>举个例子，可能不是很恰当，希望帮助你的理解，比如家是由床，柜子等多个 Component 组成，柜子是由多个抽屉 Widget 组成的。<br>而 Component 和 Widget 的目的都是为了模块化开发。</p>
</blockquote>
<p>其实，在这里并没有对 widget 和 component 做这么细的区分。</p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h3><p>正如上面讨论的，一个页面由多个 widget 组成。因此，一个页面看起来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;body ontouchstart&gt;</div><div class="line">  &lt;div class=&quot;wrapper&quot;&gt;</div><div class="line">    &lt;!-- S 主会场头部 --&gt;</div><div class="line">    &lt;%= widget.load(&quot;app_market_main_header&quot;) %&gt;</div><div class="line">    &lt;!-- E 主会场头部 --&gt;</div><div class="line">    &lt;!-- S 达人问答区 --&gt;</div><div class="line">    &lt;%= widget.load(&quot;app_market_answer&quot;) %&gt;</div><div class="line">    &lt;!-- E 达人问答区 --&gt;</div><div class="line">    &lt;!-- S 优惠券 --&gt;</div><div class="line">    &lt;%= widget.load(&quot;app_market_coupons&quot;) %&gt;</div><div class="line">    &lt;!-- E 优惠券 --&gt;</div><div class="line">    &lt;!-- S 达人集中营 --&gt;</div><div class="line">    &lt;%= widget.load(&quot;app_market_camp&quot;) %&gt;</div><div class="line">    &lt;!-- E 达人集中营 --&gt;</div><div class="line">    &lt;!-- S 达人穿搭公式 --&gt;</div><div class="line">    &lt;%= widget.load(&quot;app_market_collocation&quot;) %&gt;</div><div class="line">    &lt;!-- E 达人穿搭公式 --&gt;</div><div class="line">    &lt;!-- S 卡券相关弹框 --&gt;</div><div class="line">    &lt;%= widget.load(&quot;app_market_dialog&quot;) %&gt;</div><div class="line">    &lt;!-- E 卡券相关弹框 --&gt;</div><div class="line">  &lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>widget 一般存在可复用性。但如何控制细粒度呢？分得越细代码就越简洁，但工作量和维护难度可能会上升，因此需要权衡你当时的情况。</p>
<h3 id="CSS-命名"><a href="#CSS-命名" class="headerlink" title="CSS 命名"></a>CSS 命名</h3><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>由于一个项目中，一个模块由某一个人负责，但模块之间的 widget 存在或未来存在可复用的可能（而且开发可能会为你的页面添加已有的组件，如页面会嵌在某 APP 内，该 APP 已有现成的一些提示框）。因此，需要命名空间将其它们进行区分以防止冲突。由于 CSS 不存在命名空间，因此只能通过类似 BEM 的方式（具体根据团队的规范），如：<code>app_market_header</code>、<code>app_market_list_item</code>。<code>app_market</code> 是模块（即某个活动）的标识，在该项目下，它是唯一的。</p>
<p>另外，还有一点：类名是否要按照 html 层级关系层层添加呢？如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div.app_market_header</div><div class="line">    div.app_market_header_icon</div><div class="line">    div.app_market_header_**</div></pre></td></tr></table></figure></p>
<p>对于 <code>app_market_header_icon</code>，尽管在 header 中，但 icon 并不只属于 header，而属于整个模块（活动），那么我们就可以改为 <code>app_market_icon</code>。</p>
<h4 id="命名存在的问题"><a href="#命名存在的问题" class="headerlink" title="命名存在的问题"></a>命名存在的问题</h4><p>老司机 Code review 后，讲了以下内容：<br>反面教材：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;app_market_answer&quot;&gt;</div><div class="line">  &lt;div class=&quot;app_market_secheader&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;app_market_answer_list&quot;&gt;</div><div class="line">    &lt;div class=&quot;app_market_answer_item&quot;&gt;</div><div class="line">      &lt;div class=&quot;app_market_answer_item_top&quot;&gt;&lt;/div&gt;</div><div class="line">      &lt;div class=&quot;app_market_answer_item_middle&quot;&gt;&lt;/div&gt;</div><div class="line">      &lt;a href=&quot;javascript:;&quot; class=&quot;app_market_answer_item_bottom&quot;&gt;去围观&lt;/a&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>存在的问题是：嵌套层级越深，类名就越长。</p>
<p>较好的解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;app_market_answer&quot;&gt;</div><div class="line">  &lt;div class=&quot;app_market_secheader&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;app_market_answer_list&quot;&gt;</div><div class="line">    &lt;div class=&quot;app_market_answer_item&quot;&gt;</div><div class="line">      &lt;div class=&quot;app_market_answer_itop&quot;&gt;&lt;/div&gt;***</div><div class="line">      &lt;div class=&quot;app_market_answer_imid&quot;&gt;&lt;/div&gt;***</div><div class="line">      &lt;a href=&quot;javascript:;&quot; class=&quot;app_market_answer_ibtm&quot;&gt;去围观&lt;/a&gt;***</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这是基于『姓名』原理进行优化的，举例：<code>app_market_answer_item</code> 是姓名（库日天），那么它的子元素只需继承它的『姓』（库姆斯） <code>app_market_answer_itop</code>，而不是它的姓名（库日天姆斯） <code>app_market_answer_item_top</code>。每当类名达到三到四个单词长时，就要考虑简化名字。</p>
<p>进一步优化，app_market 可以看成是『复姓』，有时为了书写便利，可以以两个单词的首字母结合形成一个新的『新姓』- 『am』。当然，追求便利的副作用是牺牲了代码的可读性。如果你负责的项目或页面没有太大的二次维护或者交叉维护的可能性，推荐做此简化。</p>
<p>BTW：此简化后的『姓』可以在代码中稍加注释说明，如下代码所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!-- am = app_market --&gt;</div><div class="line">&lt;div class=&quot;am_answer&quot;&gt;</div><div class="line">  &lt;div class=&quot;am_secheader&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;am_answer_list&quot;&gt;</div><div class="line">    &lt;div class=&quot;am_answer_item&quot;&gt;</div><div class="line">      &lt;div class=&quot;am_answer_itop&quot;&gt;&lt;/div&gt;</div><div class="line">      &lt;div class=&quot;am_answer_imid&quot;&gt;&lt;/div&gt;</div><div class="line">      &lt;a href=&quot;javascript:;&quot; class=&quot;am_answer_ibtm&quot;&gt;去围观&lt;/a&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h4 id="针对类名书写样式"><a href="#针对类名书写样式" class="headerlink" title="针对类名书写样式"></a>针对类名书写样式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;a href=&quot;javascript:;&quot;&gt;...&lt;/a&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>至少加一个类名，任何时候都尽量要『针对类名书写样式，而不是针对元素书写样式』，除非你能预判元素是末级元素。<br>因此对于以下 CSS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.app_market_coupons &gt; div &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可优化成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.app_market_coupons &gt; .xxx &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="技术涉及"><a href="#技术涉及" class="headerlink" title="技术涉及"></a>技术涉及</h2><h3 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h3><p>移动端采用 rem 布局方式。通过动态修改 html 的 font-size 实现自适应。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>REM 布局有两种实现方式：CSS 媒介查询和 JavaScript 动态修改。由于 JavaScript 更为灵活，因此现在更多地采用此方式。</p>
<h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><p>凹凸的实现方式是：在 <code>head</code> 标签末加入以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    !function()&#123;</div><div class="line">      var maxWidth=750;</div><div class="line">      document.write(&apos;&lt;style id=&quot;o2HtmlFontSize&quot;&gt;&lt;/style&gt;&apos;);</div><div class="line">      var o2_resize=function()&#123;</div><div class="line">          var cw,ch;</div><div class="line">          if(document&amp;&amp;document.documentElement)&#123;</div><div class="line">              cw=document.documentElement.clientWidth,ch=document.documentElement.clientHeight;</div><div class="line">          &#125;</div><div class="line">          if(!cw||!ch)&#123;</div><div class="line">              if(window.localStorage[&quot;o2-cw&quot;]&amp;&amp;window.localStorage[&quot;o2-ch&quot;])&#123;</div><div class="line">                  cw=parseInt(window.localStorage[&quot;o2-cw&quot;]),ch=parseInt(window.localStorage[&quot;o2-ch&quot;]);</div><div class="line">              &#125;else&#123;</div><div class="line">                  chk_cw();//定时检查</div><div class="line">                  return ;//出错了</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          var zoom=maxWidth&amp;&amp;maxWidth&lt;cw?maxWidth/375:cw/375,zoomY=ch/603;//由ip6 weChat</div><div class="line">          window.localStorage[&quot;o2-cw&quot;]=cw,window.localStorage[&quot;o2-ch&quot;]=ch;</div><div class="line">          //zoom=Math.min(zoom,zoomY);//保证ip6 wechat的显示比率</div><div class="line">          window.zoom=window.o2Zoom=zoom;</div><div class="line">          document.getElementById(&quot;o2HtmlFontSize&quot;).innerHTML=&apos;html&#123;font-size:&apos;+(zoom*20)+&apos;px;&#125;.o2-zoom,.zoom&#123;zoom:&apos;+(zoom/2)+&apos;;&#125;.o2-scale&#123;-webkit-transform: scale(&apos;+zoom/2+&apos;); transform: scale(&apos;+zoom/2+&apos;);&#125; .sq_sns_pic_item,.sq_sns_picmod_erea_img&#123;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scale(&apos;+zoom/2+&apos;);transform: scale(&apos;+zoom/2+&apos;);&#125;&apos;;</div><div class="line">      &#125;,</div><div class="line">      siv,</div><div class="line">      chk_cw=function()&#123;</div><div class="line">          if(siv)return ;//已经存在</div><div class="line">          siv=setInterval(function()&#123;</div><div class="line">              //定时检查</div><div class="line">              document&amp;&amp;document.documentElement&amp;&amp;document.documentElement.clientWidth&amp;&amp;document.documentElement.clientHeight&amp;&amp;(o2_resize(),clearInterval(siv),siv=undefined);</div><div class="line">          &#125;,100);</div><div class="line">      &#125;;</div><div class="line">      o2_resize();//立即初始化</div><div class="line">      window.addEventListener(&quot;resize&quot;,o2_resize);</div><div class="line">  &#125;();</div><div class="line">  &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>从以上代码可得出以下信息：  </p>
<ol>
<li>以 iPhone 6 为基准，iPhone 6 的缩放比 <code>zoom</code> 为 <code>1</code></li>
<li>由于只针对移动端，因此最大宽度为768（恰好等于 iPad 的竖屏宽度）</li>
<li>通过 document.documentElement.clientWidth 获取视口宽度</li>
<li>resize 事件主要考虑横竖屏切换和你在PC上调试时🙃</li>
<li>zoom 系数是 20。系数决定了在宽度 375 的 iPhone6 下，1 rem 的值是多少 px（20px）。当然如果想过渡到 vw，可以将 zoom 系数设置为 3.75，那么 100rem 就是 375px 了</li>
</ol>
<h4 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a>为什么要用</h4><p>有人说 rem 布局是 <code>vw</code> 和 <code>vh</code> 的替换方案，当 <code>vw</code> 和 <code>vh</code> 成熟时，两者可能会各司其职吧。</p>
<blockquote>
<p><a href="http://caniuse.com/#search=vw" target="_blank" rel="external">vw 的兼容性</a>：在安卓 4.3 及以下是不支持的。</p>
</blockquote>
<h5 id="哪些地方要用"><a href="#哪些地方要用" class="headerlink" title="哪些地方要用"></a>哪些地方要用</h5><p>由于 rem 布局是相对于视口宽度，因此任何需要根据屏幕大小进行变化的元素（width、height、position 等）都可以用 rem 单位。</p>
<p>但 rem 也有它的缺点——不精细（在下一节阐述），其实这涉及到了浏览器渲染引擎的处理。因此，对于需要精细处理的地方（如通过 CSS 实现的 icon），可以用 px 等绝对单位，然后再通过 transform: scale() 方法等比缩放。</p>
<h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p>那 <code>font-size</code> 是否也要用 rem 单位呢？ 这也是我曾经纠结的地方。如果不等比缩放，对不起设计师，而且对于小屏幕，一些元素内的字体会换行或溢出。当然这可以通过 CSS3 媒介查询解决这种状况。</p>
<p>字体不采用 rem 的好处是：在大屏手机下，能显示更多字体。</p>
<p>看到 <a href="http://3g.163.com/" target="_blank" rel="external">网易新闻</a> 和 <a href="https://jhs.m.taobao.com/m/index.htm#!all" target="_blank" rel="external">聚划算</a> 的字体大小都采用 rem 单位，我就不纠结了。当然，也有其它网站是采用绝对单位的，两者没有绝对的对与错，取决于你的实际情况。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="小数点（不精细，有间隙）"><a href="#小数点（不精细，有间隙）" class="headerlink" title="小数点（不精细，有间隙）"></a>小数点（不精细，有间隙）</h5><p>由于 rem 布局是基于某一设备实现的（目前一般采用 iPhone6），对于 375 倍数宽的设备无疑会拥有最佳的显示效果。而对于非 375 倍数宽的设备，zoom 就可能是拥有除不尽的小数，根元素的字体大小也相应会有小数。而浏览器对小数的处理方式不一致，导致该居中的地方没完全居中，但你又不能为此设置特定样式（如 margin-top: *px;），因为浏览器多如牛毛，这个浏览器微调居中了，而原本居中的浏览器变得不居中了。</p>
<p>对于图标 icon，rem 的不精细导致通过多个元素（伪元素）组合而成的 icon 会形成错位/偏差。因此，在这种情况下，需要权衡是否需要使用 CSS 实现了。</p>
<h3 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h3><p>SASS 无疑增强了原本声明式的 CSS，为 CSS 注入了可编程等能力。在这次项目，算是我第一次使用 SASS，由于构建工具和基础库的完善，只需通过查看/模仿已有项目的 SASS 用法，就能快速上手。后续还是要系统地学习，以更合理地使用 SASS。</p>
<p>使用 SASS 的最大问题是：层级嵌套过深，这也是对 SASS 理解不深入的原因。可以关注一下转译后的 CSS。</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>这次项目的 APP 采用手机自带浏览器内核，而这些浏览器内核依赖于系统版本等因素。另外，国产机也会对这些内核进行定制和修改。特别是华为、OPPO。</p>
<p>下面列出我所遇到的兼容性问题（不列具体机型，因为这些兼容性处理终会过时，不必死记硬背，遇到了能解决就好（要求基础扎实））：</p>
<ul>
<li>flexbox：在构建工具处理下（实现了新旧语法）可以大胆用，但个别设备不支持 flex-wrap: wrap。因此对于想使用 flex-wrap 实现自动分行的情况，建议使用其他实现。如果个数固定（如 N  行，每行 M 个），则可使用 N 个 flexbox（这样就可以使用 flexbox 的特性了）。flexbox 的其他属性也有支持不好的情况，可以通过显式声明 display、overflow、width、height 等方法解决。</li>
<li>background-size：需要单独写，否则在 <a href="http://caniuse.com/#search=background-size" target="_blank" rel="external">安卓 4.3 及以下，IOS 6.1及以下不兼容</a>。</li>
<li>渐变：线性渐变大胆使用，径向渐变有兼容性问题。但是不建议对整体背景使用，会有性能问题（可简单地通过 1px 高的图片替代，注意，不要 background-size: 100% auto; 应该采用 background-size: 100% 1px; 因为有些浏览器（视口宽度较小）会忽略小数点【<code>auto = img.Height * (screen.Width/img.Width)</code>】，导致图片未显示）。另外，需要注意的是：透明的色标在iOS 默认是黑色的，即 transparent 等于 rgba(0,0,0,0)。因此即使是完全透明的色标，也要指定颜色。否则后果如下：<br><img src="//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/linear-gradient.jpg" alt="此处输入图片的描述"></li>
<li>classlist.remove(String[, String])，传递多个参数时，会有不兼容的情况。建议每次写一个。add (String[, String])同理。</li>
<li><p>根节点 html font-size 渲染错误：在华为、魅族的某设备上（手Q），会出现一个非常奇葩的渲染 Bug，同一个网页，“扫一扫”打开 html 的 font-size 正常，直接点击链接会出现<strong>渲染出来的 html font-size 会比设置得值大</strong>（如：设置25.8，渲染出来是 29），因此导致整体变大，且布局错乱。<br>我的方法是：为 html font-size 重新设置大小：渲染字体大小 - (渲染与正常差值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getStyle(ele, style) &#123;</div><div class="line">    return document.defaultView.getComputedStyle(ele, null)[style]</div><div class="line">&#125;</div><div class="line">;(function fixFontSize() &#123;</div><div class="line">    var target = window.o2Zoom * 20</div><div class="line">    var cur = parseInt(getStyle(document.documentElement, &quot;fontSize&quot;))</div><div class="line">    while(cur - target &gt;= 1) &#123;</div><div class="line">        document.documentElement.style[&quot;fontSize&quot;] = target - (cur - target) + &quot;px&quot;</div><div class="line">        cur = parseInt(getStyle(document.documentElement, &quot;fontSize&quot;))</div><div class="line">    &#125;          </div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>有网友提供这个方法 <code>&lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&gt;</code>，经测试不可行。此方法是针对 UC 浏览器的。</p>
<p>上面主要列出了对使用有影响的兼容性问题，有些由于浏览器渲染引擎导致的问题（不影响使用），若无法通过 transform、z-index 等解决，也许只能通过 JavaScript 解决或进行取舍了。</p>
<h3 id="其他一些知识点"><a href="#其他一些知识点" class="headerlink" title="其他一些知识点"></a>其他一些知识点</h3><ul>
<li><p>图片占位元素：对于宽高比例固定的坑位（如商品列表项），通过将图片放置在占位元素中，可避免图片加载时引起的页面抖动和图片尺寸不一致而导致的页面布局错乱。代码实现：</p>
<pre><code>.img_placeholder {
  position: relative;
  height: 0;
  overflow: hidden;
  padding-top: placeholder 的高/宽%; // padding-top/bottom: 百分比; 是基于父元素的宽度
  img {
      width: 100%;
      height: auto;
      position: absolute;
      left: 0;
      top: 0;
  }
}
</code></pre></li>
<li><p>1px：在 retina 屏幕下，1 CSS像素是用 4 个物理像素表示，为了在该屏幕下显示更精细，通过为 ::after 应用以下代码（以上边框为例）：</p>
<pre><code>div {
    position: relative;
    &amp;::after {
        content: &apos;&apos;;
        position: absolute;
        z-index: 1;
        pointer-events: none;
        background: $borderColor;
        height: 1px;left: 0;right: 0;top: 0;
        @media only screen and (-webkit-min-device-pixel-ratio:2) {
            &amp;{
                -webkit-transform: scaleY(0.5);
                -webkit-transform-origin: 50% 0%;
            }
        }
    }
}
</code></pre></li>
<li><p>根据元素个数应用特定样式：</p>
<pre><code>/* one item */
li:first-child:nth-last-child(1) {
    width: 100%;
}
/* two items */
li:first-child:nth-last-child(2),
li:first-child:nth-last-child(2) ~ li {
    width: 50%;
}
/* three items */
li:first-child:nth-last-child(3),
li:first-child:nth-last-child(3) ~ li {
    width: 33.3333%;
}
/* four items */
li:first-child:nth-last-child(4),
li:first-child:nth-last-child(4) ~ li {
    width: 25%;
}
</code></pre><p>  应用样例有：根据元素个数自适应标签样式。<br>  <img src="//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/tag1.png" alt="根据元素个数自适应标签样式"><br>  而对于反方向标签，可先首先对整体 transform: scale(-1)，然后再对字体 transform: scale(-1) 恢复从左向右的方向。效果如下：<br><img src="//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/tag2.png" alt="标签反向">  </p>
</li>
<li>卡券：『带孔且背景是渐变的卡券』在复杂背景中的实现。由于背景是复杂的（非纯色），因此孔不能简单地通过覆盖（与背景同色）产生。这里可以应用径向渐变 <code>background-image: radial-gradient(rem(189/2) 100%, circle, transparent 0, transparent 3px, #fa2c66 3px);</code>，其中 3px 是孔的半径。另外，卡券的上下部分是线性渐变的，因此可以在上下部分分别通过伪类元素添加 <code>background-image: linear-gradient(to top, #fa2e67 0, #fb5584 100%);</code>，当然，要从离外上/下边界 3px 的地方开始。虽然这不能完美地从最边界开始，但效果还是可以的。但由于径向渐变的兼容性问题，我最终还是用图片替换了这种实现。🙄<br><img src="//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/coupon.png" alt="带孔且背景是渐变的卡券">  </li>
<li>多行文本的多行padding：让背景只出现在有文字的地方，可直接设置 <code>display: inline;</code>，但还会存在一个问题是：padding 只会出现在多行文本的首和尾，对于需要为每行文本的首尾都需要相同的 padding，可以参考这篇文章：<a href="https://css-tricks.com/multi-line-padded-text/" target="_blank" rel="external">《multi-line-padded-text》</a> 。该文章提供了多种实现方式，根据具体情况选择一种即可。另外，对于每行的间距，可通过设置 line-height 和 padding-top/bottom 实现，其中 line-height 要大于（字体高度+padding-top/bottom）。<br><img src="//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/multi-line1.png" alt="此处输入图片的描述"><br><img src="//misc.aotu.io/JChehe/2016-11-08-first-mobile-rebuild/multi-line2.png" alt="此处输入图片的描述">  </li>
<li>最小字体限制：PC上最小字体是 12px、移动端最小是 8px，当然可通过 transform:scale() 突破限制。</li>
</ul>
<h3 id="不止页面页面制作"><a href="#不止页面页面制作" class="headerlink" title="不止页面页面制作"></a>不止页面页面制作</h3><ol>
<li>基础：合理运用 CSS 的威力更好地完成对设计稿的重现目的。  </li>
<li>沟通：由于分工较细，只负责页面制作的同学，需要与产品和设计沟通，以达到交给开发后更少修改的目的。如哪些地方可跳转、哪些地方最多显示几行文字、超出如何处理（直接隐藏/省略号等）、坑位中的图片摆放（顶部对齐/居中等）等等。  </li>
<li>代码上的沟通：HTML 注释要写好、HTML 与 CSS 代码要规范（命名等）清晰。  </li>
</ol>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>由于工具的成熟，我不需要考虑构建工具的搭建。<br>由于发布方式的成熟，页面制作和开发能更好地分离，页面制作者负责输出 HTML、CSS，开发负责 copy html 代码和引入 CSS 页面片。CSS 页面片由页面制作者更新发布，开发无需关心。这达到了互不干扰、多线程并行的效果。<br>成熟的基础设施让我们免除了非代码相关的烦恼，但这也让我担心：假如有一天我脱离了这些基础设施，我该如何保持高效。</p>
<h4 id="延伸：页面片是什么？"><a href="#延伸：页面片是什么？" class="headerlink" title="延伸：页面片是什么？"></a>延伸：页面片是什么？</h4><p>CSS 页面片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- #include virtual=&quot;/folder/branch.shtml&quot; --&gt;</div><div class="line">&lt;link combofile=&quot;/folder/branch.shtml&quot; rel=&quot;stylesheet&quot; href=&quot;//website/folder/gb.min_1151b5b0.css,/folder/branch.min_925332fc.css&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>JS 页面片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- #include virtual=&quot;/folder/branch_js.shtml&quot; --&gt;</div><div class="line">&lt;script combofile=&quot;/folder/branch.shtml&quot; src=&quot;//website/path/branch.min_8971778a.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Combo Handler是Yahoo!开发的一个Apache模块，它实现了开发人员简单方便地通过URL来合并JavaScript和CSS文件，从而大大减少文件请求数。 <a href="http://www.cnblogs.com/zhengyun_ustc/archive/2012/07/18/combo.html" target="_blank" rel="external">http://www.cnblogs.com/zhengyun_ustc/archive/2012/07/18/combo.html</a></p>
</blockquote>
<hr>
<p>这就是我的第一次…🙈 学习很多，完！</p>
<p>以上仅是我个人完成某项目页面制作的思考和总结，不小心暴露了团队下限。🌚</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被分配到移动端开发组，支持某活动的页面页面制作。这算是我第一次真正接触移动端页面制作，下面就谈谈个人总结和思考。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="mobile-rebuild html css" scheme="http://yoursite.com/tags/mobile-rebuild-html-css/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 WebVR</title>
    <link href="http://yoursite.com/2016/08/23/2016-8-23-webvr/"/>
    <id>http://yoursite.com/2016/08/23/2016-8-23-webvr/</id>
    <published>2016-08-23T06:24:26.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>“目镜在他眼前涂上了一抹朦胧的淡色，映射着一幅弯曲的广角画面：一条灯火辉煌的大街，伸向无尽的黑暗。但这大街其实并不存在，它只是电脑绘出的一片虚拟的空间。”——《Snow Crash》，Neal Stephenson 1992年</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是-VR"><a href="#什么是-VR" class="headerlink" title="什么是 VR"></a>什么是 VR</h2><p>VR（Virtual Reality）是利用电脑模拟产生一个三维空间的虚拟世界，提供用户关于视觉等感官的模拟，让用户感觉仿佛身历其境，可以及时、没有限制地观察三维空间内的事物。用户进行位置移动时，电脑可以立即进行复杂的运算，将精确的三维世界视频传回产生临场感。—— 维基百科</p>
<h3 id="VR-的显示原理"><a href="#VR-的显示原理" class="headerlink" title="VR 的显示原理"></a>VR 的显示原理</h3><p>了解 VR 显示原理前，先了解我们人眼的立体视觉的成像原理：  </p>
<p>人眼的视觉是可以感觉出深度的，也就是<strong>深度知觉（depth perception）</strong>。而有了深度的信息后，才能判断出立体空间的相对位置。</p>
<p>另外，由于两个眼睛的位置不一样（一般人两眼相距 5~7 厘米），所以看到的东西会有<strong>两眼视差（binocular parallax）</strong>，大脑再将这两个图像做融合处理，从而产生立体的感觉（即所谓的 binocular cues）。</p>
<p><img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/vision.png" alt="立体视觉"><br>立体视觉</p>
<h3 id="头戴式显示器（Head-mounted-Display）"><a href="#头戴式显示器（Head-mounted-Display）" class="headerlink" title="头戴式显示器（Head-mounted Display）"></a>头戴式显示器（Head-mounted Display）</h3><p>头戴式显示器（HMD）是 VR 目前最常见的一种体验方式。它的原理是将小型二维显示器所产生的图像经由光学系统放大。具体而言，小型显示器所发射的光线经过凸状透镜使图像因折射产生类似远方效果。利用此效果将近处物体放大至远处观赏，从而达到所谓的全息视觉（Hologram）。另外，显示器被分为左右两个部分，分别显示左右眼看到的图像。大脑再将左右眼所看到的图像（两眼视差）做融合处理，从而产生 3D 效果。同时，HMD  会根据头部运动让视角与之同步。综合上述特性，用户通过 HMD 体验 VR 时就如同在现实中观看一样，这种体验也被称为沉浸式体验。</p>
<p><img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/HMD.jpg" alt="此处输入图片的描述"><br>HMD 原理示意图</p>
<h4 id="HMD-种类"><a href="#HMD-种类" class="headerlink" title="HMD 种类"></a>HMD 种类</h4><p>目前市场上主要有以下 3 种 HMD 设备：</p>
<ul>
<li>滑配式<br> 这是目前最初级、价格最低的 HMD 设备。它与智能手机相连接，将 2D 显示变成 3D VR 显示。滑配式 HMD 设备强烈依赖于主机系统（智能手机），后者是提供 VR 效果的必备部分。<br> 厂商：滑配式 HMD 设备包括谷歌 Carboard 和三星 Gear VR。</li>
<li>分离式<br>分离式 HMD 设备较滑配式 HMD 设备复杂，内置多种电子零部件。两者的主要不同是，分离式 HMD  设备拥有自己的显示屏，也可能配备自己的处理器（提供简单计算能力）。虽然分离式 HMD 设备不能独立于主机系统而工作，但却为 VR 市场创造了新的机会，因为主机系统已不再局限于智能手机，PC 和视频游戏机也能用于提供 VR 体验。总之，分离式 HMD 设备能提供高质量的 VR 体验。<br> 厂商：分离式 HMD 设备包括 Facebook Oculus Rift、HTC Vive 和 PlayStation VR。</li>
<li>整合式<br>整合式 HMD 设备拥有强大的计算能力和追踪系统。作为一款独立的计算设备，整合式 HMD 设备将配备一整套零部件，价格甚至高于普通 PC。<br> 厂商：微软 HoloLens（AR）</li>
</ul>
<p>对于想初步体验或入门 VR 的用户，推荐谷歌的 Carboard 或国内的性价比高的滑配式设备。<br><img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/google-cardboard.jpg" alt="此处输入图片的描述"><br>Google Carboard</p>
<h3 id="VR-周边设备"><a href="#VR-周边设备" class="headerlink" title="VR 周边设备"></a>VR 周边设备</h3><p>VR 是最具科幻色彩以及梦幻体验的东西，单独一个 HMD 并不能发挥 VR 的最大效果，加上“属性加成”的周边才能体验极致的 VR。</p>
<p>2015 年，澳大利亚开设了世界首家 VR 沉浸式竞技游戏店—— <a href="https://www.zerolatencyvr.com/" target="_blank" rel="external">Zero Latency</a>。 这家店拥有 4300 平方英尺，安装有 129 台 PlayStation Eye 摄像头，用于捕捉玩家的动作。整套系统可以最多同时供 6 名玩家进行游戏。<br><img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/Zero%20Latency.jpg" alt="此处输入图片的描述"><br>现实与虚拟</p>
<p>当然，各式各样的 VR 周边设备也越来越多，如 Virtuix Omni 跑步机：<br> <img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/Virtuix%20Omni.gif" alt="此处输入图片的描述"><br>Virtuix Omni</p>
<p>这些设备无疑会增强了 VR 的体验，给用户带来更加刺激与逼真的体验。</p>
<h2 id="WebVR"><a href="#WebVR" class="headerlink" title="WebVR"></a>WebVR</h2><p>上文说了这么多关于 VR 的东西，视乎还没有入正题（⊙﹏⊙)）   </p>
<p>许多 VR 体验是以应用程序的形式呈现的，这意味着你在体验 VR 前，必须进行搜索与下载。而 Web VR 则改变了这种形式，它将 VR  体验搬进了浏览器，Web + VR = WebVR。  </p>
<p>下面根据我目前的见解，分析一下 WebVR 的现状。</p>
<h3 id="WebVR-草案"><a href="#WebVR-草案" class="headerlink" title="WebVR 草案"></a>WebVR 草案</h3><blockquote>
<p>WebVR 是早期和实验性的 JavaScript API，它提供了访问如 Oculus Rift 和 Google Cardboard 等 VR 设备功能的 API。</p>
</blockquote>
<p>VR 应用需要高精度、低延迟的接口，才能传递一个可接受的体验。而对于类似 Device Orientation Event 接口，虽然能获取浅层的 VR 输入，但这并不能为高品质的 VR 提供必要的精度要求。WebVR 提供了专门访问 VR 硬件的接口，让开发者能构建舒适的 VR 体验。</p>
<p>WebVR API 目前可用于安装了 Firefox nightly 的 Oculus Rift、Chrome 的实验性版本和 Samsung Gear VR 的浏览器。当然，如果你现在就想在你的移动端浏览器体验 WebVR，可以使用 <a href="https://github.com/borismus/webvr-polyfill" target="_blank" rel="external">WebVR Polyfill</a>。</p>
<h3 id="WebVR-开发"><a href="#WebVR-开发" class="headerlink" title="WebVR 开发"></a>WebVR 开发</h3><p>在 Web 上开发 VR 应用，有下面三种（潜在）方式：</p>
<ol>
<li>JavaScript, Three.js 与 监听设备方向（Device Orientation）</li>
<li>JavaScript, Three.js 与 WebVR</li>
<li>CSS 与 WebVR（仍处于非常早期阶段）</li>
</ol>
<p>由于 WebVR 仍处于草案阶段并可能会有所改变，所以建议你基于 <a href="https://github.com/borismus/webvr-boilerplate" target="_blank" rel="external">webvr-boilerplate</a> 进行 WebVR 开发。</p>
<h4 id="A-Frame"><a href="#A-Frame" class="headerlink" title="A-Frame"></a>A-Frame</h4><p>上面说道，在 Web 上开发 VR 应用有 3 种（潜在）方式，前两种都离不开直接接触 Three.js，而第三种方式则为时尚早。对于没接触过 Three.js，但又想体验一把 WebVR 开发的同学们来说，无疑会存在一定的门槛。</p>
<p>如果你想以较低的门槛体验一把 WebVR 开发，那么可以试试 <a href="https://mozvr.com/#team" target="_blank" rel="external">MozVR 团队</a> 开发的 A-Frame 框架。</p>
<p>PS：写着写着，A-Frame 的版本从 v0.2 升到到 v0.3（这很前端），但文档等各方面变得更加完善了。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><a href="https://aframe.io/" target="_blank" rel="external">A-Frame</a> 是一个通过 HTML 创建 VR 体验的开源 WebVR 框架。通过该框架构建的 VR 场景能兼容智能手机、PC、 Oculus Rift 和 HTC Vive。</p>
<p>MozVR 团队开发的 A-Frame 框架的目的是：让构建 3D/VR 场景变得更易更快，以吸引 web 开发社区进入 WebVR 的生态。WebVR 要成功，需要有内容。但目前只有很少一部分 WebGL 开发者，却有数以百万的 Web 开发者与设计师。A-Frame 要把 3D/VR 内容的创造权力赋予给每个人。</p>
<h4 id="优势与特点"><a href="#优势与特点" class="headerlink" title="优势与特点"></a>优势与特点</h4><ul>
<li>A-Frame 能减少冗余代码。冗余复杂的代码成为了尝鲜者的障碍，A-Frame 将复杂冗余的代码减至一行 HTML 代码，如创建场景则只需一个 <code>&lt;a-scene&gt;</code> 标签。</li>
<li>A-Frame 是专为 Web 开发者设计的。它基于 DOM，因此能像其它 Web 应用一样操作 3D/VR 内容。当然，也能结合 box、d3、React 等 JavaScript 框架一起使用；</li>
<li>A-Frame 让代码结构化。Three.js 的代码通常是松散的，A-Frame 在 Three.js  之上构建了一个声明式的实体组件系统（entity-component-system）。另外，组件能发布并分享出去，其它开发者能以 HTML 的形式进行使用。</li>
</ul>
<p><img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/asence.gif" alt="此处输入图片的描述"><br>减少冗余复杂的代码</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>talk is cheap，show me the c… hello world.</p>
<p><a href="http://codepen.io/mozvr/pen/BjygdO/" target="_blank" rel="external">A-Frame 的 Hello world</a><br><img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/aframe.gif" alt="此处输入图片的描述"><br>在手机的浏览器（如：Chrome、QQ浏览器）中呈现的效果</p>
<p>实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 引入aframe框架</div><div class="line">&lt;script src=&quot;./aframe.min.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;a-scene&gt;</div><div class="line">  &lt;!-- 球体 --&gt;</div><div class="line">  &lt;a-sphere position=&quot;0 1 -1&quot; radius=&quot;1&quot; color=&quot;#EF2D5E&quot;&gt;&lt;/a-sphere&gt;</div><div class="line">  &lt;!-- 盒（此处是立方体） --&gt;</div><div class="line">  &lt;a-box width=&quot;1&quot; height=&quot;1&quot; rotation=&quot;0 45 0&quot; depth=&quot;1&quot; color=&quot;#4CC3D9&quot; position=&quot;-1 0.5 1&quot;&gt;&lt;/a-box&gt;	</div><div class="line">  &lt;!-- 圆柱 --&gt;</div><div class="line">  &lt;a-cylinder position=&quot;1 0.75 1&quot; radius=&quot;0.5&quot; height=&quot;1.5&quot; color=&quot;#FFC65D&quot;&gt;&lt;/a-cylinder&gt;</div><div class="line">  &lt;!-- 平面 --&gt;</div><div class="line">  &lt;a-plane rotation=&quot;-90 0 0&quot; width=&quot;4&quot; height=&quot;4&quot; color=&quot;#7BC8A4&quot;&gt;&lt;/a-plane&gt;</div><div class="line">  &lt;!-- sky元用于为场景添加背景图或显示360度的全景图 --&gt;</div><div class="line">  &lt;a-sky color=&quot;#ECECEC&quot;&gt;&lt;/a-sky&gt;</div><div class="line">  &lt;!-- 用于指定摄像机的位置 --&gt;</div><div class="line">  &lt;a-entity position=&quot;0 0 4&quot;&gt;</div><div class="line">    &lt;a-camera&gt;&lt;/a-camera&gt;</div><div class="line">  &lt;/a-entity&gt;</div><div class="line">&lt;/a-scene&gt;</div></pre></td></tr></table></figure></p>
<p>基本概念（以 v0.3 版本为参考）：</p>
<ul>
<li>该框架的三维坐标轴遵循<strong>右手坐标系</strong>，具体如下图：<br><img src="https://misc.aotu.io/JChehe/2016-8-24-webvr/coordinate.jpg" alt="此处输入图片的描述"></li>
<li>场景的原点默认在视口底边的中点</li>
<li>position 相当于 CSS3 中的 translate3d</li>
<li>以<strong>米</strong>为单位长度</li>
<li>height 与 width 是正面的长和宽，depth表示深度（厚度）</li>
<li>rotation=”x y z” 单位<strong>角度（°）</strong>，拇指指向坐标轴的正方向，其余手指卷起来的方向就是该轴的旋转正方向。</li>
<li>color 是材质颜色，默认是白色（#FFF）</li>
<li>在 PC 中，可通过鼠标与键盘 WSAD 进行交互</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当然，上述案例只是 A-Frame 的 Hello World demo。若你感兴趣，可以深入学习，再结合自己的想法，相信你能作出让人拍手称赞的作品。</p>
<ul>
<li>A-Frame 官网：<a href="https://aframe.io/" target="_blank" rel="external">https://aframe.io/</a></li>
<li>A-Frame Blog：<a href="https://aframe.io/blog/" target="_blank" rel="external">https://aframe.io/blog/</a></li>
<li>Awesome A-Frame：<a href="https://github.com/aframevr/awesome-aframe" target="_blank" rel="external">https://github.com/aframevr/awesome-aframe</a></li>
</ul>
<h3 id="其它一些-WebVR-案例"><a href="#其它一些-WebVR-案例" class="headerlink" title="其它一些 WebVR 案例"></a>其它一些 WebVR 案例</h3><p>下面就列举一些 WebVR 的相关案例，如果你已具备了 VR 的体验环境，不妨体验一下。</p>
<ul>
<li><a href="https://www.beloola.com/" target="_blank" rel="external">Beloola</a>：Beloola 是一个基于 WebVR 的社交平台，它允许人们在同一个虚拟的空间上实时进行情感交流。</li>
<li><a href="https://sketchfab.com/" target="_blank" rel="external">Sketchfab</a>：Sketchfab 是一个不需任何插件即可在 Web 页面里嵌入交互式 3D 模型的服务网站。</li>
<li><a href="http://vizor.io/" target="_blank" rel="external">Vizor</a>：该网站提供了可视化编辑器，让任何人都能在浏览器上创建和分享他们的 VR 内容。</li>
<li><a href="http://vr.chromeexperiments.com/" target="_blank" rel="external">Chrome Experiments for Virtual Reality</a>：Chrome 团队提供的 6 个 VR 案例。</li>
<li>…</li>
</ul>
<p>更多 WebVR 内容等着你们发现</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>许多人将 2016 年称为 VR 元年。VR 的前景有人看好，也有人看衰。但无论如何，新技术的出现都值得我们去体验一番。当然，作为一名开发者，也可以从代码的角度体验一番。</p>
<p>想详细了解更多关于 VR 的行业报告，可以阅读 <a href="http://tech.qq.com/a/20160202/011274.htm" target="_blank" rel="external">《VR与AR：解读下一个通用计算平台》</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://webvr.info/" target="_blank" rel="external">WebVR.info</a></li>
<li><a href="https://aframe.io/" target="_blank" rel="external">A-Frame</a></li>
<li><a href="https://www.sitepoint.com/how-to-build-vr-on-the-web-today/" target="_blank" rel="external">How to Build VR on the Web Today</a></li>
<li><a href="http://tech.qq.com/a/20160202/011274.htm" target="_blank" rel="external">VR与AR：解读下一个通用计算平台</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“目镜在他眼前涂上了一抹朦胧的淡色，映射着一幅弯曲的广角画面：一条灯火辉煌的大街，伸向无尽的黑暗。但这大街其实并不存在，它只是电脑绘出的一片虚拟的空间。”——《Snow Crash》，Neal Stephenson 1992年&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="WebVR" scheme="http://yoursite.com/tags/WebVR/"/>
    
      <category term="VR" scheme="http://yoursite.com/tags/VR/"/>
    
      <category term="Three.js" scheme="http://yoursite.com/tags/Three-js/"/>
    
  </entry>
  
  <entry>
    <title>CSS 3D Panorama</title>
    <link href="http://yoursite.com/2016/08/22/2016-8-22-css-3d-panorama/"/>
    <id>http://yoursite.com/2016/08/22/2016-8-22-css-3d-panorama/</id>
    <published>2016-08-22T06:24:26.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>3D 全景并不是什么新鲜事物了，但以前我们在 Web 上看到的 3D 全景一般是通过 Flash 实现的。若我们能将 <code>CSS3 Transform</code> 的相关知识运用得当，也是能实现类似的效果。换句话说，3D 全景其实就是 CSS3 3D 的应用场景之一。</p>
<a id="more"></a>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在实现 CSS3 3D 全景之前，我们先理清部分 CSS3 Transform 属性：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin" target="_blank" rel="external">transform-origin</a>：元素变形的原点（默认值为 50% 50% 0，该数值和后续提及的百分比均默认基于元素自身的宽高算出具体数值）；</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/perspective" target="_blank" rel="external">perspective</a>: 指定了观察者与 <code>z=0</code> 平面的距离，使具有三维位置变换的元素产生透视效果。（默认值：none，值只能是绝对长度，即负数是非法值）；</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-style" target="_blank" rel="external">transform-style</a>：用于指定其为子元素提供 2D 还是 3D 的场景。另外，该属性是非继承的；</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform" target="_blank" rel="external">transform</a>：该属性能让你修改 CSS 可视化模型的坐标空间，其中包括 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d" target="_blank" rel="external">平移（translate）</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate" target="_blank" rel="external">旋转（rotate）</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale" target="_blank" rel="external">缩放（scale）</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew" target="_blank" rel="external">扭曲（skew）</a>。</li>
</ul>
<p>下面对上述的一些点进行更深入的分析：</p>
<ul>
<li><p>对于 <code>perspective</code>，该属性指定了“眼睛”与元素的 <code>perspective-origin</code> （默认值是 <code>50% 50%</code>）点的距离。那么问题来了：“当我们应用 <code>px</code> 作为衡量单位时，那它的实际距离该如何量化呢（即如何得到我们熟悉且易于表达的距离）？”<br>答：当我们的屏幕的分辨率是 1080P（1920*1080px），且该元素或祖先元素的 perspective 值是 <code>1920px</code> 时，该应用了 CSS3 3D Transform 的元素的立体效果就相当于我们在距离一个屏幕宽度（1920px）的屏幕前观看该元素的真实效果。尽管如此，目前我也不清楚如何准确地为元素设置一个合适的 <code>perspective</code> 值，只能猜测个大概值，然后再动态修改值，以达到满意的呈现效果。<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/perspective.jpg" alt="此处输入图片的描述"><br>根据 <a href="https://zh.wikipedia.org/wiki/%E7%9B%B8%E4%BC%BC%E4%B8%89%E8%A7%92%E5%BD%A2" target="_blank" rel="external">相似三角形</a> 的性质可计算出被前移的元素最终在屏幕上显示的实际大小  </p>
<p> 另外，关于 <code>perspective</code> 还有另外一个重要的点。因为，perspective-origin 的默认值是 <code>50% 50%</code>，因此，对哪个元素应用 <code>perspective</code> 属性，就决定了“眼睛”的位置（即我们的“眼睛”是在哪个角度看物体）。一般来说，当我们需要正视物体时，就会将该属性设置在与该元素中心重合的<strong>某一祖先元素</strong>上。</p>
<p> 再另外，如果说：“如何让一个元素（的背面）不可见？”，你可能会说 <code>backface-visibility:hidden;</code>。其实，对于在“眼睛”背后的元素（以元素的 <code>transform-origin</code> 为参考点），即元素的z轴坐标值大于 perspective 的值，浏览器是不会将其渲染出来的。</p>
</li>
<li><p>对于 <code>transform-style</code>，该属性指定了其<strong>子元素</strong>是处于 3D 场景还是 2D 场景。对于 2D 场景，元素的前后位置是按照平时的渲染方式（即若在普通文档流中，是按照代码中元素的先后顺序，后面的元素会遮住在其前面的元素）；对于 3D 场景，元素的前后位置则按照真实世界的规则排序（即越靠近“眼睛”的，会遮住离“眼睛”更远的元素）。</p>
<p> 另外，由于 <code>transform-style</code> 属性是非继承的，对于中间节点需要显式设定。</p>
</li>
<li><p>对于 <code>transform</code> 属性：下图整理了 rotate3d、translate3d 的变换方向：<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/transform.jpg" alt="transform"><br>transform 中的变换属性的顺序是有关系的，如 translateX(10px) rotate(30deg) 与 rotate(30deg) translateX(10px) 是不等价的。</p>
<p> 另外，需要注意的是 scale 中如果有负数值，则该方向会产生 180 度的翻转；</p>
<p> 再另外，部分 transform 效果会导致元素（字体）模糊，如 translate 的数值存在小数、通过 translateZ 或 scale 放大元素等等。<strong>每个浏览器都有其不同的表现</strong>。</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>上面理清了一些 CSS Transform 的知识点，下面就讲讲如何实现 CSS 3D 全景 ：</p>
<p>想象一下，当我们站在十字路口中间，身体不动，头部旋转 360°，这个过程中所看到的画面就形成了一幅以你为中心的全景图了。其实，当焦距不变时，我们就等同于站在一个圆柱体的中心。  </p>
<p>但是，虚拟世界与现实的最大不同是：没有东西是连续的，即所有东西都是离散的。例如，你无法在屏幕上显示一个完美的圆。你只能以一个正多边形表示圆：边越多，圆就越“完美”。 </p>
<p>同理，在三维空间，每个 3D 模型都等同于一个多面体（即 3D 模型只能由不弯曲的平面组成）。当我们讨论一个本身就是多面体（如立方体）的模型时并不足以为奇，但当我们想展示其它模型时，如球体时，就需要记住这个原理了。<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/ball.png" alt="三维环境的球体"></p>
<p><a href="http://zwj360.im20.com.cn" target="_blank" rel="external">淘宝造物节的活动页</a> 就是 CSS 3D 全景的一个很赞的页面，它将全景图分隔成 20 等份，相邻的元素间差 18°（360/20）。需要注意的是：我们要确保<strong>每个元素的正面是指向圆柱中心的，</strong>所以要计算好每等份的旋转角度值。然后再将元素向外（即 Z 轴方向）平移 <code>r</code> px。对于立方体 <code>r</code> 就是 <code>边长/2</code>，而对于其它更复杂的正多面体呢？  </p>
<p>举例：对于正九面体，每个元素的宽为 <code>210px</code>，对应的角度为 <code>40°</code>，即如下图：<br>图片来自：<a href="https://desandro.github.io/3dtransforms/docs/carousel.html" target="_blank" rel="external">https://desandro.github.io/3dtransforms/docs/carousel.html</a><br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/diagram.png" alt="此处输入图片的描述"><br>正九面体的俯视图  </p>
<p><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/calc.png" alt="此处输入图片的描述"><br>计算过程  </p>
<p>由此得到一个公用函数，只需传入含有<strong>元素的宽度</strong>和<strong>元素数量</strong>的对象，即可得到 <code>r</code> 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function calTranslateZ(opts) &#123;</div><div class="line">  return Math.round(opts.width / (2 * Math.tan(Math.PI / opts.number)))</div><div class="line">&#125;</div><div class="line"></div><div class="line">calTranlateZ(&#123;</div><div class="line">    width: 210,</div><div class="line">    number: 9</div><div class="line">&#125;);  // 288</div></pre></td></tr></table></figure></p>
<p><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/expand4.gif" alt="俯视时所看到的元素外移动画"><br>俯视时所看到的元素外移动画  </p>
<p>另外，为了让下文易于理解，我们约定 html 结构是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#view(perspective:1000px)</div><div class="line">    #stage(transform-style:preserve-3d)</div><div class="line">        #cube(transform-style:preserve-3d)</div><div class="line">            .div（width:600px;height:600px;） /*组成立方体的元素*/</div></pre></td></tr></table></figure></p>
<p>正多面体构建完成后，就需要将我们的“眼睛”放置在正多面体内。由于在“眼睛”后的元素是不会被浏览器所渲染的（与 <code>.div元素</code> 是否设置 <code>backface-visibility:hidden;</code> 无关），且我们保证了 <code>.div元素</code> 的<strong>正面</strong>都指向了正多面体的中心，这就形成 360° 被环绕的效果了。<br>那“眼睛”具体是被放置在哪个位置呢？<br>答：通过设置 <code>#stage</code> 元素的 translateZ 的值，让不能被看到的 <code>.div元素</code> 的 Z 轴坐标值大于 perspective 的值即可。如：立方体的正面的 translateZ 是 -300px（为了保证立方体的正面是指向立方体中心，正面元素需要设置 <code>rotateY(-180deg) translateZ(-300px)</code>，即正面元素向“眼球”方向平移了 300px），而 #view 的 perspective 的值为 1000px，那么 #stage 的 translateZ 的值应该大于 700px 且小于 1300px，具体数值则取决于你想要呈现的效果了。</p>
<p>根据上述知识，我粗略地模仿了“造物节”的效果：<a href="http://jdc.jd.com/lab/zaowu/index_new.html" target="_blank" rel="external">http://jdc.jd.com/lab/zaowu/index_new.html</a></p>
<p>其实，只需 6 幅图就可以实现一张常见的无死角全景图。<br>我自己又试验了下：<a href="http://jdc.jd.com/lab/zaowu/index2.html" target="_blank" rel="external">http://jdc.jd.com/lab/zaowu/index2.html</a>   </p>
<p>可由下图看出，将水平的 4 张图片合成后就是一张全景图：<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/panorama3d.jpg" alt="此处输入图片的描述"></p>
<p>理解上述知识后，就可以通过为元素设置合适的 CSS3 Transform 属性值，即可实现一张可交互的全景图了。当然，交互的效果可以是拖拽，也可以是重力感应等。</p>
<p>正如在上文提到的：“没有东西是连续的，即所有东西都是离散的…”。将《造物节》与后续全景图的水平方向上的图片分别合成一张图后，可以发现：图片数量越多，图片的要求也越低。你觉得呢？<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/zaowujie.jpg" alt="淘宝造物节整体效果图"><br>造物节全景图</p>
<h3 id="全景图素材的制作"><a href="#全景图素材的制作" class="headerlink" title="全景图素材的制作"></a>全景图素材的制作</h3><p>将全景图制作分为设计类与实景类：</p>
<h4 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h4><p>要制作类似 <a href="http://zwj360.im20.com.cn" target="_blank" rel="external">《淘宝造物节》</a> 的全景页面，设计稿需要有以下这些要求。</p>
<p>注：下面提及的具体数据均基于《造物节》，可根据自身要求进行调整（若发现欠缺，欢迎作出补充）。</p>
<p>整体背景设计图如下（2580*1170px，被分成 20 等份）：<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/zaowujie.jpg" alt="淘宝造物节整体效果图"></p>
<p>基本要求：</p>
<ol>
<li>水平方向上需要首尾相连；</li>
<li>因为效果图最终需要切成 <strong>N 等份</strong>，所以尽可能让 <strong>设计图的宽度能被 N 整除</strong>；</li>
<li>图片尺寸不仅要考虑正视图的大小，还要考虑元素在旋转时依然能覆盖视野（可选）。</li>
</ol>
<p>当然，上图只是背景图，还可以添加一些小物体素材（通过运动速度的差异形成视差，增强立体效果），如：<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/item3.jpg" alt="物体小元素1"><br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/item1.jpg" alt="物体小元素2"><br>小物体元素（虚线是用于参考的，造物节中共有 21 个小物体）</p>
<p>如上图所示，每个图片也是被等分成 M 等份。当然，M 取决于物体在背景上的具体位置和本身大小。<br>另外，M 的宽度是与 N 的宽度相等的。尽管部分物体（M&gt;1）的两侧等份的图案占比小，但建议保留同样的宽度。  </p>
<p>注：如果小物体有特殊的变形效果，应该备注具体变形参数。</p>
<p>对于顶部和底图图片，则无特殊要求。</p>
<h4 id="实景类"><a href="#实景类" class="headerlink" title="实景类"></a>实景类</h4><p>如果想制作实景的全景，可以看看 Google 街景：<br><a href="https://www.google.com/streetview/publish/" target="_blank" rel="external">Google 街景</a> 推荐的设备如下：<br><img src="https://misc.aotu.io/JChehe/2016-8-24-css-3d-panorama/panorama_machine.jpg" alt="此处输入图片的描述"></p>
<p>如上图，最实惠的就是最后一个选项—— <a href="https://www.google.com/streetview/apps/" target="_blank" rel="external">Google 街景 APP</a>，该应用内部提供了全景相机功能，但正如图片介绍所说，这是需要练习的，因此对操作要求比较高。</p>
<p>补充：<br>上周六（2016.8.20）参加了 TGDC 的分享会，嘉宾分享了他们处理全景的方式：</p>
<ol>
<li>利用 RICOH THETA S 等专业设备拍出全景图</li>
<li>导出静态图像</li>
<li>利用设备专门提供的 APP 或 krpamo tools、pano2vr、Glsky box 等工具将静态图像转为6张图</li>
<li>利用 Web 技术制作可交互的全景图</li>
</ol>
<p>其中 Web 技术有以下3种可选方式（当然，还有其它）：</p>
<ul>
<li>CSS3（本文所提及的方式）</li>
<li>Three.js</li>
<li>krpano（为全景而生，低级浏览器则回退到 Flash），<a href="http://krpano.com/docu/tutorials/quickstart/?from=groupmessage&amp;isappinstalled=0#top" target="_blank" rel="external">查看教程</a></li>
</ul>
<p>当时，嘉宾现场快速制作的 <a href="http://wt.qq.com/act/tgdc_lottery/lottery.html" target="_blank" rel="external">会议现场全景</a>。</p>
<p>可见，优秀硬件设备的出现，大大减少了后期处理的时间，而 Web 则提供了一个很好的展现平台。</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>随着终端设备的软硬件不断完善和提高，Web 在 3D 领域也不甘落后，如果你玩腻了 2D 的 H5 或者想为用户提供更加新颖优秀的体验，全景也许是一种选择。</p>
<p>最后，如有不清晰或不明白的地方，可以联系我，我会尽可能解决的。谢谢谢~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;3D 全景并不是什么新鲜事物了，但以前我们在 Web 上看到的 3D 全景一般是通过 Flash 实现的。若我们能将 &lt;code&gt;CSS3 Transform&lt;/code&gt; 的相关知识运用得当，也是能实现类似的效果。换句话说，3D 全景其实就是 CSS3 3D 的应用场景之一。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
      <category term="3D" scheme="http://yoursite.com/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>Flex 学习</title>
    <link href="http://yoursite.com/2016/05/19/2016-5-19-css-flex/"/>
    <id>http://yoursite.com/2016/05/19/2016-5-19-css-flex/</id>
    <published>2016-05-19T12:14:06.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前以为Flexbox不成熟，兼容性不好，所以看了书本上的知识后就没有深入了解和实践。</p>
<a id="more"></a>
<p>在 <a href="http://caniuse.com/#search=flex" target="_blank" rel="external">Can I use</a> 网站上可看到 flex 的兼容情况。在该网站可以看到flex有新版和旧版的规范。</p>
<p>先不管旧版，学习新版。</p>
<p>学习资料是来自阮一峰老师的两篇教程：《<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程：语法篇</a>》 和 《<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a>》</p>
<p>若对 flex-basis、flex-grow与flex-shrink 的，可看《<a href="http://zhoon.github.io/css3/2014/08/23/flex.html" target="_blank" rel="external">深入理解css3中的flex-grow、flex-shrink、flex-basis</a>》。</p>
<h3 id="Flex属性速记"><a href="#Flex属性速记" class="headerlink" title="Flex属性速记"></a>Flex属性速记</h3><h4 id="Flex容器属性表格"><a href="#Flex容器属性表格" class="headerlink" title="Flex容器属性表格"></a>Flex容器属性表格</h4><table>
<thead>
<tr>
<th>Flex容器属性</th>
<th>定义</th>
<th>取值（第一个是默认值）</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-direction</td>
<td>决定主轴的方向（即项目的排列方向）。</td>
<td>row \ row-reverse \ column \ column-reverse;</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>flex-wrap属性定义，如果一条轴线排不下，如何换行（默认是不换行）。</td>
<td>nowrap \ wrap \ wrap-reverse;</td>
</tr>
<tr>
<td>flex-flow</td>
<td>是flex-direction属性和flex-wrap属性的简写形式</td>
<td>默认值为row nowrap。</td>
</tr>
<tr>
<td>justify-content</td>
<td>定义了项目在主轴上的对齐方式。</td>
<td>flex-start \ flex-end \ center \ space-between \ space-around</td>
</tr>
<tr>
<td>align-items</td>
<td>定义项目在交叉轴上如何对齐。</td>
<td>flex-start \ flex-end \ center \ baseline \ stretch</td>
</tr>
<tr>
<td>align-content</td>
<td>定义了多根轴线（即项目也声明为Flex容器）的对齐方式。一根轴不起效</td>
<td>stretch \ flex-end \ center \ space-between \ space-around \ flex-start</td>
</tr>
</tbody>
</table>
<h4 id="Flex项目属性表格"><a href="#Flex项目属性表格" class="headerlink" title="Flex项目属性表格"></a>Flex项目属性表格</h4><table>
<thead>
<tr>
<th>Flex项目属性</th>
<th>定义</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>order</td>
<td>定义项目的排列顺序。数值越小（负数有效），排列越靠前，默认为0。</td>
<td>integer 默认为0，负值有效。</td>
</tr>
<tr>
<td>flex-grow</td>
<td>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</td>
<td>number 默认值是0</td>
</tr>
<tr>
<td>flex-shrink</td>
<td>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。0代表在空间不足时也不收缩。负值对该属性无效（相当于默认值 1）。</td>
<td>number 默认值是1</td>
</tr>
<tr>
<td>flex-basis</td>
<td>定义了在分配容器空间之前，项目占据的主轴空间（main size）。默认值为auto，即项目的本来大小。</td>
<td>length \ auto</td>
</tr>
<tr>
<td>flex</td>
<td>是flex-grow, flex-shrink 和 flex-basis的简写</td>
<td>默认值为0 1 auto。后两个属性可选。还有两个关键字：<code>auto</code> (<code>1 1 auto</code>) 和 <code>none</code> (<code>0 0 auto</code>)</td>
</tr>
<tr>
<td>align-self</td>
<td>允许单个项目有与其他项目不一样的对齐（交叉轴上）方式，即覆盖align-items属性。</td>
<td>auto \ flex-start \ flex-end \ center \ baseline \ stretch 其中auto是默认值，表示继承父元素的align-items属性。</td>
</tr>
</tbody>
</table>
<p>本文是自己的快速记录，你们想学可以看阮一峰老师的教程。</p>
<h3 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为Flex布局。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="comment">/* 旧版浏览器需要前浏览器前缀，如：-webkit-flex */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行内元素也可以使用Flex布局。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">display</span>: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效（已测试，的确是这样）。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。当然，Flex项目也可以再次声明为Flex容器。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/flex.png" alt="此处输入图片的描述"><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>决定主轴的方向（即项目的排列方向）。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>默认情况下，项目都排在一条线（又称”轴线”，<strong>默认是不换行的</strong>）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse; </div><div class="line">    <span class="comment">/* wrap-reverse 行之间的倒序 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<h4 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h4><p>定义了项目在<strong>主轴</strong>上的对齐方式。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/justify-content.png" alt="此处输入图片的描述"></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h4 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h4><p>定义项目在交叉轴上如何对齐。</p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline： 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h4 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h4><p>定义了多根轴线（即项目也声明为Flex容器）的对齐方式。如果容器只有一根轴线，该属性不起作用。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/align-content.png" alt="此处输入图片的描述"></p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>定义项目的排列顺序。数值越小（负数有效），排列越靠前，默认为0。</p>
<h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><p>属性定义项目的放大比例，<strong>默认为0，即如果存在剩余空间，也不放大</strong>。  </p>
<p>即：对于剩余空间（容器宽度-项目总占位），然后按照项目指定的大小（比例=当前项目值/总项目值）进行分配。</p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><p>定义了项目的缩小比例，<strong>默认为1，即如果空间不足，该项目将缩小</strong>。0代表在空间不足时也不收缩。</p>
<p>负值对该属性无效（相当于默认值 1）。</p>
<p>该属性的工作机制与<code>flex-grow</code>一样，对<code>项目总占位</code>超出容器的部分进行按比例分配，然后对各个 flex-shrink 不为 0 的项目按照分配到的宽度进行收缩（即项目原本宽度减去分配到的宽度）。</p>
<h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><p>定义了在分配容器空间之前，项目占据的主轴空间（main size）。</p>
<p>它的默认值为auto，即项目的本来大小。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default value */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果同时设置flex-basis和width，那么width属性会被覆盖，也就是说flex-basis的优先级比width高。有一点需要注意的是：如果flex-basis和width其中有一个是auto，那么另外一个非auto的属性优先级会更高。</p>
</blockquote>
<h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该属性有两个关键字：<code>auto</code> (<code>1 1 auto</code>) 和 <code>none</code> (<code>0 0 auto</code>)。</p>
<h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><p>允许单个项目有与其他项目不一样的对齐（交叉轴上）方式，即覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了auto，其余与align-items 一样。</p>
<p>希望能尽快应用到项目中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前以为Flexbox不成熟，兼容性不好，所以看了书本上的知识后就没有深入了解和实践。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>《CSS 揭秘》读书笔记</title>
    <link href="http://yoursite.com/2016/05/18/2016-5-18-css-scerets-notes/"/>
    <id>http://yoursite.com/2016/05/18/2016-5-18-css-scerets-notes/</id>
    <published>2016-05-18T04:41:10.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于看完了《CSS揭秘》了，下面就做一下笔记。</p>
<a id="more"></a>
<p>对querySelectorAll进行封装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$$</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line">    context = context || <span class="built_in">document</span>;</div><div class="line">    <span class="keyword">var</span> elements = context.querySelectorAll(selector);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(elements);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检测某个样式属性是否被支持，核心思路是在任意元素的 <code>element.style</code> 对象上检查该属性是否存在：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">funcion testProperty(property)&#123;</div><div class="line">    <span class="keyword">var</span> root = <span class="built_in">document</span>.documentElement; <span class="comment">// &lt;html&gt;</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(property <span class="keyword">in</span> root.style)&#123;</div><div class="line">        root.classList.add(property.toLowerCase());</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    root.classList.add(<span class="string">"no-"</span> + property.toLowerCase());</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检测某个具体的<strong>属性值</strong>是否支持，那就需要把它赋给对应的属性，然后再检查浏览器是不是还保存着这个值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testValue</span>(<span class="params">id, value, property</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> dummy = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</div><div class="line">    dummy.style[property] = value;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(dummy.style[property])&#123;</div><div class="line">        root.classList.add(id);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    root.classList.add(<span class="string">"no-"</span> + id);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果要检测选择符和@规则的支持情况：在解析CSS代码时，浏览器总会丢弃它自己无法识别的部分，因此可以动态地应用样式并检查它是否生效，以此来判断浏览器是否可以识别某个特性。当然，<strong>浏览器可以解析某个CSS特性并不代表它已经实现（或正确实现）了这个特性。</strong></p>
<h2 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h2><h3 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h3><p>标准的工作组需要网页开发者这一端的输入，以确保各项规范可以处理真实的开发需求。当实验性的技术被广泛应用到生产时，工作组就被这些技术早期的、实验性的版本捆住手脚了，因此一旦这些技术有变动，那些已经在用这些技术的网站就挂了。显然，这完全否定了让开发者尝试早期标准的好处。</p>
<p>浏览器前缀就是解决方案之一。这个方案是指每个浏览器都可以实现这些实验性的（甚至是私有的、非标准的）特性，但要在名称前加上自己特有的前缀。<br>最终标准化的版本会有一个不同的名称（没有前缀），这样就不会与加前缀版本相冲突了。</p>
<p>开发者为了避免浏览器日后更新（从而支持某属性），就先发制人地加上所有可能的浏览器前缀，再把无前缀的版本放在最后，以图一劳永逸。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-moz-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-ms-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-o-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-webkit-border-radius</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">border-radius</span>: 10<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure>
<p>-ms-和-o-是多余的，这两个属性从未在任何浏览器中出现过，因为IE和Opera从开始就直接实现了border-radius这个无前缀版本的。</p>
<p>由于开发者使用无前缀的属性是想确保代码的向前兼容，那么工作组想要修改这些无前缀语法就变得不可能了。我们基本上就跟这些半生不熟的早期规范绑在一起了。<strong>因此，浏览器前缀已是一场史诗般的失败</strong>。</p>
<p>最近，浏览器厂商已经很少以前缀的方式来实验性地实现新特性了。取而代之的是，通过<strong>配置开关</strong>来启用，这样可以有效防止开发者在生产环境中使用它们。</p>
<h3 id="CSS编码技巧"><a href="#CSS编码技巧" class="headerlink" title="CSS编码技巧"></a>CSS编码技巧</h3><p>在软件开发中，保持代码的DRY（Don’t Repeat Yourself）和可维护性是最大的挑战之一，而这句话对于CSS也是适用的。</p>
<p>在实践中，代码可维护性的最大要素是尽量减少改动时要编辑的地方。</p>
<p><strong>当某些值相互依赖时，应该把它们的相互关系用代码表达出来。</strong>如按钮的字体与行高的关系。</p>
<p><strong>有时，代码易维护和代码量少不可兼得。</strong>如元素的边框为10px宽，但左侧不加边框。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border-width</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 0;</div></pre></td></tr></table></figure></p>
<p>只需一条声明就可以达到要求了，但如果日后要改动边框的宽度，就需要修改3处。如果把它拆成两条声明，则改起来容易多了，而且可读性或许更好一些：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border-width</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">border-left-width</span>: 0;</div></pre></td></tr></table></figure></p>
<p><strong>currentColor</strong>这个变量的值是当前元素的color值。如果当前元素没有在CSS里显示地指定一个color值，那它的颜色值就遵从CSS规则，从父级元素继承而来。该关键字<strong>兼容IE9及以上</strong>。</p>
<p><strong>继承</strong>：inherit可以用在任何CSS属性（可继承的），而且它总是绑定到父元素的计算值（对伪元素来说，则会取该伪元素的宿主元素）。</p>
<p>把表单元素的字体设定为与页面的其他部分相同，你无需重复指定字体属性，只需利用inherit即可。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">button</span>&#123; <span class="attribute">font</span>: inherit; &#125;</div></pre></td></tr></table></figure></p>
<p>把超链接的颜色设定与页面中其它文本相同：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>&#123; <span class="attribute">color</span>: inherit; &#125;</div></pre></td></tr></table></figure></p>
<p>在创建提示框时，通过:before伪元素生成的小箭头能继承宿主元素的背景和边框样式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.callout&#123; position: relative; &#125;</div><div class="line"></div><div class="line">.callout:before&#123;</div><div class="line">    content: "";</div><div class="line">    background: inherit;</div><div class="line">    border: inherit;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="相信你的眼睛，而不是数字"><a href="#相信你的眼睛，而不是数字" class="headerlink" title="相信你的眼睛，而不是数字"></a>相信你的眼睛，而不是数字</h3><p>人的眼睛并不是一台完美的输入设备。有时候精准的尺度看起来并不精准，而我们的设计需要顺应这种偏差。</p>
<ol>
<li>看一个完美居中的物体时，会感觉它并不居中。实际上，我们应该把这个物体从几何学的中心点再晚上稍微上挪一点。</li>
<li>宽度相同的圆形和正方形，圆形会显得小一点。</li>
</ol>
<p>上述视觉上的错觉在任何形式的视觉设计中都普遍存在，需要我们有针对性地进行调整。<br>常见的例子是：给一个文本容器设置内边距。无论文本多长，四边相同的内边距在实际效果看起来并不相等。原因在于，字母的形状在两端都比较整齐，而顶部和底部则往往参差不齐，从而导致你的眼睛把这些参差不齐的空缺部分感知为多出来的内边距。</p>
<h3 id="关于响应式设计"><a href="#关于响应式设计" class="headerlink" title="关于响应式设计"></a>关于响应式设计</h3><p>媒体查询不能以一种连续的方式来修复问题。它的工作原理基于某几个特定的断点。<br>添加的媒体查询越多，CSS代码就会变得越经不起折腾。应该把它作为最后的手段。</p>
<p>媒体查询的断点不应该由具体的设备来决定，而应该根据设计自身来决定。</p>
<p>避免不必要的媒介查询的建议：</p>
<ul>
<li>使用百分比长度来取代固定长度。若做不到这点，可尝试使用与视口相关的单位（vw、wh、vmin、vmax）。</li>
<li>需要在较大分辨率下取得固定宽度时，使用max-width而不是width。</li>
<li>不要忘记为替换元素（如img、object、video、iframe等）设置max-width：100%。</li>
<li>假设背景图片需要完整地铺满一个容器，不管容器尺寸如何变化，background-size:cover可以做到这点。需要注意的是，移动端带宽有限，把大图缩小显示往往不太明智。</li>
<li>当图片（或其他元素）以行列式进行布局时，让视口宽度来决定列的数量。</li>
<li>在使用多列文本时，指定column-width而不是column-count。</li>
</ul>
<p><strong>总的来说，思路是尽最大努力实现弹性可伸缩的布局，并在媒体查询的各个断点区间内指定相应的尺寸。</strong></p>
<h3 id="合理使用简写"><a href="#合理使用简写" class="headerlink" title="合理使用简写"></a>合理使用简写</h3><p>合理使用简写是一种良好的防卫性编码方式，可以抵御未来的风险。</p>
<p>如果只为某个属性提供一个值，那它会扩散并应用到列表中的每一项。如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">background: url(tr.png) no-repeat top right / 2em 2em,</div><div class="line">            url(br.png) no-repeat bottom right / 2em 2em,</div><div class="line">            url(bl.png) no-repeat bottom left / 2em 2em;</div></pre></td></tr></table></figure></p>
<p>可将重复的值从简写属性中抽出来写成一个展开式属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(<span class="selector-tag">tr</span><span class="selector-class">.png</span>) <span class="selector-tag">top</span> <span class="selector-tag">right</span>,</div><div class="line">            <span class="selector-tag">url</span>(<span class="selector-tag">br</span><span class="selector-class">.png</span>) <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>,</div><div class="line">            <span class="selector-tag">url</span>(<span class="selector-tag">bl</span><span class="selector-class">.png</span>) <span class="selector-tag">bottom</span> <span class="selector-tag">left</span>;</div><div class="line"><span class="selector-tag">background-size</span>: 2<span class="selector-tag">em</span> 2<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</div></pre></td></tr></table></figure></p>
<p>对于如background属性的值有歧义的属性，background-position（即使是初始值也要写出来）和background-size中间需要<code>/</code>作为分隔。</p>
<p>对于绝大多数的简写属性来说，并没有歧义问题，因而简写属性的多个值往往可以随意排列。</p>
<h2 id="第二章-背景与边框"><a href="#第二章-背景与边框" class="headerlink" title="第二章 背景与边框"></a>第二章 背景与边框</h2><p>background-clip: border-box（默认值）/padding-box/content-box</p>
<h3 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h3><h4 id="box-shadow方案"><a href="#box-shadow方案" class="headerlink" title="box-shadow方案"></a>box-shadow方案</h4><p>box-shadow的第四个参数（称作“扩张半径”），通过指定正值或负值，可以让投影面积加大或者减少。<br>一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框。<br>box-shadow支持逗号分隔符，可创建任意数量的投影。<br>box-shadow是层层叠加的，第一层投影位于最顶层，以此类推。</p>
<p>注意点</p>
<ul>
<li>投影的行为更边框（border）不完全一致，因为它不影响布局，而且也不会受到box-sizing属性的影响。</li>
<li>不会响应鼠标事件</li>
</ul>
<h4 id="outline方案"><a href="#outline方案" class="headerlink" title="outline方案"></a>outline方案</h4><p>outline: 5px solid #655; 它可通过outline-offset属性来控制它跟元素边缘之间的间距，这个属性甚至可以接受负值。</p>
<p>需要注意的是：它目前并不贴合border-radius，未来可能会改为贴合。</p>
<h4 id="灵活的背景定位"><a href="#灵活的背景定位" class="headerlink" title="灵活的背景定位"></a>灵活的背景定位</h4><p>background-origin: padding-box（默认值）/content-box/border-box。</p>
<p>calc()需要注意的是：要在<code>-</code>和<code>+</code>运算符的两侧各加一个空白符，否则会产生解析错误！这是为了向前兼容：未来，在calc()内部可能会允许使用关键字，而这些关键字可能会包含连字符（即<code>-</code>）。<br>当然calc()还能进行乘法与除法。</p>
<h4 id="条纹背景"><a href="#条纹背景" class="headerlink" title="条纹背景"></a>条纹背景</h4><p><strong>渐变需要注意的点</strong><br>渐变指定的位置是色标的位置，色标之间的距离是过渡的空间。</p>
<p><strong>渐变的角度</strong><br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E6%B8%90%E5%8F%98%E8%A7%92%E5%BA%A6.jpg" alt="此处输入图片的描述"></p>
<blockquote>
<p>如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。</p>
</blockquote>
<p>根据上述引用，我可以在构建条纹时（无过渡）时，把第二个坐标（即后续坐标）的位置值设置为0，那它的位置就总是会被浏览器调整为前一个色标的位置值。<br>这可以避免每次改动条纹宽度时都要修改两个数字。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#fb3</span> 30%, <span class="selector-id">#58a</span> 0);</div></pre></td></tr></table></figure></p>
<h4 id="复杂的背景"><a href="#复杂的背景" class="headerlink" title="复杂的背景"></a>复杂的背景</h4><p>对于现代浏览器，我们可以把SVG文件以data URI的方式嵌入到样式表中，甚至不需要用base64或URIencode来对其编码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">background: url("data:image/svg+xml, \</div><div class="line">            &lt;svg&gt; \</div><div class="line">            ... \</div><div class="line">            &lt;/svg&gt;");</div></pre></td></tr></table></figure></p>
<p>注意，如果出于可读性的考虑，需要把一句CSS代码（如background-image的字符串值）打断为多行，可用反斜杠（<code>\</code>）来转义每行末尾的换行。</p>
<h4 id="伪随机背景"><a href="#伪随机背景" class="headerlink" title="伪随机背景"></a>伪随机背景</h4><p>与box-shadow一样，多图背景的位置（默认）都是从最左侧开始的。</p>
<h4 id="连续的图像边框"><a href="#连续的图像边框" class="headerlink" title="连续的图像边框"></a>连续的图像边框</h4><p>MDN：浏览器应用了border-image，则不再应用border-style。另外，若border-image-source的值为none或图片不能显示，则将应用border-style。</p>
<h2 id="第三章-形状"><a href="#第三章-形状" class="headerlink" title="第三章 形状"></a>第三章 形状</h2><h3 id="梯形标签页"><a href="#梯形标签页" class="headerlink" title="梯形标签页"></a>梯形标签页</h3><p>为了更好地实现回退方案，可同样通过不兼容的属性进行设置，如：变形后需要上移的情况，此时，可用translateY，而不是margin-top或postion。</p>
<h3 id="简单的饼图"><a href="#简单的饼图" class="headerlink" title="简单的饼图"></a>简单的饼图</h3><p>一个负的延时值（animation-delay）是合法的。它会跳过指定时间而从中间开始播放。</p>
<p>通过设置animation-play-state: paused，可让动画暂停。默认值是<code>running</code>。</p>
<p><strong>如何改变伪元素的样式？</strong></p>
<ul>
<li>通过继承，改变宿主元素</li>
<li>通过animation，设置好一系列帧，然后设置延时值，以跳到某帧的样式（前提是处于暂停状态）。</li>
</ul>
<h2 id="第四章-视觉效果"><a href="#第四章-视觉效果" class="headerlink" title="第四章 视觉效果"></a>第四章 视觉效果</h2><h3 id="单侧投影"><a href="#单侧投影" class="headerlink" title="单侧投影"></a>单侧投影</h3><p>border-radius：2px 3px 4px rgba(0,0,0,.5);<br>使用高斯模糊（或类似算法）将它进行4px的模糊处理。这在本质上表示在阴影边缘发生<strong>阴影色</strong>与<strong>纯透明色</strong>之间的颜色过渡，长度近似于模糊半径的两倍（比如这里是<code>8px</code>）。<br>模糊后的矩形<strong>与原始元素的交集部分会被切除掉</strong>。因此，如果元素是半透明时，也会看不到它下层的投影。这点与text-shadow不同，文字下层的投影不会被裁切。</p>
<h3 id="不规则投影"><a href="#不规则投影" class="headerlink" title="不规则投影"></a>不规则投影</h3><p>box-shadow会忽略元素的伪元素或半透明部分（只对整体进行投影），这类情况包括：</p>
<ul>
<li>半透明图像、背景图像、或者border-image；</li>
<li>元素设置了点状、虚线或半透明的边框，但没有背景（或者当background-clip不是border-box）时；</li>
<li>对话气泡，它的小尾巴通常是通过伪元素生成；</li>
<li>…</li>
</ul>
<p>filter: drop-shadow()与box-shadow的参数一样，但不包括扩张半径和inset关键字，也不支持逗号分隔符的多层投影。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">filter</span>: <span class="selector-tag">drop-shadow</span>(2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.5</span>));</div></pre></td></tr></table></figure></p>
<p>该属性能对很好地解决上述问题（伪元素、虚线边框、半透明背景等）。</p>
<p>当然，它们的模糊算法可能不同，需要进行调整。</p>
<h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p>filter: blur(); 是对自身进行模糊，但不透明。</p>
<p>background-attach: fixed; 表示背景相对于视口固定（以视口的左上角为背景定位origin）。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</p>
<h2 id="第六章-用户体验"><a href="#第六章-用户体验" class="headerlink" title="第六章 用户体验"></a>第六章 用户体验</h2><h3 id="自定义复选框"><a href="#自定义复选框" class="headerlink" title="自定义复选框"></a>自定义复选框</h3><p>新伪类 <code>:checked</code>，该伪类只在复选框（也适用于单选框）被选择时才会匹配，不论这个选择状态是由用户交互触发，还是由脚本触发。</p>
<blockquote>
<p>属性选择符[checked]与它不同，该选择符不会根据用户的交互行为进行更新，因为用户的交互并不会影响到HTML标签上的属性。</p>
</blockquote>
<p>由于没有多少样式能够对复选框（由于是替换元素）起作用。不过，可基于复选框的勾选状态借助组合选择符给其他元素（label）设置样式。</p>
<blockquote>
<p>替换元素：其内容超出了CSS格式化模型的范畴，比如图片、嵌入的文档等。原则上我们无法为替换元素添加生成性内容，尽管某些浏览器可能会允许这样做。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"awesome"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"awesome"</span>&gt;</span>Awesome!<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">input[type="checkbox"] + label::before&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">// 选中状态</div><div class="line">input[type="checkbox"]:checked + label::before&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当label元素与复选框关联后，也可以起到触发开关的作用。</p>
<h3 id="交互式的图片对比控件"><a href="#交互式的图片对比控件" class="headerlink" title="交互式的图片对比控件"></a>交互式的图片对比控件</h3><p>即使不设置 pointer-events: none;的情况下，伪元素（覆盖在它之上）也不会干扰调节手柄（resize:both）的功能。 </p>
<p>user-select:none; 作用：？？？？</p>
<h2 id="第七章-结构与布局"><a href="#第七章-结构与布局" class="headerlink" title="第七章 结构与布局"></a>第七章 结构与布局</h2><p>min-content：该关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽单词、图片或具有固定宽度的盒元素）。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">width</span>: <span class="selector-tag">min-content</span>;</div></pre></td></tr></table></figure></p>
<p>还有max-content与fit-content关键字。</p>
<h3 id="精确控制表格列宽"><a href="#精确控制表格列宽" class="headerlink" title="精确控制表格列宽"></a>精确控制表格列宽</h3><p>table默认情况下：</p>
<ul>
<li>不指定单元格的宽度，则这些单元格就会根据它们内容的长短来分配。</li>
<li>当然，表格的每一行都会参与到列宽的计算中，而不仅是第一行</li>
<li>即时我们为单元格指定了宽度（第一列1000px，第二列2000px），由于外层容器所能提供的宽度不足3000px，则这两个单元格的宽度会按比列缩小，分别得到33.3% 和 66.6%。</li>
<li>如果禁止文本折行，那么表格宽度可能会超出其容器宽度（设置text-overflow:ellipsis;也没用（也不会显示…））。</li>
<li>大图片也会导致上一点同样的问题。</li>
</ul>
<p>而table-layout<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">table</span>&#123;</div><div class="line">    <span class="attribute">table-layout</span>: fixed;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>如果不指定任何宽度，则各列宽度将是平均分配；</li>
<li>后续的表格行并不会影响列宽；</li>
<li>给单元格指定很大的宽度也能生效，并不会自动缩小；</li>
<li>overflow和text-overflow属性都正常生效；</li>
<li>如果overflow的值是visible，则<strong>单元格的内容</strong>可能会溢出。</li>
</ul>
<h3 id="根据兄弟元素的数量来设置样式"><a href="#根据兄弟元素的数量来设置样式" class="headerlink" title="根据兄弟元素的数量来设置样式"></a>根据兄弟元素的数量来设置样式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">li:first-child:nth-last-child(4), /* 由于`~`选择符不包括自身 */</div><div class="line">li:first-child:nth-last-child(4) ~ li&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该选择符 <code>li:first-child:nth-last-child(4)</code> 表示：<strong>一个正好有四个列表项的列表中的第一个列表项</strong>。</p>
<p>根据上述选择符，再通过 <code>~</code> 兄弟选择符，即可实现根据数量来设置样式（这里是只有li为4个时）。</p>
<p>根据兄弟元素的数量范围来匹配元素<br>:nth-child()选择符，它的参数可以是简单数字，也可以像 <code>an+b</code> 这样的表达式，<code>n</code> 表示0到 <code>正无穷</code>。 </p>
<ul>
<li>:nth-child()的值是从1开始，即nth-child(1)对应第一个元素。</li>
<li>:nth-child(n+b)：则会选中除第一、二、三个子元素之外的所有子元素。</li>
</ul>
<p>结合之前的【根据兄弟元素的数量来设置样式】，下面这个选择器会选择：<strong>仅当列表中有4个或更少的列表项时</strong>，才能匹配。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">li:first-child:nth-last-child(-n+4), </div><div class="line">li:first-child:nth-last-child(-n+4) ~ li&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而希望匹配列表包含2~6个列表项时：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">li:first-child:nth-last-child(n+2):nth-last-child(-n+6), </div><div class="line">li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有上述选择符可看出，同一个选择符中，n的值并不一致，</p>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>在某些浏览器中，transform可能会导致元素的显示有一些模糊，因为元素可能被放置在半个像素上。这个问题可以用tranform-style: preserve-3d 来修复。</p>
<p>当使用Flexbox时，margin:auto可在水平和垂直方向上居中。另外，我们甚至不需要指定任何宽度：这个居中元素分配到的宽度等于 max-content。</p>
<h2 id="第八章-过渡与动画"><a href="#第八章-过渡与动画" class="headerlink" title="第八章 过渡与动画"></a>第八章 过渡与动画</h2><p>每个transform-origin都可以被两个translate()模拟出来。</p>
<p>完！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于看完了《CSS揭秘》了，下面就做一下笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript模式》读书笔记</title>
    <link href="http://yoursite.com/2016/04/26/2016-4-26-javascript-patterns-notes/"/>
    <id>http://yoursite.com/2016/04/26/2016-4-26-javascript-patterns-notes/</id>
    <published>2016-04-26T13:05:42.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在软件开发过程中，模式是指一个通用问题的解决方案。一个模式不仅仅是一个可以用来复制粘贴的代码解决方案，更多地是提供了一个更好的实践经验、有用的抽象化表示和解决一类问题的模板。<br><a id="more"></a><br>对象有两大类：</p>
<ul>
<li>本地对象（Native）：由ECMAScript标准定义的对象</li>
<li>宿主对象（Host）：由宿主环境创建的对象（比如浏览器环境）</li>
</ul>
<p>本地对象也可以被归类为内置对象（比如Array、Date）或自定义对象（var o = {}）。<br>宿主对象包含window和所有DOM对象。如果你想知道你是否在使用宿主对象，将你的代码迁移到一个非浏览器环境中运行一下，如果正常工作，那么你的代码就只用到了本地对象。  </p>
<p>“GoF”的书中提到一条通用规则，“组合优于继承”。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console" target="_blank" rel="external">console 对象</a></p>
<h2 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h2><p>易维护的代码具有如下特性：</p>
<ul>
<li>可读的</li>
<li>风格一致</li>
<li>可预测的</li>
<li>看起来像一个人写的</li>
<li>有文档</li>
</ul>
<h3 id="尽量少用全局变量"><a href="#尽量少用全局变量" class="headerlink" title="尽量少用全局变量"></a>尽量少用全局变量</h3><h4 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h4><p>隐式创建全部变量有两种情况：</p>
<ul>
<li><p>未经声明的变量就为全局对象所有。</p>
<pre><code>function sum(x, y){
    result = x + y; // result 是全局变量;
}
</code></pre></li>
<li><p>带有 <code>var</code> 声明的链式赋值</p>
<pre><code>function foo(){
    var a = b = 0; // b 是全局变量
}
</code></pre><p> 由于 <code>=</code> 的运算顺序是从右到左。即 <code>var a = b = 0;</code> 等价于 <code>var a = (b = 0)</code>。<br> 因此，对于链式赋值建议做法如下：</p>
<pre><code>function foo(){
    var a, b;
    a = b = 0;
}
</code></pre></li>
</ul>
<p>隐式创建的全局变量与明确定义的全局变量的不同之处在于：是否能被 <code>delete</code> 操作符删除。</p>
<ul>
<li>使用 var 创建的全局变量（在函数外创建）不能删除</li>
<li>不使用 var 创建的隐式全局变量（就算在函数内创建）可以删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">b = 2;</div><div class="line">(function()&#123;</div><div class="line">    c = 3;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">delete a; // false;</div><div class="line">delete b; // true;</div><div class="line">delete c; // true</div><div class="line"></div><div class="line">typeof a; // number</div><div class="line">typeof b; // undefined</div><div class="line">typeof c; // undefined</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在ES5 strict模式下，为未声明的变量赋值会抛出错误。</p>
<h3 id="单一var模式"><a href="#单一var模式" class="headerlink" title="单一var模式"></a>单一var模式</h3><p>在函数顶部对所有变量通过一个 var 进行声明。好处如下：</p>
<ul>
<li>可以在同一个位置找到函数所需的所有变量</li>
<li>避免在变量声明之前使用这个变量时产生的逻辑错误</li>
<li>提醒你不要忘记声明变量，顺便减少潜在的全局变量</li>
<li>代码量更少</li>
</ul>
<p>例子：</p>
<pre><code>function func(){
    var a = 1,
        b = 2,
        sum = a + b,
        myobject = {},
        i,
        j;
    console.log(sum)
    // 函数体
}
func()
</code></pre><blockquote>
<p>使用逗号操作符可以在一条语句中执行多个操作。多用于声明多个变量，但还可以用于赋值，总会返回表达式的最后一项。<br>(1) 逗号表达式的运算过程为：从左往右逐个计算表达式。<br>(2) 逗号表达式作为一个整体，它的值为最后一个表达式的值。<code>var num = (5,4,1,0); // num 为 0</code>。<br>(3) 逗号运算符的优先级别在所有运算符中最低。    </p>
</blockquote>
<h3 id="避免使用隐式类型转换"><a href="#避免使用隐式类型转换" class="headerlink" title="避免使用隐式类型转换"></a>避免使用隐式类型转换</h3><p>使用 <code>===</code> 或 <code>!==</code> 进行比较。增强代码可阅读性，避免猜测。<br>另外，<code>switch</code> 语句的 <code>case</code> 进行比较时，使用的是 <code>===</code>。</p>
<h3 id="避免使用-eval"><a href="#避免使用-eval" class="headerlink" title="避免使用 eval()"></a>避免使用 eval()</h3><p>new Functin() 与 eval()的不同：</p>
<p>第一点：<br>new Function()中的代码将在局部函数空间运行，因此代码中任何采用var定义的变量不会自动成为全局变量（即在函数内）。<br>eval()则会自动成为全局变量，但可通过立即调用函数对其进行封装。</p>
<pre><code>console.log(typeof un);// &quot;undefined&quot;
console.log(typeof deux); // &quot;undefined&quot;
console.log(typeof trois); // &quot;undefined&quot;

var jsstring = &quot;var un = 1; console.log(un);&quot;;
eval(jsstring); // 打印出 &quot;1&quot;

jsstring = &quot;var deux = 2; console.log(deux);&quot;;
new Function(jsstring)(); // 打印出 &quot;2&quot;

jsstring = &quot;var trois = 3; console.log(trois);&quot;;
(function () {
    eval(jsstring);
}()); // 打印出 &quot;3&quot;

console.log(typeof un); // &quot;number&quot;
console.log(typeof deux); // &quot;undefined&quot;
console.log(typeof trois); // &quot;undefined&quot;
</code></pre><p>第二点：<br>eval()会影响到作用域链，而Function则像一个沙盒，无论在哪里执行Function，它都仅能看到全局作用域链。因此对局部变量的影响比较小。</p>
<pre><code>(function () {
    var local = 1;
    eval(&quot;local = 3; console.log(local)&quot;); // 打印出 3
    console.log(local); // 打印出 3
}());

(function () {
    var local = 1;
    Function(&quot;console.log(typeof local);&quot;)(); // 打印出 undefined
}());
</code></pre><h3 id="使用parseInt-进行数字转换"><a href="#使用parseInt-进行数字转换" class="headerlink" title="使用parseInt()进行数字转换"></a>使用parseInt()进行数字转换</h3><p>ECMAScript3中以0为前缀的字符串会被当作八进制数处理，这一点在ES5中已经有了改变。为了避免转换类型不一致而导致的意外结果，应当总是指定第二个参数：</p>
<pre><code>var month = &quot;06&quot;,
year = &quot;09&quot;;
month = parseInt(month, 10);
year = parseInt(year, 10);
</code></pre><p>字符串转换为数字还有两种方法：</p>
<pre><code>+&quot;08&quot; // 结果为8，隐式调用Number()
Number(&quot;08&quot;) // 结果为8
</code></pre><p>这两种方法要比parseInt()更快一些，因为顾名思义parseInt()是一种“解析”而不是简单的“转换”。但当你期望将“08 hello”这类字符串转换为数字，则必须使用parseInt()，其他方法都会返回NaN。</p>
<h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><ul>
<li>构造函数首字母大写</li>
<li>函数用小驼峰式（getFirstName），变量用“所有单词小写，并用下划线分隔各个单词”（first_name）。这样就能区分函数和变量了。</li>
<li>常量和全局变量的所有字符大写</li>
<li>私有成员函数用下划线（_）前缀命名</li>
</ul>
<p>当然，还要正确编写注释和更新注释。最好能编写 API 文档。</p>
<h2 id="字面量与构造函数"><a href="#字面量与构造函数" class="headerlink" title="字面量与构造函数"></a>字面量与构造函数</h2><pre><code>// 一种方法，使用字面量
var car = {goes: &quot;far&quot;};

// 另一种方法，使用内置构造函数
// 注意：这是一种反模式
var car = new Object();
car.goes = &quot;far&quot;;
</code></pre><p>字面量写法的一个明显优势是，它的代码更少。“创建对象的最佳模式是使用字面量”还有一个原因，它可以强调对象就是一个简单的可变的散列表，而不必一定派生自某个类。<br>另外一个使用字面量而不是Object()构造函数创建实例对象的原因是，对象字面量不需要“作用域解析”（scope resolution）。因为可能存在一个同名的构造函数Object()，当你调用Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，直到找到全局Object()构造函数为止。</p>
<p>Object()构造函数仅接受一个参数，且依赖于传递的值，该Object()根据值委派另一个内置构造函数来创建对象，并返回另外一个对象实例，而这往往不是你想要的。</p>
<pre><code>// 空对象
var o = new Object();
console.log(o.constructor === Object); // true

// 数值对象
var o = new Object(1);
console.log(o.constructor === Number); // true
console.log(o.toFixed(2)); // &quot;1.00&quot;

// 字符串对象
var o = new Object(&quot;I am a string&quot;);
console.log(o.constructor === String); // true
// 普通对象没有substring()方法，但字符串对象有
console.log(typeof o.substring); // &quot;function&quot;

// 布尔值对象
var o = new Object(true);
console.log(o.constructor === Boolean); // true
</code></pre><h3 id="强制使用new的模式"><a href="#强制使用new的模式" class="headerlink" title="强制使用new的模式"></a>强制使用new的模式</h3><p>对于构造函数，若忘记使用 <code>new</code> 操作符，会导致构造函数中的this指向全局对象（严格模式下，指向undeinfed）。</p>
<p>为了防止忘记 <code>new</code>，我们使用下面的方法：在构造函数中首先检查this是否是构造函数的实例，如果不是，则<strong>通过new再次调用自己</strong>：</p>
<pre><code>function Waffle() {

// Waffle 可换成 arguments.callee（指向当前执行的函数）
if (!(this instanceof Waffle)) { 
    return new Waffle();
}
this.tastes = &quot;yummy&quot;;

}
Waffle.prototype.wantAnother = true;

// 测试
var first = new Waffle(),
    second = Waffle();

console.log(first.tastes); // &quot;yummy&quot;
console.log(second.tastes); // &quot;yummy&quot;

console.log(first.wantAnother); // true
console.log(second.wantAnother); // true
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="重定义函数"><a href="#重定义函数" class="headerlink" title="重定义函数"></a>重定义函数</h3><p>函数可以被动态定义，也可以被赋值给变量。如果将你定义的函数赋值给已经存在的函数变量的话，则新函数会覆盖旧函数。这样做的结果是，旧函数的引用被丢弃掉，变量中所存储的引用值替换成了新的函数。这样看起来这个变量指代的函数逻辑就发生了变化，或者说函数进行了“重新定义”或“重写”。</p>
<pre><code>var scareMe = function () {
    alert(&quot;Boo!&quot;);
    scareMe = function () {
        alert(&quot;Double boo!&quot;);
    };
};
// 使用重定义函数
scareMe(); // Boo!
scareMe(); // Double boo!
</code></pre><p>当函数中包含一些初始化操作，并希望这些初始化操作只执行一次，那么这种模式是非常合适的，因为我们要避免重复执行不需要的代码。在这个场景中，函数执行一次后就被重写为另外一个函数了。</p>
<p>使用这种模式可以帮助提高应用的执行效率，因为重新定义的函数执行的代码量更少。</p>
<blockquote>
<p>这种模式的另外一个名字是“函数的懒惰定义”，因为直到函数执行一次后才重新定义，可以说它是“某个时间点之后才存在”，简称“懒惰定义”。</p>
</blockquote>
<p>这种模式有一个明显的缺陷，就是之前给原函数添加的功能在重定义之后都丢失了。同时，如果这个函数被重定义为不同的名字，被赋值给不同的变量，或者是作为对象的方法使用，那么重定义的部分并不会生效，原来的函数依然会被执行。</p>
<h3 id="条件初始化"><a href="#条件初始化" class="headerlink" title="条件初始化"></a>条件初始化</h3><p>条件初始化（也叫条件加载）是一种优化模式。当你知道某种条件在整个程序生命周期中都不会变化的时候，那么对这个条件的探测只做一次就很有意义。浏览器探测（或者特征检测）是一个典型的例子。</p>
<pre><code>// 接口
var utils = {
    addListener: null,
    removeListener: null
};

// 实现
if (typeof window.addEventListener === &apos;function&apos;) {
    utils.addListener = function (el, type, fn) {
        el.addEventListener(type, fn, false);
    };
    utils.removeListener = function (el, type, fn) {
        el.removeEventListener(type, fn, false);
    };
} else if (typeof document.attachEvent === &apos;function&apos;) { // IE
    utils.addListener = function (el, type, fn) {
        el.attachEvent(&apos;on&apos; + type, fn);
    };
    utils.removeListener = function (el, type, fn) {
        el.detachEvent(&apos;on&apos; + type, fn);
    };
} else { // older browsers
    utils.addListener = function (el, type, fn) {
        el[&apos;on&apos; + type] = fn;
    };
    utils.removeListener = function (el, type, fn) {
        el[&apos;on&apos; + type] = null;
    };
}
</code></pre><p>当然，重定义函数也能实现这种效果。</p>
<h3 id="函数属性——记忆模式（Memoization）"><a href="#函数属性——记忆模式（Memoization）" class="headerlink" title="函数属性——记忆模式（Memoization）"></a>函数属性——记忆模式（Memoization）</h3><p>任何时候都可以给函数添加自定义属性。添加自定义属性的一个有用场景是缓存函数的执行结果（返回值），这样下次同样的函数被调用的时候就不需要再做一次那些可能很复杂的计算。缓存一个函数的运行结果也就是为大家所熟知的记忆模式。</p>
<pre><code>var myFunc = function (param) {
    if (!myFunc.cache[param]) {
        var result = {};
        // ……复杂的计算……
        myFunc.cache[param] = result;
    }
    return myFunc.cache[param];
};

// 缓存
myFunc.cache = {};
</code></pre><p>上面的代码假设函数只接受一个参数param，并且这个参数是原始类型（比如字符串）。如果你有更多更复杂的参数，则通常需要对它们进行序列化。比如，你需要将arguments对象序列化为JSON字符串，然后使用JSON字符串作为cache对象的key：</p>
<pre><code>var myFunc = function () {

    var cachekey = JSON.stringify(Array.prototype.slice.call(arguments)),
        result;

    if (!myFunc.cache[cachekey]) {
        result = {};
        // ……复杂的计算……
        myFunc.cache[cachekey] = result;
    }
    return myFunc.cache[cachekey];
};

// 缓存
myFunc.cache = {};
</code></pre><p>前面代码中的函数名还可以使用arguments.callee来替代，这样就不用将函数名硬编码。不过尽管现阶段这个办法可行，但是仍然需要注意，arguments.callee在ECMAScript5的严格模式中是不被允许的。</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>下面是通用的柯里化函数：</p>
<pre><code>function cury(fn){
    var slice = Array.prototype.slice;
    var stored_args = slice.call(arguments, 1);

    return function(){
        var new_args = slice.call(arguments),
            args = stored_args.concat(new_args);
        return fn.apply(null, args);
    }
}

// 测试
function sum(){
    var result = 0;
    for(var i = 0, len = arguments.length; i &lt; len; i++){
        result += arguments[i];
    }
    return result;
}

var newSum = cury(sum, 1,2,3,4,5,6);
console.log(newSum(2,3,5,4)); // 35
</code></pre><h4 id="什么时候使用柯里化"><a href="#什么时候使用柯里化" class="headerlink" title="什么时候使用柯里化"></a>什么时候使用柯里化</h4><p>当你发现自己在调用同样的函数并且传入的参数大部分都相同的时候，就是考虑柯里化的理想场景了。你可以通过传入一部分的参数动态地创建一个新的函数。这个新函数会存储那些重复的参数（所以你不需要再每次都传入），然后再在调用原始函数的时候将整个参数列表补全。</p>
<blockquote>
<p>apply()接受两个参数：第一个是在函数内部绑定到this上的对象，第二个是一个参数数组，参数数组会在函数内部变成一个类似数组的arguments对象。如果第一个参数为 <code>null</code>，那么this将指向全局对象，这正是当你调用一个函数（且这个函数不是某个对象的方法）时发生的事情。</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在介绍完背景和函数的语法后，介绍了一些有用的模式，按分类列出：</p>
<ol>
<li><p>API模式，它们帮助我们为函数给出更干净的接口，包括：</p>
<ul>
<li><p>回调模式</p>
<pre><code>传入一个函数作为参数
</code></pre></li>
<li><p>配置对象</p>
<pre><code>帮助保持函数的参数数量可控
</code></pre></li>
<li><p>返回函数</p>
<pre><code>函数的返回值是另一个函数
</code></pre></li>
<li><p>柯里化</p>
<pre><code>新函数在已有函数的基础上再加上一部分参数构成
</code></pre></li>
</ul>
</li>
<li><p>初始化模式，这些模式帮助我们用一种干净的、结构化的方法来做一些初始化工作（在web页面和应用中非常常见），通过一些临时变量来保证不污染全局命名空间。这些模式包括：</p>
<ul>
<li><p>即时函数</p>
<pre><code>当它们被定义后立即执行
</code></pre></li>
<li><p>对象即时初始化</p>
<pre><code>初始化工作被放入一个匿名对象，这个对象提供一个可以立即被执行的方法
</code></pre></li>
<li><p>条件初始化</p>
<pre><code>使分支代码只在初始化的时候执行一次，而不是在整个程序生命周期中反复执行
</code></pre></li>
</ul>
</li>
<li><p>性能模式，这些模式帮助提高代码的执行速度，包括：</p>
<ul>
<li><p>记忆模式</p>
<pre><code>利用函数的属性，使已经计算过的值不用再次计算
</code></pre></li>
<li><p>自定义函数</p>
<pre><code>重写自身的函数体，使第二次及后续的调用做更少的工作
</code></pre></li>
</ul>
</li>
</ol>
<h2 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h2><p>JavaScript语言本身很简单、直观，也没有其他语言的一些语言特性：命名空间、模块、包、私有属性以及静态成员。本章将介绍一些常用的模式，以此实现这些语言特性。</p>
<p>我们将对命名空间、依赖声明、模块模式以及沙箱模式进行初探——它们可以帮助我们更好地组织应用程序的代码，有效地减少全局污染的问题。除此之外，还会讨论私有和特权成员、静态和私有静态成员、对象常量、链式调用以及一种像类式语言一样定义构造函数的方法等话题。</p>
<h3 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h3><p>使用命名空间可以减少全局变量的数量，与此同时，还能有效地避免命名冲突和前缀的滥用。</p>
<p>本章后续要介绍的沙箱模式则可以避免这些缺点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 重构前：5个全局变量</div><div class="line">// 注意：反模式</div><div class="line">// 构造函数</div><div class="line">function Parent() &#123;&#125; </div><div class="line">function Child() &#123;&#125;</div><div class="line">// 一个变量</div><div class="line">var some_var = 1;</div><div class="line"></div><div class="line">// 一些对象</div><div class="line">var module1 = &#123;&#125;; </div><div class="line">module1.data = &#123;a: 1, b: 2&#125;; </div><div class="line">var module2 = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>可以通过创建一个全局对象（通常代表应用名）比如MYAPP来重构上述这类代码，然后将上述例子中的函数和变量都变为该全局对象的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 重构后：一个全局变量</div><div class="line">// 全局对象</div><div class="line">var MYAPP = &#123;&#125;;</div><div class="line"></div><div class="line">// 构造函数</div><div class="line">MYAPP.Parent = function () &#123;&#125;; </div><div class="line">MYAPP.Child = function () &#123;&#125;;</div><div class="line"></div><div class="line">// 一个变量</div><div class="line">MYAPP.some_var = 1;</div><div class="line"></div><div class="line">// 一个对象容器</div><div class="line">MYAPP.modules = &#123;&#125;;</div><div class="line"></div><div class="line">// 嵌套的对象</div><div class="line">MYAPP.modules.module1 = &#123;&#125;; </div><div class="line">MYAPP.modules.module1.data = &#123;a: 1, b: 2&#125;; </div><div class="line">MYAPP.modules.module2 = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>这种模式在大多数情况下非常适用，但也有它的缺点：</p>
<ul>
<li>代码量稍有增加；在每个函数和变量前加上这个命名空间对象的前缀，会增加代码量，增大文件大小</li>
<li>该全局实例可以被随时修改</li>
<li>命名的深度嵌套会减慢属性值的查询</li>
</ul>
<p>本章后续要介绍的沙箱模式则可以避免这些缺点。</p>
<h4 id="通用命名空间函数"><a href="#通用命名空间函数" class="headerlink" title="通用命名空间函数"></a>通用命名空间函数</h4><p>随着程序复杂度的提高，代码会被分拆在不同的文件中以按照页面需要来加载，这样一来，就不能保证你的代码一定是第一个定义命名空间或者某个属性的，甚至会发生属性覆盖的问题。所以，在创建命名空间或者添加属性的时候，最好先检查下是否存在，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 不安全的做法</div><div class="line">var MYAPP = &#123;&#125;;</div><div class="line">// 更好的做法</div><div class="line">if (typeof MYAPP === &quot;undefined&quot;) &#123;</div><div class="line">    var MYAPP = &#123;&#125;; </div><div class="line">&#125;</div><div class="line">// 简写</div><div class="line">var MYAPP = MYAPP || &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>如上所示，如果每次做类似操作都要这样检查一下就会有很多重复的代码。例如，要声明MYAPP.modules.module2，就要重复三次这样的检查。所以，我们需要一个可复用的namespace()函数来专门处理这些检查工作，然后用它来创建命名空间，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 使用命名空间函数</div><div class="line">MYAPP.namespace(&apos;MYAPP.modules.module2&apos;);</div><div class="line"></div><div class="line">// 等价于：</div><div class="line">// var MYAPP = &#123;</div><div class="line">//  modules: &#123;</div><div class="line">//      module2: &#123;&#125;</div><div class="line">//  &#125;</div><div class="line">// &#125;;</div></pre></td></tr></table></figure></p>
<p>下面是上述namespace函数的实现示例。这种实现是非破坏性的，意味着如果要创建的命名空间已经存在，则不会再重复创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var MYAPP = MYAPP || &#123;&#125;;</div><div class="line"></div><div class="line">MYAPP.namespace = function(ns_string)&#123;</div><div class="line">    var parts = ns_string.split(&quot;.&quot;),</div><div class="line">        parent = MYAPP;</div><div class="line"></div><div class="line">    if(parts[0] === &quot;MYAPP&quot;)&#123;</div><div class="line">        parts.shift();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(var i = 0, len = parts.length; i &lt; len; i++)&#123;</div><div class="line">        if(parent[parts[i]] === undefined)&#123;</div><div class="line">            parent[parts[i]] = &#123;&#125;</div><div class="line">        &#125;</div><div class="line">        parent = parent[parts[i]]</div><div class="line">    &#125;</div><div class="line">    return parent;</div><div class="line">&#125;</div><div class="line">var module2 = MYAPP.namespace(&quot;MYAPP.modules.module2&quot;);</div><div class="line">console.log(module2 === MYAPP.modules.module2); // true</div><div class="line"></div><div class="line">var modules = MYAPP.namespace(&quot;modules&quot;);</div><div class="line">console.log(modules === MYAPP.modules); // true</div></pre></td></tr></table></figure></p>
<h3 id="依赖声明"><a href="#依赖声明" class="headerlink" title="依赖声明"></a>依赖声明</h3><p>JavaScript库往往是模块化而且有用到命名空间的，这使得你可以只使用你需要的模块。比如在YUI2中，全局变量YAHOO就是一个命名空间，各个模块都是全局变量的属性，比如YAHOO.util.Dom（DOM模块）、YAHOO.util.Event（事件模块）。</p>
<p>将你的代码依赖在函数或者模块的顶部进行声明是一个好主意。声明就是创建一个本地变量，指向你需要用到的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myFunction = function () &#123;</div><div class="line">    // 依赖</div><div class="line">    var event = YAHOO.util.Event,</div><div class="line">        dom = YAHOO.util.Dom;</div><div class="line"></div><div class="line">    // 在函数后面的代码中使用event和dom……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>这是一个相当简单的模式，但是有很多的好处：</strong></p>
<ul>
<li>明确的依赖声明是告知使用你代码的开发者，需要保证指定的脚本文件被包含在页面中。</li>
<li>将声明放在函数顶部使得依赖很容易被查找和解析。</li>
<li>本地变量（如dom）永远会比全局变量（如YAHOO）要快，甚至比全局变量的属性（如YAHOO.util.Dom）还要快，这样会有更好的性能。使用了依赖声明模式之后，全局变量的解析在函数中只会进行一次，在此之后将会使用更快的本地变量（备注：本地变量直接指向最后一级对象，event）。</li>
<li>一些高级的代码压缩工具比如YUI Compressor和Google Closure compiler会重命名本地变量（比如event可能会被压缩成一个字母，如A），这会使代码更精简，但这个操作不会对全局变量进行，因为这样做不安全。</li>
</ul>
<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><h4 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h4><p>通过闭包实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Gadget() &#123;</div><div class="line">    // 私有成员</div><div class="line">    var name = &apos;iPod&apos;;</div><div class="line">    // 公有函数</div><div class="line">    this.getName = function () &#123;</div><div class="line">        return name;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var toy = new Gadget();</div><div class="line"></div><div class="line">// name是是私有的</div><div class="line">console.log(toy.name); // undefined</div><div class="line">// 公有方法可以访问到name</div><div class="line">console.log(toy.getName()); // &quot;iPod&quot;</div></pre></td></tr></table></figure></p>
<h4 id="特权方法"><a href="#特权方法" class="headerlink" title="特权方法"></a>特权方法</h4><p>特权方法的概念不涉及到任何语法，它只是一个给可以访问到私有成员的公有方法的名字（就好像它们有更多权限一样）。<br>在前面的例子中，getName()就是一个特权方法，因为它有访问name属性的特殊权限。</p>
<h4 id="私有成员失效"><a href="#私有成员失效" class="headerlink" title="私有成员失效"></a>私有成员失效</h4><p>当你直接通过特权方法返回一个私有变量，而这个私有变量恰好是一个对象或者数组时，外部的代码可以修改这个私有变量，因为它是按引用传递的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Gadget() &#123;</div><div class="line">    // 私有成员</div><div class="line">    var specs = &#123;</div><div class="line">        screen_width: 320,</div><div class="line">        screen_height: 480,</div><div class="line">        color: &quot;white&quot;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // 公有函数</div><div class="line">    this.getSpecs = function () &#123;</div><div class="line">        return specs; // 直接返回对象（数组也是对象），会导致私有对象能在外面被修改</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>解决方法：</strong>返回精简后新对象（返回需要用到的部分属性），或对私有对象进行复制（返回副本）。</p>
<blockquote>
<p>众所周知的“最低授权原则”（Principle of Least Authority，简称POLA），指永远不要给出比真实需要更多的东西。</p>
</blockquote>
<h4 id="原型和私有成员"><a href="#原型和私有成员" class="headerlink" title="原型和私有成员"></a>原型和私有成员</h4><p>使用构造函数创建私有成员的一个弊端是，每一次调用构造函数创建对象时这些私有成员都会被创建一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function Gadget() &#123;</div><div class="line">    // 私有成员</div><div class="line">    var name = &apos;iPod&apos;;</div><div class="line">    // 公有函数</div><div class="line">    this.getName = function () &#123;</div><div class="line">        return name;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Gadget.prototype = (function () &#123;</div><div class="line">    // 私有成员</div><div class="line">    var browser = &quot;Mobile Webkit&quot;;</div><div class="line">    // 公有函数</div><div class="line">    return &#123;</div><div class="line">        getBrowser: function () &#123;</div><div class="line">            return browser;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">var toy = new Gadget();</div><div class="line">console.log(toy.getName()); // 自有的特权方法 </div><div class="line">console.log(toy.getBrowser()); // 来自原型的特权方法</div></pre></td></tr></table></figure></p>
<h4 id="将私有函数暴露为公有方法"><a href="#将私有函数暴露为公有方法" class="headerlink" title="将私有函数暴露为公有方法"></a>将私有函数暴露为公有方法</h4><p>“暴露模式”是指将已经有的私有函数暴露为公有方法。</p>
<p>我们来看一个例子，它建立在对象字面量的私有成员模式之上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var myarray;</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line"></div><div class="line">    var astr = &quot;[object Array]&quot;,</div><div class="line">        toString = Object.prototype.toString;</div><div class="line"></div><div class="line">    function isArray(a) &#123;</div><div class="line">        return toString.call(a) === astr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function indexOf(haystack, needle) &#123;</div><div class="line">        var i = 0,</div><div class="line">            max = haystack.length;</div><div class="line">        for (; i &lt; max; i += 1) &#123;</div><div class="line">            if (haystack[i] === needle) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return −1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    myarray = &#123;</div><div class="line">        isArray: isArray,</div><div class="line">        indexOf: indexOf,</div><div class="line">        inArray: indexOf</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>模块模式使用得很广泛，因为它可以为代码提供特定的结构，帮助组织日益增长的代码。不像其它语言，JavaScript没有专门的“包”（package）的语法，但模块模式提供了用于创建独立解耦的代码片段的工具，这些代码可以被当成黑盒，当你正在写的软件需求发生变化时，这些代码可以被添加、替换、移除。</p>
<p>模块模式是我们目前讨论过的好几种模式的组合，即：</p>
<ul>
<li>命名空间模式</li>
<li>即时函数模式</li>
<li>私有和特权成员模式</li>
<li>依赖声明模式</li>
</ul>
<p>第一步是初始化一个命名空间。我们使用本章前面部分的namespace()函数，创建一个提供数组相关方法的套件模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MYAPP.namespace(&apos;MYAPP.utilities.array&apos;);</div></pre></td></tr></table></figure></p>
<p>下一步是定义模块。使用一个即时函数来提供私有作用域供私有成员使用。即时函数返回一个对象，也就是带有公有接口的真正的模块，可以供其它代码使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MYAPP.utilities.array = (function () &#123;</div><div class="line">    return &#123;</div><div class="line">        // todo...</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>下一步，给公有接口添加一些方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">MYAPP.utilities.array = (function () &#123;</div><div class="line">    return &#123;</div><div class="line">        inArray: function (needle, haystack) &#123;</div><div class="line">            // ...</div><div class="line">        &#125;,</div><div class="line">        isArray: function (a) &#123;</div><div class="line">            // ...</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>如果需要的话，你可以在即时函数提供的闭包中声明私有属性和私有方法。同样，依赖声明放置在函数顶部，在变量声明的下方可以选择性地放置辅助初始化模块的一次性代码。函数最终返回的是一个包含模块公共API的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">MYAPP.namespace(&apos;MYAPP.utilities.array&apos;);</div><div class="line">MYAPP.utilities.array = (function () &#123;</div><div class="line"></div><div class="line">        // 依赖声明</div><div class="line">    var uobj = MYAPP.utilities.object,</div><div class="line">        ulang = MYAPP.utilities.lang,</div><div class="line"></div><div class="line">        // 私有属性</div><div class="line">        array_string = &quot;[object Array]&quot;,</div><div class="line">        ops = Object.prototype.toString;</div><div class="line"></div><div class="line">        // 私有方法</div><div class="line">        // ……</div><div class="line"></div><div class="line">        // 结束变量声明</div><div class="line"></div><div class="line">    // 选择性放置一次性初始化的代码</div><div class="line">    // ……</div><div class="line"></div><div class="line">    // 公有API</div><div class="line">    return &#123;</div><div class="line"></div><div class="line">        inArray: function (needle, haystack) &#123;</div><div class="line">            for (var i = 0, max = haystack.length; i &lt; max; i += 1) &#123;</div><div class="line">                if (haystack[i] === needle) &#123;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        isArray: function (a) &#123;</div><div class="line">            return ops.call(a) === array_string;</div><div class="line">        &#125;</div><div class="line">        // ……更多的方法和属性</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>模块模式被广泛使用，是一种值得强烈推荐的模式，它可以帮助我们组织代码，尤其是代码量在不断增长的时候。</p>
<h4 id="暴露模块模式"><a href="#暴露模块模式" class="headerlink" title="暴露模块模式"></a>暴露模块模式</h4><p>我们在本章中讨论私有成员模式时已经讨论过暴露模式。模块模式也可以用类似的方法来组织，将所有的方法保持私有，只在最后暴露需要使用的方法来初始化API。</p>
<p>上面的例子可以变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">MYAPP.utilities.array = (function () &#123;</div><div class="line"></div><div class="line">        // 私有属性</div><div class="line">    var array_string = &quot;[object Array]&quot;,</div><div class="line">        ops = Object.prototype.toString,</div><div class="line"></div><div class="line">        // 私有方法</div><div class="line">        inArray = function (haystack, needle) &#123;</div><div class="line">            for (var i = 0, max = haystack.length; i &lt; max; i += 1) &#123;</div><div class="line">                if (haystack[i] === needle) &#123;</div><div class="line">                    return i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return −1;</div><div class="line">        &#125;,</div><div class="line">        isArray = function (a) &#123;</div><div class="line">            return ops.call(a) === array_string;</div><div class="line">        &#125;;</div><div class="line">        // 结束变量定义</div><div class="line"></div><div class="line">    // 暴露公有API</div><div class="line">    return &#123;</div><div class="line">        isArray: isArray,</div><div class="line">        indexOf: inArray</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<h4 id="在模块中引入全局上下文"><a href="#在模块中引入全局上下文" class="headerlink" title="在模块中引入全局上下文"></a>在模块中引入全局上下文</h4><p>作为这种模式的一个常见的变种，你可以给包裹模块的即时函数传递参数。你可以传递任何值，但通常情况下会传递全局变量甚至是全局对象本身。引入全局上下文可以加快函数内部的全局变量的解析，因为引入之后会作为函数的本地变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MYAPP.utilities.module = (function (app, global) &#123;</div><div class="line"></div><div class="line">    // 全局对象和全局命名空间都作为本地变量存在</div><div class="line"></div><div class="line">&#125;(MYAPP, this));</div></pre></td></tr></table></figure></p>
<h2 id="代码复用模式"><a href="#代码复用模式" class="headerlink" title="代码复用模式"></a>代码复用模式</h2><p>在做代码复用的工作的时候，谨记Gang of Four在书中给出的关于对象创建的建议：“优先使用对象创建而不是类继承”。</p>
<p>类式（传统）继承（classical inheritance） vs 现代继承模式<br>类式继承：按照类的方式考虑JavaScript，并产生了一些假定在类的基础上的开发思路和继承模式。<br>现代继承模式：其他任何不需要以类的方式考虑的模式。</p>
<p>当需要给项目选择一个继承模式时，有不少的备选方案。你应该尽量选择那些现代继承模式，除非团队已经觉得“无类不欢”。</p>
<p>跳过类继承..</p>
<h3 id="通过复制属性实现继承"><a href="#通过复制属性实现继承" class="headerlink" title="通过复制属性实现继承"></a>通过复制属性实现继承</h3><p>在这种模式中，一个对象通过简单地复制另一个对象来获得功能。下面是一个简单的实现这种功能的extend()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function extend(parent, child) &#123;</div><div class="line">    var i;</div><div class="line">    child = child || &#123;&#125;;</div><div class="line">    for (i in parent) &#123;</div><div class="line">        if (parent.hasOwnProperty(i)) &#123;</div><div class="line">            child[i] = parent[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面给出的实现叫作对象的“浅拷贝”（shallow copy），与之相对，“深拷贝”是指检查准备复制的属性本身是否是对象或者数组，如果是，也遍历它们的属性并复制。如果使用浅拷贝的话（因为在JavaScript中对象是按引用传递），如果你改变子对象的一个属性，而这个属性恰好是一个对象，那么你也会改变父对象。实际上这对方法来说可能很好（因为函数也是对象，也是按引用传递），但是当遇到其它的对象和数组的时候可能会有些意外情况。</p>
<p>现在让我们来修改一下extend()函数以便实现深拷贝。你需要做的事情只是检查一个属性的类型是否是对象，如果是，则递归遍历它的属性。另外一个需要做的检查是这个对象是真的对象还是数组，可以使用第三章讨论过的数组检查方式。最终深拷贝版的extend()是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function extendDeep(parent, child) &#123;</div><div class="line">    var i,</div><div class="line">        toStr = Object.prototype.toString,</div><div class="line">        astr = &quot;[object Array]&quot;;</div><div class="line"></div><div class="line">    child = child || &#123;&#125;;</div><div class="line"></div><div class="line">    for (i in parent) &#123;</div><div class="line">        if (parent.hasOwnProperty(i)) &#123;</div><div class="line">            if (typeof parent[i] === &quot;object&quot;) &#123;</div><div class="line">                child[i] = (toStr.call(parent[i]) === astr) ? [] : &#123;&#125;;</div><div class="line">                extendDeep(parent[i], child[i]);</div><div class="line">            &#125; else &#123;</div><div class="line">                child[i] = parent[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种模式并不高深，因为根本没有原型牵涉进来，而只跟对象和它们的属性有关。</p>
<h3 id="混元（Mix-ins）"><a href="#混元（Mix-ins）" class="headerlink" title="混元（Mix-ins）"></a>混元（Mix-ins）</h3><p>“混元”模式，从任意多数量的对象中复制属性，然后将它们混在一起组成一个新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function mix() &#123;</div><div class="line">    var arg, prop, child = &#123;&#125;;</div><div class="line">    for (arg = 0; arg &lt; arguments.length; arg += 1) &#123;</div><div class="line">        for (prop in arguments[arg]) &#123;</div><div class="line">            if (arguments[arg].hasOwnProperty(prop)) &#123;</div><div class="line">                child[prop] = arguments[arg][prop];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们只是简单地遍历、复制自有属性，并没有与父对象有任何链接。</p>
<h3 id="借用方法"><a href="#借用方法" class="headerlink" title="借用方法"></a>借用方法</h3><p>apply、call、bind（ES5）。<br>apply是接受数组，而call是接受一个一个的参数。</p>
<p>在低于ES5的环境中时如何实现Function.prototype.bind()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (typeof Function.prototype.bind === &quot;undefined&quot;) &#123;</div><div class="line">    Function.prototype.bind = function (thisArg) &#123;</div><div class="line">        var fn = this,</div><div class="line">        slice = Array.prototype.slice,</div><div class="line">        args = slice.call(arguments, 1);</div><div class="line"></div><div class="line">        return function () &#123;</div><div class="line">            return fn.apply(thisArg, args.concat(slice.call(arguments)));</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>在JavaScript中，继承有很多种方案可以选择，在本章中你看到了很多类式继承和现代继承的方案。学习和理解不同的模式是有好处的，因为这可以增强你对这门语言的掌握能力。</p>
<p>但是，也许在开发过程中继承并不是你经常面对的一个问题。一部分是因为这个问题已经被使用某种方式或者某个你使用的类库解决了，另一部分是因为你不需要在JavaScript中建立很长很复杂的继承链。在静态强类型语言中，继承可能是唯一可以复用代码的方法，但在JavaScript中有更多更简单更优化的方法，包括借用方法、绑定、复制属性、混元等。</p>
<p>记住，代码复用才是目标，继承只是达成这个目标的一种手段。</p>
<h2 id="DOM与浏览器模式"><a href="#DOM与浏览器模式" class="headerlink" title="DOM与浏览器模式"></a>DOM与浏览器模式</h2><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>所谓的延迟加载是指在页面的load事件之后再加载外部文件。通常，将一个大的合并后的文件分成两部分是有好处的：</p>
<ul>
<li>一部分是页面初始化和绑定UI元素的事件处理函数必须的</li>
<li>第二部分是只在用户交互或者其它条件下才会用到的</li>
</ul>
<p>分成两部分的目标就是逐步加载页面，让用户尽快可以进行一些操作。剩余的部分在用户可以看到页面的时候再在后台加载。</p>
<p>加载第二部分JavaScript的方法也是使用动态script元素，将它加在head或者body中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    ……页面主体部分……</div><div class="line"></div><div class="line">    &lt;!-- 第二块结束 --&gt;</div><div class="line">    &lt;script src=&quot;all_20100426.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">    window.onload = function () &#123;</div><div class="line">        var script = document.createElement(&quot;script&quot;);</div><div class="line">        script.src = &quot;all_lazy_20100426.js&quot;;</div><div class="line">        document.documentElement.firstChild.appendChild(script);</div><div class="line">    &#125;;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>创建一个require()函数或者方法，它接受一个需要被加载的脚本文件的文件名，还有一个在脚本被加载完毕后执行的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require(&quot;extra.js&quot;, function () &#123;</div><div class="line">    functionDefinedInExtraJS();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function require(file, callback) &#123;</div><div class="line"></div><div class="line">    var script = document.getElementsByTagName(&apos;script&apos;)[0], newjs = document.createElement(&apos;script&apos;);</div><div class="line"></div><div class="line">    // IE</div><div class="line">    newjs.onreadystatechange = function () &#123;</div><div class="line">        if (newjs.readyState === &apos;loaded&apos; || newjs.readyState === &apos;complete&apos;) &#123;</div><div class="line">            newjs.onreadystatechange = null;</div><div class="line">            callback();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // 其它浏览器</div><div class="line">    newjs.onload = function () &#123;</div><div class="line">        callback();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    newjs.src = file;</div><div class="line">    script.parentNode.insertBefore(newjs, script);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个实现的几点说明：</p>
<ul>
<li>在IE中需要监听readystatechange事件，然后判断状态是否为”loaded”或者”complete”。其它的浏览器会忽略这里。</li>
<li>在Firefox，Safari和Opera中，通过onload属性监听load事件。</li>
<li>这个方法在Safari 2中无效。如果必须要处理这个浏览器，需要设一个定时器，周期性地去检查某个指定的变量（在脚本中定义的）是否有定义。当它变成已定义时，就意味着新的脚本已经被加载并执行。</li>
</ul>
<h3 id="预加载JavaScript"><a href="#预加载JavaScript" class="headerlink" title="预加载JavaScript"></a>预加载JavaScript</h3><p>在延迟加载模式和按需加载模式中，我们加载了当前页面需要用到的脚本，除此之外，我们也可以加载当前页面不需要但可能在接下来的页面中需要的脚本。这样的话，当用户进入第二个页面时，脚本已经被预加载过，整体体验会变得更快。</p>
<p>预加载可以简单地通过动态脚本模式实现，但这也意味着脚本会被解析和执行。解析仅仅会在页面加载时间中增加预加载消耗的时间，但执行却可能导致JavaScript错误，因为预加载的脚本会假设自己运行在第二个页面上，比如找一个特定的DOM节点就可能出错。</p>
<p>仅加载脚本而不解析和执行是可能的，这也同样适用于CSS和图像。</p>
<p>在IE中，你可以使用熟悉的图片信标模式来发起请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Image().src = &quot;preloadme.js&quot;;</div></pre></td></tr></table></figure></p>
<p>在其它的浏览器中，你可以使用<object>替代script元素，然后将它的data属性指向脚本的URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj = document.createElement(&apos;object&apos;);</div><div class="line">obj.data = &quot;preloadme.js&quot;;</div><div class="line">document.body.appendChild(obj);</div></pre></td></tr></table></figure></object></p>
<p>为了阻止object可见，你应该设置它的width和height属性为0。</p>
<p>你可以创建一个通用的preload()函数或者方法，使用条件初始化模式（第四章）来处理浏览器差异：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var preload;</div><div class="line">if (/*@cc_on!@*/false) &#123; // IE支持条件注释</div><div class="line">    preload = function (file) &#123;</div><div class="line">        new Image().src = file;</div><div class="line">    &#125;;</div><div class="line">&#125; else &#123;</div><div class="line">    preload = function (file) &#123;</div><div class="line">        var obj = document.createElement(&apos;object&apos;),</div><div class="line">            body = document.body;</div><div class="line"></div><div class="line">        obj.width = 0;</div><div class="line">        obj.height = 0;</div><div class="line">        obj.data = file;</div><div class="line">        body.appendChild(obj);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这个新函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">preload(&apos;my_web_worker.js&apos;);</div></pre></td></tr></table></figure></p>
<p>这种模式的坏处在于存在用户代理（浏览器）嗅探，但这里无法避免，因为特性检测没有办法告知足够的浏览器行为信息。比如在这个模式中，理论上你可以测试typeof Image是否是”function”来代替嗅探，但这种方法其实没有作用，因为所有的浏览器都支持new Image()；只是有一些浏览器会为图片单独做缓存，意味着作为图片缓存下来的组件（文件）在第二个页面中不会被作为脚本取出来，而是会重新下载。</p>
<blockquote>
<p>浏览器嗅探中使用条件注释很有意思，这明显比在<code>navigator.userAgent</code>中找字符串要安全得多，因为用户可以很容易地修改这些字符串。 比如： <code>var isIE = /*@cc_on!@*/false</code>; 会在其它的浏览器中将<code>isIE</code>设为<code>false</code>（因为忽略了注释），但在IE中会是<code>true</code>，因为在条件注释中有取反运算符!。在IE中就像是这样： var isIE = !false; // true</p>
</blockquote>
<p>预加载模式可以被用于各种组件（文件），而不仅仅是脚本。比如在登录页就很有用，当用户开始输入用户名时，你可以使用打字的时间开始预加载（非敏感的东西），因为用户很可能会到第二个也就是登录后的页面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在软件开发过程中，模式是指一个通用问题的解决方案。一个模式不仅仅是一个可以用来复制粘贴的代码解决方案，更多地是提供了一个更好的实践经验、有用的抽象化表示和解决一类问题的模板。&lt;br&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>white-space:nowrap 的妙用</title>
    <link href="http://yoursite.com/2016/04/10/2016-4-10-white-space-clever/"/>
    <id>http://yoursite.com/2016/04/10/2016-4-10-white-space-clever/</id>
    <published>2016-04-10T07:09:23.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于多个元素同在同一行的布局，如比较常见的是轮播。下面我将探讨这这一布局的做法：<br>首先约定<code>html</code>结果如下：</p>
<pre><code>div.row
  div.col
  div.col
  div.col
  ...
</code></pre><a id="more"></a>
<h3 id="做法一："><a href="#做法一：" class="headerlink" title="做法一："></a>做法一：</h3><p>设定<code>div.row</code>的宽度为<code>div.col宽度*div.col的个数</code>，然后设置<code>div.col</code>为<code>float:left</code>或<code>display:inline-block</code><br>对于 <code>float:left</code>, <code>div.row</code> 需要清除浮动。<br>对于 <code>display:inline-block</code>，需要压缩html或者为<code>div.row</code>设置 <code>font-size:0</code> 以去除 <code>div.col</code> 之间的水平间隙，后者也顺便去除了垂直方向的间隙（line-height为相对单位时，其最终值为line-height值*font-size）。对于前者，还有垂直方面的间隙未去除，我们可以为<code>div.col</code>设置 <code>vertical-align:top</code> 或为<code>div.row</code>设置 <code>line-height:0</code>。推荐前者（即vertical-align），因为当 <code>div.col</code> 高度不相等时，会按顶部对齐，当然你也可以<code>bottom</code>或<code>middle</code>。而且，如果<code>div.col</code>内含有行内元素或inline-block元素时，<code>div.col</code>会按其子元素最后一行<code>inline/inline-block</code>元素的基线进行垂直方向上的对齐（vertical-align默认值是baseline）。因此最好显式设置<code>div.col</code>的垂直方向上的对齐。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/nowrap-baseline.jpg" alt="baseline基线"><br>baseline基线</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/nowrap-jianxi.jpg" alt="水平与竖直方向上的间隙"><br>水平与竖直方向上的间隙</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/nowrap-inlineORinline-block.jpg" alt="按其子元素最后一行inline/inline-block元素的基线进行垂直方向上的对齐"><br>按其子元素最后一行<code>inline/inline-block</code>元素的基线进行垂直方向上的对齐</p>
<blockquote>
<p>这也符合张鑫旭老师的《<a href="http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" target="_blank" rel="external">CSS深入理解vertical-align和line-height的基友关系</a>》这篇文章讲到的：一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。</p>
</blockquote>
<p>补充知识：line-height的值为<strong>数字</strong>与<strong>百分比</strong>的区别</p>
<blockquote>
<p>百分比是当前元素的字体大小<code>*</code>百分比，算出的值让后代元素继承（固定值，后代元素均用此值）；而数字是让后代元素的字体大小<code>*</code>数值（相对值，后代元素根据自身字体大小算出适合的行高）。具体可以看 《<a href="http://www.cnblogs.com/fengzheng126/archive/2012/05/18/2507632.html" target="_blank" rel="external">深入了解css的行高Line Height属性</a>》。</p>
</blockquote>
<p>当然，如果<code>div.row</code>内有行内元素或inline-block元素，它们会继承父元素的font-size与line-height，因此需要重新设置font-size和line-height，以覆盖<code>div.row</code>对应的值。</p>
<p>做法一的案例有：淘宝首页的主轮播（通过子元素浮动，父元素清除浮动）。<br>这种做法的好处有：①兼容性好，无须清除<code>div.col</code>直接的间隙，因为浮动后的元素会一直与当前行框（line box）顶部对齐，vertical-align对齐无效。<br>不好的地方：要计算<code>div.row</code>的宽度。</p>
<h3 id="做法二（这也是我想讲的巧妙）"><a href="#做法二（这也是我想讲的巧妙）" class="headerlink" title="做法二（这也是我想讲的巧妙）"></a>做法二（这也是我想讲的巧妙）</h3><p>直接上代码：</p>
<pre><code>*{
    margin: 0;
    padding: 0;
}
.row{
    white-space: nowrap; // 让div.col放置在同一行
    background-color: rgb(0,0,0); // 背景色，以方便观察
    font-size: 0; // 去除水平+垂直间隙
}
.col{
    display: inline-block;
    *display: inline; // 兼容IE 6/7，模拟inline-block效果
    *zoom: 1; // 兼容IE 6/7，模拟inline-block效果
    width: 20%; 
    margin-right: 30px;
    height: 100px;
    background-color: red;
    font-size: 14px; // 覆盖父元素的font-size
    vertical-align: top; // 向上对齐，同时去除垂直间隙
}
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/nowrap-GIF.gif" alt="此处输入图片的描述"><br>黑色背景是<code>div.row</code>，红色背景是 <code>div.col</code>。</p>
<p>可看出这与与应用了<code>white-space:nowrap</code>的文本容器效果一样。</p>
<p>####做法二的好处有：<br>①兼容性好（IE5都正常），无须计算宽度，可任意放多个 <code>div.col</code>，而 <code>div.row</code> 的宽度等于其父元素的宽度（但IE6则会将div.row撑大，在IE6中，<code>width</code>如同<code>min-width</code>效果，<code>height</code>也是）。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/nowrap-GIF-IE56.gif" alt="IE5/6效果"><br>IE5上的效果，IE6应该也一样。</p>
<hr>
<p>如果你还有其它想法，欢迎大家在评论处告诉我哦。</p>
<p><a href="https://github.com/JChehe/blog" target="_blank" rel="external">github-JChehe</a>。<br><a href="http://jchehe.github.io/resume/" target="_blank" rel="external">静态博客</a> &lt;- 小心这心机婊</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于多个元素同在同一行的布局，如比较常见的是轮播。下面我将探讨这这一布局的做法：&lt;br&gt;首先约定&lt;code&gt;html&lt;/code&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;div.row
  div.col
  div.col
  div.col
  ...
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="white-space" scheme="http://yoursite.com/tags/white-space/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》读书笔记</title>
    <link href="http://yoursite.com/2016/04/05/2016-4-5-illustration-http/"/>
    <id>http://yoursite.com/2016/04/05/2016-4-5-illustration-http/</id>
    <published>2016-04-05T00:47:42.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>HTTP（HyperText Transfer Protocol，超文转移协议，超文本传输协议的译法并不严谨。）</p>
<h3 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h3><h4 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h4><p>TCP/IP 协议族是互联网相关联的协议的集合。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等。而HTTP是属于它内部的一个子集。</p>
<a id="more"></a>
<h4 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP/IP 的分层管理"></a>TCP/IP 的分层管理</h4><p>TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。<br>分层的好处：把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。而且，层次化之后，设计也变得相对简单。处于应用层上的应用可以只考虑分派给自己的任务，而无需弄清对方在地球上哪个地方、对方的传输路线、是否能确保传输送达等问题。</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。<br>TCP/IP 协议族预存了各类通用的应用服务。如 FTP（File Transfer Protocol）、DNS（Domain Name System）和 HTTP。</li>
<li>传输层：该层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP（Transmission Control Protocol）和 UDP（User Data Protocol，用户数据报协议）。</li>
<li>网络层：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎么样的路径到达对方计算机，并把数据包传送给对方。</li>
<li>链路层：用来处理网络的硬件部分。</li>
</ul>
<h4 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h4><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-9.jpg" alt="缺一张照片P9"></p>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>用HTTP 举例来说：首先作为发送端的客户端在应用层（HTTP协议）发出一个HTTP请求。<br>接着，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分隔，并在各个报文上打上标记序号及端口号后转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这就让发往网络的通信请求准备齐全了。<br>接收端的服务器在链路层接收到数据后，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到客户端发送过来的HTTP请求。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-10.jpg" alt="&gt; 缺一张照片P10"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>把数据信息包装起来的做法称为封装。</p>
<h3 id="与HTTP关系密切的协议：IP、TCP和DNS"><a href="#与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="与HTTP关系密切的协议：IP、TCP和DNS"></a>与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h4><p>IP（网际协议）位于网络层。该协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中最重要的两个条件是 IP 地址和 MAC地址。<br>IP 地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。</p>
<p><strong>使用ARP协议凭借MAC地址进行通信</strong><br>IP间通信通信依赖MAC地址。通信的双方通常会经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。该协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-12.jpg" alt="此处输入图片的描述"></p>
<h4 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h4><p>TCP属于传输层，提供可靠的字节流服务。<br>字节流服务是指：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。<br>这就是为什么下载高清大图时，图片会一块一块地加载。</p>
<p><strong>三次握手</strong><br>为了准确无误地将数据送达目标处，TCP协议在发送数据的准备阶段采用了三次握手策略（若在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包）。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-13.jpg" alt="&gt; 缺图片P13"></p>
<p>当然，除了三次握手，TCP还有其它各种手段确保通信的可靠性。</p>
<h3 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h3><p>DNS服务提供域名到IP 地址之间的解析服务。<br>即可通过域名查找IP，或逆向从IP地址反查域名服务。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-14.jpg" alt="此处输入图片的描述"></p>
<p>因为域名解析也需要时间，所以可以 <a href="http://fanyi.jobbole.com/14191/" target="_blank" rel="external">提前获取DNS来提升网页加载速度</a>。</p>
<h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI（uniform Resource Identifier）<br>Uniform：规定统一的格式可方便处理多种不同类型的资源。<br>Resource：可标识的任何东西<br>Identifier：标识符</p>
<p>URI就是某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称，如http、ftp。</p>
<p>URI 用字符串标识某一个互联网资源，而URL表示资源的地点。URL是URI的子集。</p>
<p>表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处指定的URL，如 <code>/image/logo.gif</code>。</p>
<p>绝对URI的格式如下：</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-18.jpg" alt="图片P18"></p>
<h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><p>HTTP协议规定，先从客户端开始建立通信，服务端在没有接收到请求之前不会发送响应。</p>
<p>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p> <img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-24.jpg" alt="&gt; 图片P24"></p>
<p> 响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-25.jpg" alt="&gt; 图片P25"></p>
<h3 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h3><p>HTTP是无状态协议。自身不对请求和响应之间通信状态进行保存（即不做持久化处理）。<br>HTTP之所以设计得如此简单，是为了更快地处理大量事物，确保协议的可伸缩性。<br>HTTP/1.1 随时无状态协议，但可通过 Cookie 技术保存状态。</p>
<h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><ul>
<li>GET：获取资源</li>
<li>POST：传输实体主体</li>
<li>PUT：传输文件</li>
<li>HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。</li>
<li>DELETE：删除文件，与PUT相反（响应返回204 No Content）。</li>
<li>OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法（Allow:GET、POST、HEAD、OPTIONS）。</li>
<li>TRACE：追踪路径</li>
<li>CONNECT：要求用隧道协议连接代理（主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输）。</li>
</ul>
<p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。方法名区分大小写，主要要用大写字母。</p>
<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-34.jpg" alt="此处输入图片的描述"></p>
<p>发送请求一份包含多张图片的HTML文档对应的Web页面，会产生大量通信开销。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-35.jpg" alt="此处输入图片的描述"><br>为了解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive 或 HTTP Connection resue）的方法。<br><strong>持久连接的特点</strong>是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-36.jpg" alt="TCP持久连接"></p>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也相应提高了。</p>
<p>在HTTP/1.1中，所有连接默认都是持久连接，但在HTTP/1.0内并未标准化。<br>毫无疑问，除了服务器端，客户端也需要支持持久连接。</p>
<h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不等等待响应亦可直接发送下一个请求（并行发送多个请求）。</p>
<blockquote>
<p>每个浏览器支持的请求并发数不同，但可在页面中使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价。</p>
</blockquote>
<h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。<br>Cookie会根据从服务器端发送的响应报文内的一个叫做 <code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。</p>
<blockquote>
<p>Cookie-free Domains：用户在请求静态资源时，也会发送cookie信息。对于一个拥有多个静态资源的网站，这无疑会产生不必要的流量。因此我们可以启用与主站不同的域名（包括子域名）来放置静态资源。</p>
</blockquote>
<h2 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h2><p>用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文。HTTP报文本身是由多行（用CR+LF做换行符）数据构成的字符串文本。</p>
<p>HTTP报文大致可分为报文首部和报文主体两部块。两者由最初出现的空行（CR+LF、回车符+换行符）来划分。通常，并不一定要有报文主体。</p>
<h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率，但这会消耗更多的CPU等资源。</p>
<h4 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h4><p>报文：是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。<br>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p>
<p>HTTP报文的主体用于传输请求或响应的实体主体。<br>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br>常见的内容编码有：gzip（GNU zip）、compress（UNIX系统的标准压缩）、deflate（zlib）、identity（不进行编码）</p>
<h4 id="分隔发送的分块传输编码"><a href="#分隔发送的分块传输编码" class="headerlink" title="分隔发送的分块传输编码"></a>分隔发送的分块传输编码</h4><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。<br>这种把实体主体分块的功能称为<strong>分块传输编码</strong>（Chunked Transfer Coding）。</p>
<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）”来标记。</p>
<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。</p>
<h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常实在图片或文本文件等上传时使用。</p>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>下载大尺寸的图片的过程中，如果网络中断，则需要重新下载。因此需要一种可恢复的机制。<br>实现该功能需要指定下载的实体范围，像这样，指定范围发送的请求叫做<strong>范围请求</strong>。<br>执行范围请求时，会用到首部字段Range来指定资源的byte范围。响应会返回状态码206 Partial Content。</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p>
<h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>
<h2 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。<br>状态码如200 OK，以3为数字和原因短语组成。<br>数字中的第一位定义了响应类别，后两位无分类。响应类别有以下五种：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational(信息性状态码)</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>只要遵守状态码类别的定义，即使改变 <a href="https://datatracker.ietf.org/doc/rfc2616/" target="_blank" rel="external">RFC2616</a> 中定义的状态码，或服务器端自行创建状态码都没问题。</p>
<h3 id="常用的状态码14种："><a href="#常用的状态码14种：" class="headerlink" title="常用的状态码14种："></a>常用的状态码14种：</h3><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul>
<li>200 OK：请求被正常处理</li>
<li>204 No Content：一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li>
<li>206 Partial Content：客户端进行范围请求</li>
</ul>
<h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul>
<li>301 Moved Permanently：永久重定向。表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。<br>也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</li>
<li>302 Found：临时性重定向。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。<br>和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI（在Chrome中，还是会保存为重定向后的URI，不解）。</li>
<li>303 See Other：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。这与302类似，但303明确表示客户端应当采用GET方法获取资源。</li>
<li>304 Not Modified：该状态码表示客户端发送附带条件的请求（指采用GET方法的请求报文中包含If-Match,If-Modified-Since，If-None-March，If-Range，If-Unmodified-Since中任一首部。）时，服务器端允许请求访问资源，但因发生请求为满足条件的情况后，直接返回304（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。<br>304虽被划分在3XX类别，但是和重定向没有关系。</li>
<li>307 Temporary Redirect：临时重定向。与302有相同含义。307遵守浏览器标准，不会从POST变成GET。</li>
</ul>
<blockquote>
<p>就算是304，也需要发出请求与接收响应，也会耗费资源和时间。</p>
</blockquote>
<h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><p>4XX的响应结果表明客户端是发生错误的原因所在。</p>
<ul>
<li>400 Bad Request：表示请求报文中存在语法错误。</li>
<li>401 Unauthorized：表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</li>
<li>403 Forbidden：表明对请求资源的访问被服务器拒绝了。服务器端可在实体的主体部分对原因进行描述（可选）</li>
<li>404 Not Found：表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时时用。</li>
</ul>
<h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><p>5XX的响应结果表明服务器本身发生错误。</p>
<ul>
<li>500 Interval Server Error：表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</li>
<li>503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</li>
</ul>
<h2 id="第五章-与HTTP协作的Web服务器"><a href="#第五章-与HTTP协作的Web服务器" class="headerlink" title="第五章 与HTTP协作的Web服务器"></a>第五章 与HTTP协作的Web服务器</h2><h3 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h3><p>HTTP/1.1 规范允许一台HTTP服务器搭建多个Web站点。这是利用虚拟主机（Virtual Host，又称虚拟服务器）的功能。</p>
<p>在互联网上，域名通过DNS服务映射到IP地址之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址形式访问了。所以，当一台托管了两个域名的服务器接收到请求时就需要弄清楚究竟要访问哪个域名。<br>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p>
<h3 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h3><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关、隧道。它们可以配合服务器工作。</p>
<ul>
<li>代理：是一种有转发功能的应用程序，扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</li>
<li>网关：是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。</li>
<li>隧道：是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</li>
</ul>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理不改变请求URI，会直接发送给前方持有资源的目标服务器。<br>持有资源实体的服务器被称为源服务器。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-68.jpg" alt="&gt; P68"><br>例如：<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-%E4%BB%A3%E7%90%86.png" alt="&gt; 淘宝的via"></p>
<p>每次通过代理服务器转发请求或响应式，会追加写入via首部信息。</p>
<p>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p>
<p>代理有多种使用方法，按两种基准分类。一种是是否是否使用缓存，另一种是是否会修改报文。</p>
<ul>
<li>代理缓存：代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供<strong>非HTTP协议服务</strong>。<br>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端与服务器进行安全的通信。</p>
<p>隧道本身不会去解析HTTP请求。请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<h3 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，节省通信流量和时间。</p>
<p>缓存服务器是代理服务器的一种。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。</p>
<p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h4><p>对于缓存服务器和客户端浏览器，当判定缓存过期或客户端要求，会向源服务器确认资源的有效性。若失效，浏览器会再次请求新资源。</p>
<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><p>HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器端分别处理请求和响应提供所需要的信息。</p>
<p>HTTP请求报文：由方法、URI、HTTP版本、HTTP首部字段等构成。<br>HTTP响应报文：由HTTP版本、状态码（数字和原因短语）、HTTP首部字段 3 部分组成。</p>
<h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h4 id="4种HTTP首部字段类型"><a href="#4种HTTP首部字段类型" class="headerlink" title="4种HTTP首部字段类型"></a>4种HTTP首部字段类型</h4><p>HTTP首部字段根据实际通途被分为以下4种类型：</p>
<ul>
<li>通用首部字段（General Header Fileds）：请求报文和响应报文两方都会使用的首部</li>
<li>请求首都字段（Request Header Fields）：从客服端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>
<li>响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>
<li>实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li>
</ul>
<h4 id="HTTP-1-1首部字段一览"><a href="#HTTP-1-1首部字段一览" class="headerlink" title="HTTP/1.1首部字段一览"></a>HTTP/1.1首部字段一览</h4><p>通用首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
<p>Cache-Control的no-cache指令代表不缓存过期的资源，而不是不缓存。no-store才是真正不进行缓存。<br>Connection首部字段的值为close时，代表服务器想明确断开连接（HTTP/1.1默认都是持久连接）</p>
<p>请求首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-Node-Match</td>
<td>比较实体标记（与If-Match相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体Byte的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中URI的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP客户端程序的信息</td>
</tr>
</tbody>
</table>
<p>该表的Accept*字段都可以指定权重q（0-1）。当服务器提供多种内容时，将会首先返回权重最高的。<br>If-xxx请求首部字段都称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才回执行请求。<br>Referer 的正确拼写应该是Referrer。当直接在浏览器的地址栏输入URI时，或处于安全考虑时，可不发该首部字段。</p>
<p>响应首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<p>几乎所有浏览器在接收到包含首部字段Location的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<p>实体首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<p>为Cookie服务的首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody>
</table>
<p>Set-Cookie字段的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td>赋予Cookie的名称和其值（必需项）</td>
</tr>
<tr>
<td>expires=DATE</td>
<td>Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=Path</td>
<td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td>作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在HTTPS安全通信时才会发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使Cookie不能被JavaSript脚本访问</td>
</tr>
</tbody>
</table>
<p>expires：一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显示删除Cookie的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除操作。<br>path：用来指定cookie被发送到服务器的哪一个目录路径下（即被服务器哪个路径接收cookie），其中”/“指的是站点根目录，可在同一台服务器（即使有多个应用）内共享该cookie。</p>
<h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="HTTP的确定"><a href="#HTTP的确定" class="headerlink" title="HTTP的确定"></a>HTTP的确定</h3><ul>
<li>通信使用明文可能会被窃听</li>
<li>不验证通信方的身份就可能遭受伪装</li>
<li>无法验证报文完整性，可能已遭篡改</li>
</ul>
<h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护 = HTTPS"></a>HTTP+加密+认证+完整性保护 = HTTPS</h3><h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><p>核对的信息通常是指以下这些：</p>
<ul>
<li>密码：只有本人才会知道的字符串信息</li>
<li>动态令牌：仅限本人持有的设备内显示的一次性密码</li>
<li>数字证书：仅限本人（终端）持有的信息</li>
<li>生物认证：指纹和虹膜等本人的生理信息</li>
<li>IC卡等：仅限本人持有的信息</li>
</ul>
<p>HTTP/1.1 使用的认证方式如下所示：</p>
<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST 认证（摘要认证）w</li>
<li>SSL 客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
<h2 id="第九章-基于HTTP的功能追加协议"><a href="#第九章-基于HTTP的功能追加协议" class="headerlink" title="第九章 基于HTTP的功能追加协议"></a>第九章 基于HTTP的功能追加协议</h2><h3 id="HTTP的瓶颈"><a href="#HTTP的瓶颈" class="headerlink" title="HTTP的瓶颈"></a>HTTP的瓶颈</h3><p>使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。<br>若想在现有Web实现所需的功能，一下这些HTTP标准就会成为瓶颈：</p>
<ul>
<li>一条连接上只可发送一个请求（前面讲到，持久化可保持TCP连接状态，但仍完成一次请求/响应后才能进行下一次请求/响应，而管线化方式可让一个TCP连接并行发送多个请求。）</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令</li>
<li>请求/响应首部未经压缩就发送。首部信息越多延迟越大</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li>
<li>可任意选择数据压缩格式。非强制压缩发送</li>
</ul>
<h4 id="Comet-的解决方法"><a href="#Comet-的解决方法" class="headerlink" title="Comet 的解决方法"></a>Comet 的解决方法</h4><p>通常，服务器接收到请求，在处理完毕后就立即返回响应，但为了实现推送功能，Comet会先将响应置于<strong>挂起状态</strong>，当服务器端有内容更新时，再返回该响应。<br>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet仍未解决HTTP协议的本身存在的问题。</p>
<h4 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h4><p>Google 在2010年发布了 SPDY，其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间。<br>SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-184.jpg" alt="&gt; P184"></p>
<p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。</p>
<p>使用 SPDY后，HTTP协议额外获得以下功能。</p>
<ul>
<li>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。</li>
<li>赋予请求优先级：SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li>
<li>压缩HTTP首部：压缩HTTP请求和响应的首部。</li>
<li>推送功能：支持服务器主动向客户端推送数据的功能。</li>
<li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</li>
</ul>
<h3 id="使用浏览器进行全双工通信的-WebSocket"><a href="#使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="使用浏览器进行全双工通信的 WebSocket"></a>使用浏览器进行全双工通信的 WebSocket</h3><p>利用Ajax和Comet技术进行通信可以提升Web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。</p>
<p>WebSocket技术主要是为了解决Ajax和Comet里XMLHttpRequst附带的缺陷所引起的问题。</p>
<p>一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。</p>
<p>WebSocket的主要特点：</p>
<ul>
<li>推送功能：支持由服务器向客户端推送数据。</li>
<li>减少通信量：和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应较少。</li>
</ul>
<p>为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”的步骤。</p>
<ul>
<li>握手·请求：为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手的目的。</li>
<li>握手·响应：对于之前的请求，返回状态码101 Switching Protocols 的响应。</li>
</ul>
<p>成功握手确立WebSocket连接后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。</p>
<p><strong>由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端</strong>，而一旦确立WebSocket通信连接，不论服务器端还是客户端，任意一方都可直接向对方发送报文。</p>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><p><a href="https://github.com/fex-team/http2-spec/blob/master/HTTP2%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88%2806-29%29.md" target="_blank" rel="external">HTTP2中英对照版</a><br><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="external">HTTP/2.0 相比1.0有哪些重大改进？</a></p>
<h2 id="第十一章-Web攻击技术"><a href="#第十一章-Web攻击技术" class="headerlink" title="第十一章 Web攻击技术"></a>第十一章 Web攻击技术</h2><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击目标。</p>
<p>HTTP不具备必要的安全功能，就拿远程登录时会用到的SSH协议来说，SSH具备协议级别的认证及会话管理等功能，HTTP协议则没有。另外在架设SSH服务方面，任何人都可以轻易地创建安全等级高的服务。而HTTP即使已假设好服务器，但开发者需要自行设计并开发认证及会话管理功能来满足Web应用的安全。而自行设计就意味着会出现各种形形色色的实现，可仍在运作的Web应用背后就会隐藏着各种容易被攻击者滥用的安全漏洞的Bug。</p>
<h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><ul>
<li>跨站脚本攻击（Cross-Site Scripting, XSS）：主要是指在用户浏览器内运行了非法的 HTML 标签或 JavaScript 脚本。比如富文本编辑器，如果不过滤用户输入的数据直接显示用户输入的HTML内容的话，就会有可能运行恶意的 JavaScript 脚本，导致页面结构错乱，Cookies 信息被窃取等问题。</li>
<li>SQL注入攻击（SQL Injection）：是指针对 Web 应用使用的数据库，通过运行非法的SQL而产生的攻击。</li>
<li>OS命令攻击（OS Command Injection）：是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。 只要在能调用 Shell 函数的地方就有存在被攻击的风险。</li>
<li>HTTP首部注入攻击（HTTP Header Injection）：是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。</li>
<li>HTTP 响应截断攻击：是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后 发送。利用两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样 就能显示伪造的主体，达到攻击的目的。</li>
<li>邮件首部注入攻击（Mail Header Injection）：是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或 病毒邮件。</li>
<li>目录遍历攻击（Directory Traversal）：是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。比如，通过 ../ 等相对路径定位到 /etc/passwd 等绝对路径上。</li>
<li>远程文件包含漏洞（Remote File Inclusion）： 是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。</li>
</ul>
<h3 id="因设置或设计上的缺陷引发的安全漏洞"><a href="#因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="因设置或设计上的缺陷引发的安全漏洞"></a>因设置或设计上的缺陷引发的安全漏洞</h3><ul>
<li>强制浏览（Forced Browsing）：是指，从安置在Web服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。比如，没有对那些需要保护的静态资源增加权限控制。</li>
<li>不正确的错误消息处理（Error Handling Vulerability）：指Web应用的错误信息内包含对攻击者有用 的信息。</li>
<li>开放重定向（Open Redirect）：是一种对指定的任意URL作重定向跳转的功能。而于此功能相关联的安全漏洞是指， 假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。</li>
</ul>
<h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="headerlink" title="因会话管理疏忽引发的安全漏洞"></a>因会话管理疏忽引发的安全漏洞</h3><ul>
<li>会话劫持（Session Hijiack）：是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</li>
<li>会话固定攻击（Session Fixation）：对以窃取目标会话ID为主动攻击手段的会话劫持而言，会强制用户使用攻击者指定的会话 ID，属于被动攻击。</li>
<li>跨站点请求伪造（Cross-Site Request Forgeries, CSRF）：是指攻击者通过设置好陷阱，强制对已完成认证的用户进行非预期的个人信息或设定等某些状态更新，属于被动攻击。</li>
</ul>
<h3 id="其它安全漏洞"><a href="#其它安全漏洞" class="headerlink" title="其它安全漏洞"></a>其它安全漏洞</h3><ul>
<li>密码破解：①通过网络进行密码试错（穷举法和字典攻击）；②对已加密密码的破解（通过穷举法·字典攻击进行类推、彩虹表、拿到加密时使用的密钥、加密算法的漏洞）</li>
<li>点击劫持：是指利用透明的按钮或链接做成陷阱，覆盖在Web页面之上。然后诱使用户在不知情的情况下， 单击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</li>
<li>Dos攻击：是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。多台计算机发起的 Dos 攻击称为 DDoS 攻击（Distributed Denial of Service attach） 。</li>
<li>后门程序：是指开发设置的隐藏入口（如开发阶段作为Debug调用的后门程序），可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限的功能。</li>
</ul>
<h2 id="自问自答："><a href="#自问自答：" class="headerlink" title="自问自答："></a>自问自答：</h2><ol>
<li>URI与URL的区别<br>答：URI 用字符串（包括地址）标识某一个互联网资源，而URL表示资源的地点。因此URL是URI的子集。</li>
<li>输入URL后，浏览器发生哪些变化<br>下图需要补充：在从DNS服务器获取IP后，进行3次握手。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-15.jpg" alt="P15 + 三次握手"><br>从服务器获取相应资源后，浏览器就会对这些资源进行相应的解析，具体可看<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model" target="_blank" rel="external">Google Developers</a>。</li>
<li>GET与POST的区别<br>可以看看这篇文章 <a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">浅谈HTTP中Get与Post的区别</a>。我个人认为主要的一点是：<strong>URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。</strong><br>关于URL和queryString长度限制的相关链接：<ul>
<li><a href="http://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers/417184" target="_blank" rel="external">What is the maximum length of a URL in different browsers?</a></li>
<li><a href="http://stackoverflow.com/questions/812925/what-is-the-maximum-possible-length-of-a-query-string" target="_blank" rel="external">What is the maximum possible length of a query string?</a><br>因此对于GET请求时，URL超出浏览器或者服务器限制的情况，建议改成POST请求。</li>
</ul>
</li>
<li>301与302区别<br>答：301是永久性重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。<br>302是临时性重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li>
<li>为什么三次握手，二次不可以吗？<br>答：不可以，只有完成3次才能进行后续操作，若在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包。而且，第三次握手是客户端为了让服务器知道它是否接收到响应，确保连接建立成功。</li>
<li>为什么有时候下载高清大图时，图片会一块一块地加载。<br>答：这就是因为设置了http请求的长度，这样就可以分块的加载资源文件。<br>　　在请求报文中使用Range属性，在响应报文中使用Content-Type属性都可以指定一定字节范围的http请求。</li>
</ol>
<p>“自问自答”仅是我个人的理解，如果你有不同的观点，可以一起讨论。当然，如果你有认为不错的问答，可以联系我，我会不断完善。</p>
<hr>
<p>Github地址：<a href="https://github.com/JChehe/blog/blob/master/posts/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md" target="_blank" rel="external">《图解HTTP》读书笔记</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;p&gt;HTTP（HyperText Transfer Protocol，超文转移协议，超文本传输协议的译法并不严谨。）&lt;/p&gt;
&lt;h3 id=&quot;网络基础-TCP-IP&quot;&gt;&lt;a href=&quot;#网络基础-TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;网络基础 TCP/IP&quot;&gt;&lt;/a&gt;网络基础 TCP/IP&lt;/h3&gt;&lt;h4 id=&quot;TCP-IP-协议族&quot;&gt;&lt;a href=&quot;#TCP-IP-协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP 协议族&quot;&gt;&lt;/a&gt;TCP/IP 协议族&lt;/h4&gt;&lt;p&gt;TCP/IP 协议族是互联网相关联的协议的集合。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等。而HTTP是属于它内部的一个子集。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>jQuery 的 attr 与 prop 的区别</title>
    <link href="http://yoursite.com/2016/03/08/2016-3-8-attr-and-prop/"/>
    <id>http://yoursite.com/2016/03/08/2016-3-8-attr-and-prop/</id>
    <published>2016-03-08T06:47:42.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>先提出问题：对于 checked 这类值是 true/false 的属性，用 jQuery 的 attr 或 prop 方法进行 读取或设置值是有区别的。</p>
<p>在看 jQuery 文档前，我们先看看 attribute 与 property 是什么：</p>
<a id="more"></a>
<h3 id="先搞懂-attribute-与-property"><a href="#先搞懂-attribute-与-property" class="headerlink" title="先搞懂 attribute 与 property"></a>先搞懂 attribute 与 property</h3><p>当编写 HTML 源码时，你能在 HTML 元素里定义 attributes。然后，一旦浏览器解析你的代码，该 HTML 元素相应的 DOM 节点就会被创建。该节点是一个对象，因此它就拥有 properties。<br>因此，我们知道：attributes 是 HTML 元素（标签）的属性，而 properties 是 DOM 对象的属性。</p>
<p>例如，下面这个 HTML 元素：</p>
<pre><code>&lt;input type=&quot;text&quot; value=&quot;Name:&quot;&gt;
</code></pre><p>拥有两个 attributes。</p>
<p>一旦浏览器解析该代码，HTMLInputElement 对象就会被创建，并且该对象会拥有很多 peoperties，如：accept、accessKey、align、alt、attributes、autofocus、baseURI、checked、childElementCount、ChildNodes、children、classList、className、clientHeight 等等。</p>
<p>对于某个 DOM 节点对象，properties 是该对象的所有属性，而 attributes 是该对象对应元素(标签)的属性。</p>
<p>当一个 DOM 节点为某个 HTML 元素所创建时，其大多数 properties 与对应 attributes 拥有相同或相近的名字，但这并不是一对一的关系。例如，下面这个 HTML 元素：</p>
<pre><code>&lt;input id=&quot;the-input&quot; type=&quot;text&quot; value=&quot;Name:&quot;&gt;
</code></pre><p>其对应 DOM 节点会拥有如下properties： id、type 和 value：</p>
<ul>
<li><code>id</code> property是 <code>id</code> attribute 的映射：获取该 property 即等于读取其对应的 attribute 值，而设置该 property 即为 attribute 赋值。<code>id</code> 是一个纯粹的映射 property，它不会修改或限制其值。</li>
<li><code>type</code> property 是 <code>type</code> attribute 的映射：获取该 property 即等于读取其对应的 attribute 值，而设置该 property 即为 attribute 赋值。但 <code>type</code> 并不是一个纯粹的映射 property，因为它的值被限制在已知值（即 input 的合法类型，如：text、password）。如果你有 <code>&lt;input type=&quot;foo&quot;&gt;</code>，然后 <code>theInput.getAttribute(&quot;type&quot;)</code> 会返回 <code>&quot;foo&quot;</code>，而 <code>theInput.type</code> 会返回 <code>&quot;text&quot;</code>。</li>
<li><p>相比之下，<code>value</code> property 并不会映射 <code>value</code> attribute。取而代之的是 input 的当前值。当用户手动更改输入框的值，<code>value</code> property 会反映该改变。所以，如果用户在 input 输入 <code>John</code>，然后：</p>
<p> theInput.value // 返回 “John”<br>然而：<br> theInput.getAttribute(‘value’) // 返回 “Name:”</p>
</li>
</ul>
<p><code>value</code> property 反映了 input 的<strong>当前</strong>文本内容，而 <code>value</code> attribute 则是在 HTML 源码 value 属性所指定的<strong>初始</strong>文本内容。</p>
<p>因此，如果你想知道文本框的当前值，则读取 property。而如果你想知道文本框的初始值，则读取 attribute。或者你也可以利用 defaultValue property，它是 value attribute 的纯粹映射。</p>
<pre><code>theInput.value                 // returns &quot;John&quot;
theInput.getAttribute(&apos;value&apos;) // returns &quot;Name:&quot;
theInput.defaultValue          // returns &quot;Name:&quot;
</code></pre><p>有几个 properties 是直接反映它们 attribute（rel、id），而有一些则用稍微不同的名字进行直接映射（<code>htmlFor</code> 映射 <code>for</code> attribute，<code>className</code> 映射 <code>class</code> attribute）。很多 property 所映射的 attribute 是带有限制/变动的（src、href、disabled、multiple）。该 <a href="https://www.w3.org/TR/html5/infrastructure.html#reflect" target="_blank" rel="external">规范</a> 涵盖了各种各样的映射。</p>
<h3 id="再看看-attr-与-prop-的区别"><a href="#再看看-attr-与-prop-的区别" class="headerlink" title="再看看 attr() 与 prop() 的区别"></a>再看看 attr() 与 prop() 的区别</h3><p>上述能让我们理清了 attribute 与 property 之间的区别，下面根据 <a href="http://api.jquery.com/prop/" target="_blank" rel="external">jQuery 文档</a> 对 attr() 与 prop() 方法进行比较：</p>
<p>自 jQuery 1.6 版本起，<code>attr()</code> 方法对于未设置的 attributes （即标签中没写该 attributes）都会返回 <code>undefined</code>。对于检索和改变 DOM 的 properties，如表单元素的 checked、selected 或 disabled 状态，应使用 <code>.prop()</code> 方法。</p>
<p>Attributes vs. Properties</p>
<p>attributes 与 properties 之间的差异在特定情况下会变得尤为重要。在 jQuery 1.6 前，<code>.attr()</code> 方法在检索一些 attributes 时，有时会把 property 考虑进去，这会导致不一致的行为。在 jQuery 1.6 版本之后，<code>.prop()</code> 方法提供了一种明确检索 property 值的方式，而 <code>.attr</code> 只会检索 attributes。</p>
<p>例如，selectedIndex、tagName、nodeName、nodeType、ownerDocument、defaultChecked 和 defaultSelected 能被 <code>.prop()</code> 检索与设置。在 jQuery 1.6 之前，这些 properties 都是通过 <code>.attr()</code> 检索的，但检索这些属性并不应属于 attr 方法职责内 。这些属性并没有对应的 attributes，只有 properties 本身。</p>
<p>对于值为布尔值的 attributes ，考虑到一个 DOM 元素是通过 HTML 标签 <code>&lt;input type=&quot;checkbox&quot; checked=&quot;checked /&gt;</code> 定义的，并且假定它在 JavaScript 的变量名为 <code>elem</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">读取属性</th>
<th style="text-align:left">返回值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">elem.checked</td>
<td style="text-align:left">true (Boolean)</td>
<td style="text-align:left">会随着 checkbox 状态作出相应改变</td>
</tr>
<tr>
<td style="text-align:left">$(elem).prop(“checked”)</td>
<td style="text-align:left">true (Boolean)</td>
<td style="text-align:left">会随着 checkbox 状态作出相应改变</td>
</tr>
<tr>
<td style="text-align:left">elem.getAttribute(“checked”)</td>
<td style="text-align:left">“checked” (String)</td>
<td style="text-align:left">checkbox 的初始状态；并且不会随着 checkbox 的状态而改变。</td>
</tr>
<tr>
<td style="text-align:left">$(elem).attr(“checked”) (1.6)</td>
<td style="text-align:left">“checked” (String)</td>
<td style="text-align:left">checkbox 的初始状态；并且不会随着 checkbox 的状态而改变。</td>
</tr>
<tr>
<td style="text-align:left">$(elem).attr(“checked”) (1.6.1+)</td>
<td style="text-align:left">“checked” (String)</td>
<td style="text-align:left"><del>会随着 checkbox 状态而作出相应改变</del>（与jQuery文档描述不一样，我用jQuery 1.12.1 测试，都是返回 “checked”，并不会随着checkbox的改变而改变）。</td>
</tr>
<tr>
<td style="text-align:left">$(elem).attr(“checked”) (1.6之前版本)</td>
<td style="text-align:left">true (Boolean)</td>
<td style="text-align:left">true (Boolean) 会随着 checkbox 状态作出相应改变。</td>
</tr>
</tbody>
</table>
<p>根据 W3C forms（表单） 规范，<code>checked</code> 是一个值为 boolean 的 attribute，这意味着当该 attribute 存在（无论值是什么），其对应的 property 都是 true。例如，该 attribute 没赋值或设为空字符串，甚至设为 <code>&quot;false&quot;</code>。这同样适用于所有值为 boolean 的 attributes。</p>
<p>然而，对于 <code>checked</code> attribute 最重要的概念是记住它并不是对应 <code>checked</code> property。该 attribute 实际上是对应 <code>defaultChecked</code> property，并仅在初次设置 checkbox 值时使用。<code>checked</code> attribute 的值并不会随着 checkbox 的状态而作出相应改变，而 <code>checked</code> property 会。因此，为了兼容不同浏览器，当判断一个 checkbox 是否被选择时应该使用 <code>property</code>：</p>
<pre><code>if (elem.checked)
if ($(elem).prop(&quot;checked&quot;))
if ($(elem).is(&quot;:checked&quot;))
</code></pre><p>这同样适用于其它动态 attributes，如 selected 和 value。</p>
<p>其他说明：<br>在 IE9 之前的版本，如果使用 <code>.prop()</code> 为 DOM 元素的 property 设置的值不是一个简单的原始值（number、string 或 boolean），且该 property 在 DOM 元素从 document 移除前未被移除（使用 .removeProp()），则会导致内存泄漏。为 DOM 对象设置值的安全做法（避免内存泄漏）是使用  <code>.data()</code>。</p>
<p>参考（翻译）：<br>jQuery API Documentation：<a href="http://api.jquery.com/prop/" target="_blank" rel="external">http://api.jquery.com/prop/</a><br>Properties and Attributrs in HTML：<a href="http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html" target="_blank" rel="external">http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html</a></p>
<hr>
<p>Github 地址: <a href="https://github.com/JChehe/blog/blob/master/posts/jQuery%20%E7%9A%84%20attr%20%E4%B8%8E%20prop%20%E7%9A%84%E5%8C%BA%E5%88%AB.md" target="_blank" rel="external">jQuery 的 attr 与 prop 的区别</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先提出问题：对于 checked 这类值是 true/false 的属性，用 jQuery 的 attr 或 prop 方法进行 读取或设置值是有区别的。&lt;/p&gt;
&lt;p&gt;在看 jQuery 文档前，我们先看看 attribute 与 property 是什么：&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 模块【Part 2】：模块打包</title>
    <link href="http://yoursite.com/2016/03/01/2016-2-30-javascript-modules-part-2-module-bundling/"/>
    <id>http://yoursite.com/2016/03/01/2016-2-30-javascript-modules-part-2-module-bundling/</id>
    <published>2016-03-01T03:32:56.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*e0eQH_9X8jN7yC6AEqlvdQ.jpeg" alt="此处输入图片的描述"></p>
<p>在文章的 <a href="https://github.com/JChehe/blog/blob/master/translation/JavaScript%20%E6%A8%A1%E5%9D%97%E3%80%90Part%201%E3%80%91%EF%BC%9A%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97.md" target="_blank" rel="external">Part 1</a>，我讲解了模块是什么、为何要使用模块和为程序整合为模块的各种方式。而在 Part 2，我将会详细讲解模块“打包”：为什么要打包模块，以不同的方式进行打包和模块在 web 开发上的未来。</p>
<a id="more"></a>
<h2 id="什么是模块打包？"><a href="#什么是模块打包？" class="headerlink" title="什么是模块打包？"></a>什么是模块打包？</h2><p>总体上看，模块打包只是简单地将一组模块（和它们所依赖的模块）以正确的顺序整合为单一文件（或文件组）。我们也知道：对于 web 开发，细节才是可怕的地方。 :）。</p>
<h2 id="究竟为什么需要打包模块？"><a href="#究竟为什么需要打包模块？" class="headerlink" title="究竟为什么需要打包模块？"></a>究竟为什么需要打包模块？</h2><p>当你将程序分为各个模块时，通常会将这些模块放到不同文件或文件夹下。当然，你所使用的库（如 Underscore 或 React）也是模块。</p>
<p>因此，每个文件都必须以一个 <code>&lt;script&gt;</code> 标签引入到主 HTML 文件中。然后当用户访问你的主页时，浏览器就会加载这些文件。分离的 <code>&lt;script&gt;</code> 标签就意味着浏览器必须单独地加载每个文件（一个接一个）。</p>
<p>…这无疑是页面加载时间的噩耗。</p>
<p>为了解决该问题，我们需要打包或“拼接”所有文件，从而生成一个大文件（或几个文件，视情况而定）以减少请求数量。当你听到开发者讨论“构建步骤”或“构建处理”时，这大概就是他们所讨论的内容了。</p>
<p>另一个加快打包操作的普遍做法是：“压缩”打包的代码。压缩就是从源代码中移除不必要的字符（如空格、注释和换行符等），这样能减少内容的整体大小且不会改变代码的功能。</p>
<p>更少的数据就意味着浏览器处理的时间更短，而且反过来也减少了下载文件的时间。如果你曾看到文件拥有扩展名“min”（如 <a href="https://github.com/jashkenas/underscore/blob/master/underscore-min.js" target="_blank" rel="external">underscore-min.js</a>），你应该会注意到压缩版本会比 <a href="https://github.com/jashkenas/underscore/blob/master/underscore.js" target="_blank" rel="external">完整版</a> 小很多（当然，无可读性可言）。</p>
<p>构建工具（如 Gulp 和 Grunt）能为开发者直接执行拼接（concatenation）和压缩（minification）操作，并确保在打包生成利于浏览器执行的代码的同时，也会导出一份开发者可读的代码。</p>
<h2 id="打包模块的不同方式是什么？"><a href="#打包模块的不同方式是什么？" class="headerlink" title="打包模块的不同方式是什么？"></a>打包模块的不同方式是什么？</h2><p>当使用标准的模块模式（module pattern，在文章的前一节中所讨论的）定义模块时，拼接和压缩文件都能很好运行。你实际所做的是将各个原生 JavaScript 代码混合在一起。</p>
<p>然而，如果你使用的是非原生的模块系统，如 CommonJS 或 AMD（甚至是原生的 ES6 模块格式，因为浏览器仍不支持该语法），浏览器就不能解析识别了。此时你需要使用特定工具将模块转为顺序正确且对浏览器友好的代码。这些工具可以是 Browserify、RequireJS、Webpack 或其它“模块打包工具”或“模块加载器”。</p>
<p>除了打包和（或）加载模块，模块打包工具也提供了很多额外功能，如自动重编译（当你对代码作出修改或为了调试而生成 source maps 时）。</p>
<p>下面是一些常见的模块打包方法：</p>
<h2 id="打包-CommonJS"><a href="#打包-CommonJS" class="headerlink" title="打包 CommonJS"></a>打包 CommonJS</h2><p>正如你从 <a href="https://github.com/JChehe/blog/blob/master/translation/JavaScript%20%E6%A8%A1%E5%9D%97%E3%80%90Part%201%E3%80%91%EF%BC%9A%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97.md" target="_blank" rel="external">Part 1</a> 可知，CommonJS 是同步加载模块的，但这对于浏览器来说并不切合实际。我在 Part 1 提到了一种解决方案 —— 其中一种是模块打包工具 Browserify。Browserify 是一种将 CommonJS 模块编译成浏览器能执行的代码的工具。</p>
<p>举个例子，main.js 文件导入一个用于计算 <code>number数组</code> 平均数的模块：</p>
<pre><code>var myDependency = require(‘myDependency’);

var myGrades = [93, 95, 88, 0, 91];

var myAverageGrade = myDependency.average(myGrades);
</code></pre><p>因此，main.js 文件有一个依赖项（myDependency）。当使用以下命令时，Browserify 会递归打包所有由 main.js 文件开始引入的模块，到一个名为 bundle.js 的文件：</p>
<pre><code>browserify main.js -o bundle.js
</code></pre><p>Browserify 要实现以上功能，它要解析 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树（AST）</a> 的每个 <code>require</code> 调用，以遍历项目的整个依赖图。一旦它解决了依赖的构造关系，就能将模块以正确的顺序打包进一个单独文件内。然后，在 html 里插入一个用于引入 <code>“bundle.js”</code> 的 <code>&lt;script&gt;</code> 标签，从而确保你的源代码在一个 HTTP 请求中完成下载。</p>
<p>同样地，如果多个文件拥有多个依赖，你只需简单地告诉 Browserify 你的入口文件（entry file），然后休息一会等待它完成魔法即可。</p>
<p>最终产品：打包文件需要通过 Minify-JS 之类的工具压缩打包后的代码。</p>
<h2 id="打包-AMD"><a href="#打包-AMD" class="headerlink" title="打包 AMD"></a>打包 AMD</h2><p>如果你使用的是 AMD，你需要使用 AMD 加载器，如 RequireJS 或 Curl。一个模块加载器（与打包工具不同）会动态加载程序需要运行的模块。</p>
<p>再次提醒，AMD 与 CommonJS 的主要区别是：AMD 以异步的方式加载模块。也就是说， 对于 AMD，你实际上不需要将模块打包到一个文件的这个构建步骤，因为它是以异步方式加载模块——也就意味着当用户第一次访问网页时，浏览器会循序渐进地下载程序实际需要执行的文件，而不是一次性下载所有文件。</p>
<p>然而，在实际生产环境中，随着用户操作，大容量的请求开销并不会产生多大意义。但大多数开发者为了优化性能，仍然使用构建工具（如 RequireJS 优化工具和 <a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="external">r.js</a>）打包和压缩它们的 AMD 模块。</p>
<p>总的来说，AMD 与 CommonJS 之间的打包差异是：在开发期间，AMD 应用无须任何构建步骤即可运行。当然，在代码上线前，要使用优化工具（如 r.js）进行优化。</p>
<p>想了解更多关于 CommonJS vs. AMD 的有趣讨论，可看看 <a href="http://tomdale.net/2012/01/amd-is-not-the-answer/" target="_blank" rel="external">Tom Dale’s blog</a> 的这篇文章 : )。</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>就打包工具而言，Webpack 是这方面的新生儿。它与你所使用的具体模块系统无关，也就是说它允许开发者使用 CommonJS、AMD 或 ES6。</p>
<p>你可能会疑惑：我们已经有其它打包工具（如 Browserify 和 RequireJS）完成相应工作并做得相当好了，为什么还需要 Webpack。没错，Webpack 提供了一些有用的功能，如“代码分割（code splitting）”——一种将代码库分割为“块（chunks）”的方式，从而能实现按需加载。 </p>
<p>例如，如果 web 应用的某段代码块在某种环境下才被用到时，却直接将整个代码库放进一个庞大的打包文件，显然不那么高效。因此，你可使用“代码分割”，将其提取出来成为“打包块（bundled chunks）”，然后按需加载。对于大多数用户只需应用程序的核心部分这种情况，就避免了前期负荷过重的问题。</p>
<p>代码分割只是 Webpack 提供的众多引人注目的功能之一，网上有很多关于 “Webpack 与 Browserify 谁更好”的激烈讨论。下面列出了一些围绕该问题的、能理清思路的讨论：</p>
<ul>
<li><a href="https://gist.github.com/substack/68f8d502be42d5cd4942" target="_blank" rel="external">https://gist.github.com/substack/68f8d502be42d5cd4942</a></li>
<li><a href="http://mattdesl.svbtle.com/browserify-vs-webpack" target="_blank" rel="external">http://mattdesl.svbtle.com/browserify-vs-webpack</a></li>
<li><a href="http://blog.namangoel.com/browserify-vs-webpack-js-drama" target="_blank" rel="external">http://blog.namangoel.com/browserify-vs-webpack-js-drama</a></li>
</ul>
<h2 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h2><p>跟得上吧？很好！因为接下来要讲 ES6 模块，某种意义上它在未来能削弱对打包工具的需求。（你马上会明白我的意思。）首先，让我们知道 ES6 模块如何被加载。</p>
<p>当前的 JS 模块规范（CommonJS、AMD）与 ES6 模块之间最重要的区别是：设计 ES6 模块时考虑到了静态分析。其意思是：当你导入模块时，该导入在编译时（换言之，在脚本开始执行前。）已执行。这允许我们在运行程序前移除那些不被其它模块使用的导出模块（exports）。移除不被使用的模块能节省空间，且有效地减少浏览器的压力。</p>
<p>一个常被提起的问题是：使用 UglifyJS 之类的工具压缩代码后（即消除冗余代码 dead code elimination）会有何不同？答案是：“视情况而定”。</p>
<blockquote>
<p>（注意：消除冗余代码是一个优化步骤，它能移除无用的代码和变量——即移除打包程序不需要执行的冗余代码）。</p>
</blockquote>
<p>有时 UglifyJS 与 ES6 模块的消除冗余代码的工作完全相同，有时则不是。如果你想了解相关知识，可看看 <a href="https://github.com/rollup/rollup" target="_blank" rel="external">Rollup’s wiki</a> 的案例。</p>
<p>导致 ES6 模块不同的原因是它以不同方式去完成消除冗余代码的效果，我们称该方式为“tree shaking”。Tree shaking 本质与消除冗余代码相反。它仅包含打包文件需要运行的代码，而不是排除打包文件不需要的代码。让我们看看 tree shaking 的一个案例：</p>
<p>假设有一个带有多个函数的 utils.js 文件，每个函数都用 ES6 的语法导出：</p>
<pre><code>export function each(collection, iterator) {
  if (Array.isArray(collection)) {
    for (var i = 0; i &lt; collection.length; i++) {
      iterator(collection[i], i, collection);
    }
  } else {
    for (var key in collection) {
      iterator(collection[key], key, collection);
    }
  }
 }

export function filter(collection, test) {
  var filtered = [];
  each(collection, function(item) {
    if (test(item)) {
      filtered.push(item);
    }
  });
  return filtered;
}

export function map(collection, iterator) {
  var mapped = [];
  each(collection, function(value, key, collection) {
    mapped.push(iterator(value));
  });
  return mapped;
}

export function reduce(collection, iterator, accumulator) {
    var startingValueMissing = accumulator === undefined;

    each(collection, function(item) {
      if(startingValueMissing) {
        accumulator = item;
        startingValueMissing = false;
      } else {
        accumulator = iterator(accumulator, item);
      }
    });

    return accumulator;
}
</code></pre><p>接着，假设我们不知道程序需要 utils.js 里的哪些函数，所以直接将上述模块内的所有函数导入到 main.js，如下：</p>
<pre><code>import * as Utils from ‘./utils.js’;
</code></pre><p>最终我们只用到了 each 函数：</p>
<pre><code>import * as Utils from ‘./utils.js’;

Utils.each([1, 2, 3], function(x) { console.log(x) });
</code></pre><p>“tree shaken” 版本的 main.js 看起来如下（一旦模块被加载后）：</p>
<pre><code>function each(collection, iterator) {
  if (Array.isArray(collection)) {
    for (var i = 0; i &lt; collection.length; i++) {
      iterator(collection[i], i, collection);
    }
  } else {
    for (var key in collection) {
      iterator(collection[key], key, collection);
    }
  }
 };

each([1, 2, 3], function(x) { console.log(x) });
</code></pre><p>注意：只导出我们使用的 <code>each</code> 函数。</p>
<p>或者我们决定使用 filter 函数，而不是 each 函数，则最终看到的代码如下：</p>
<pre><code>import * as Utils from ‘./utils.js’;

Utils.filter([1, 2, 3], function(x) { return x === 2 });
</code></pre><p>tree shaken 版本如下：</p>
<pre><code>function each(collection, iterator) {
  if (Array.isArray(collection)) {
    for (var i = 0; i &lt; collection.length; i++) {
      iterator(collection[i], i, collection);
    }
  } else {
    for (var key in collection) {
      iterator(collection[key], key, collection);
    }
  }
 };

function filter(collection, test) {
  var filtered = [];
  each(collection, function(item) {
    if (test(item)) {
      filtered.push(item);
    }
  });
  return filtered;
};

filter([1, 2, 3], function(x) { return x === 2 });
</code></pre><p>此刻，<code>each</code> 和 <code>filter</code> 函数都被包含进来。这是因为 <code>filter</code> 在定义时使用了 <code>each</code>。因此也需要导出该函数模块以保证程序正常运行。</p>
<p>很聪明，对吧？</p>
<p>我要向你发起挑战，在 Rollup.js 的 <a href="http://rollupjs.org/" target="_blank" rel="external">线上案例与编辑器</a> 中探索 tree shaking 吧。</p>
<h2 id="构建-ES6-模块"><a href="#构建-ES6-模块" class="headerlink" title="构建 ES6 模块"></a>构建 ES6 模块</h2><p>现在我们知道加载 ES6 模块与其它模块规范是不同的，但我们还没讲使用 ES6 模块时的构建步骤。</p>
<p>不幸的是，由于浏览器到现在仍不支持加载原生 ES6 模块，如果现在要使用 ES6 模块则需要其它额外的工作。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*lpAgpggDLcK1a3MBEbmODg.png" alt="此处输入图片的描述"></p>
<p>下面有两个实现构建/转化 ES6 模块（以至浏览器能执行）的方法，第一个是现在最常用的方式：</p>
<ol>
<li>使用转译器（如 Babel 或 Traceur）以 CommonJS、AMD 或 UMD 其中一种规范将 ES6 代码转译为 ES5 代码。然后通过模块打包工具（如 Browserify 或 Webpack）将转译后的代码打包成一个或多个文件。</li>
<li>使用 <a href="http://rollupjs.org/" target="_blank" rel="external">Rollup.js</a>，这与前一个方式很相似，不同的是 Rollup 拥有 ES6 模块的静态分析代码（ES6 代码）与依赖的能力。它利用 “tree shaking” 让打包文件拥有最精简的代码。总言之，对于 ES6 模块，使用 Rollup.js （相较于 Browserify 或 Webpack）的最大好处是 tree shaking 能让打包文件更小。需要提醒你的是：Rollup 提供了几种打包代码的规范，包括 ES6、CommonJS、AMD、UMD 和 IIFE（立即调用函数表达式）。IIFE 和 UMD 的打包能直接在浏览器运行，但如果你选择打包 AMD、CommonJS 或 ES6 模块时，需要寻找能将代码转成浏览器能理解运行的代码的方法（例如，使用 Broserify、Webpack、RequireJS 等）。</li>
</ol>
<h2 id="跨越障碍"><a href="#跨越障碍" class="headerlink" title="跨越障碍"></a>跨越障碍</h2><p>作为 Web 开发者，我们不得不跨越很多障碍。例如，将优美的 ES6 模块转为浏览器能识别的代码并不总是一帆风顺。</p>
<p>问题是，ES6 模块什么时候才能脱离上述的代码构建开销呢？</p>
<p>答案是：“尽快”。</p>
<p>ECMAScript 目前有一个解决方案叫 <a href="https://github.com/ModuleLoader/es6-module-loader" target="_blank" rel="external">ECMAScript 6 module loader API</a>。简言之，这是一个纲领性的、基于 Promise 的 API，它支持动态加载模块并缓存模块，以便后续的导入不需要重新加载模块。</p>
<p>它看起来如下：</p>
<p><strong>myModule.js</strong></p>
<pre><code>export class myModule {
  constructor() {
    console.log(&apos;Hello, I am a module&apos;);
  }

  hello() {
    console.log(&apos;hello!&apos;);
  }

  goodbye() {
    console.log(&apos;goodbye!&apos;);
  }
}
</code></pre><p><strong>main.js</strong></p>
<pre><code>System.import(‘myModule’).then(function(myModule) {
  new myModule.hello();
});

// ‘hello!’
</code></pre><p>你亦可直接对 script 标签指定 “type=module” 来定义模块，如：</p>
<pre><code>&lt;script type=&quot;module&quot;&gt;
  // loads the &apos;myModule&apos; export from &apos;mymodule.js&apos;
  import { hello } from &apos;mymodule&apos;;

  new Hello(); // &apos;Hello, I am a module!&apos;
&lt;/script&gt;
</code></pre><p>如果你还没看过 the module API polyfill 的 repo，我强烈建议你 <a href="https://github.com/ModuleLoader/es6-module-loader" target="_blank" rel="external">看看</a>。 </p>
<p>此外，如果你想试试该方法，那就看看 <a href="https://github.com/systemjs/systemjs" target="_blank" rel="external">SystemJS</a>，它构建于 <a href="https://github.com/ModuleLoader/es6-module-loader" target="_blank" rel="external">ES6 Module Loader polyfill</a> 之上。SystemJS 能在浏览器和 Node 上动态加载任何模块规范（ES6 模块、AMD、CommonJS、全局脚本）。它在一个 “模块注册器（module registry）”上保存了所有已加载模块的路径，从而避免重新加载先前已加载的模块。更不用说它能自动转译 ES6 模块（只需简单配置）和拥有从任何类型模块中加载任何类型模块的能力了。</p>
<h2 id="有了原生的-ES6-模块后，还需要模块打包吗？"><a href="#有了原生的-ES6-模块后，还需要模块打包吗？" class="headerlink" title="有了原生的 ES6 模块后，还需要模块打包吗？"></a>有了原生的 ES6 模块后，还需要模块打包吗？</h2><p>对于日益普及的 ES6 模块，下面有一些有趣的观点：</p>
<h3 id="HTTP-2-会淘汰模块打包吗？"><a href="#HTTP-2-会淘汰模块打包吗？" class="headerlink" title="HTTP/2 会淘汰模块打包吗？"></a>HTTP/2 会淘汰模块打包吗？</h3><p>HTTP/1 只允许每个 TCP 连接带一个请求。这就是加载多个资源时需要多个请求的原因。而 HTTP/2 是完全多路复用的，这意味着多个请求和响应可并行执行。因此，我们可用单独一个链接同时处理多个请求。</p>
<p>由于每个 HTTP 请求（HTTP/2）的成本远低于 HTTP/1，从长远来说，加载多个模块不再是一个严重的性能问题。一些人认为模块打包不再需要了。这当然是有可能的，但这要具体情况具体分析了。</p>
<p>举个例说，HTTP/2 不享有模块打包提供的优势，例如移除未被使用的导出模块以节省空间。如果一个网站的每一丁点性能都至关重要，那么长远来看，打包能带来增量效益。当然，如果你对性能需求不那么极端，你可能会通过跳过该构建步骤（打包文件），以最小的成本节省时间。</p>
<p>总的来说，要让大多数网站使用 HTTP/2 协议仍有很长的路要走。我预测构建处理至少在短期内仍会保留。</p>
<p>PS：如果你对 HTTP/2 与 HTTP/1.x 的差异感兴趣，可看看这份 <a href="https://http2.github.io/faq/#what-are-the-key-differences-to-http1x" target="_blank" rel="external">优秀的资源</a>。</p>
<h3 id="CommonJS、AMD-与-UMD-会被淘汰吗？"><a href="#CommonJS、AMD-与-UMD-会被淘汰吗？" class="headerlink" title="CommonJS、AMD 与 UMD 会被淘汰吗？"></a>CommonJS、AMD 与 UMD 会被淘汰吗？</h3><p>一旦 ES6 成为模块标准，我们还需要其它非原生的模块规范吗？</p>
<p>我持怀疑态度。</p>
<p>若 Web 开发遵守一个标准方法进行导入和导出模块，将获益匪浅，而且省去了中间步骤（译者注：一些构建处理）。但 ES6 成为模块规范需要多长时间呢？</p>
<p>机会是有，但得等一段时间 ;)</p>
<p>再者，众口难调，所以“一个标准的方法”可能永远不会成为现实。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望文章的两章节能让你理清一些开发者口中的模块和模块打包的相关概念。如果发现上文有令你困惑的地方，可看看 <a href="https://github.com/JChehe/blog/blob/master/translation/JavaScript%20%E6%A8%A1%E5%9D%97%E3%80%90Part%201%E3%80%91%EF%BC%9A%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97.md" target="_blank" rel="external">part I</a>。</p>
<p>一如既往，可以在评论区和我尽情交流或回答问题！</p>
<hr>
<p>本文由 <a href="http://web.jobbole.com/" target="_blank" rel="external">伯乐在线</a> - <a href="http://www.jobbole.com/members/q574805242" target="_blank" rel="external">刘健超-J.c</a> 翻译，等待校稿。未经许可，禁止转载！</p>
<p>英文出处：<a href="https://medium.com/@preethikasireddy/javascript-modules-part-2-module-bundling-5020383cf306" target="_blank" rel="external">JavaScript Modules Part 2: Module Bundling</a>。欢迎加入翻译组。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*e0eQH_9X8jN7yC6AEqlvdQ.jpeg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;在文章的 &lt;a href=&quot;https://github.com/JChehe/blog/blob/master/translation/JavaScript%20%E6%A8%A1%E5%9D%97%E3%80%90Part%201%E3%80%91%EF%BC%9A%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97.md&quot;&gt;Part 1&lt;/a&gt;，我讲解了模块是什么、为何要使用模块和为程序整合为模块的各种方式。而在 Part 2，我将会详细讲解模块“打包”：为什么要打包模块，以不同的方式进行打包和模块在 web 开发上的未来。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="module" scheme="http://yoursite.com/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 模块【Part 1】：初学者指南</title>
    <link href="http://yoursite.com/2016/02/29/2016-2-29-javascript-modules-a-beginner-guide/"/>
    <id>http://yoursite.com/2016/02/29/2016-2-29-javascript-modules-a-beginner-guide/</id>
    <published>2016-02-29T03:31:16.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/e36f4ad51fef734fae6cdf155b053239.jpeg" alt="此处输入图片的描述"></p>
<p>如果你刚接触 JavaScript，想必已经被“module bundlers vs. module loaders”、“Webpack vs. Browserify”和“AMD vs. CommonJS” 等诸如此类的行业术语所吓到。</p>
<p>JavaScript 模块系统听起来挺吓人的，但明白它是每个 Web 开发者所必备的要求。</p>
<a id="more"></a>
<p>在这篇文章中，我将抛开这些行业术语，用通俗易懂的语言（和一些代码案例）向你解释清楚。希望你能从中收益！</p>
<blockquote>
<p>注意：为了让文章更易理解，我分为两部分进行讲述：第一部分会深入解释「模块是什么」和「为什么要使用它们」。第二部分（下周发布）讲述「模块打包意味着什么」和「用不同方式实现模块打包」。</p>
</blockquote>
<h2 id="Part-1-你能再次解释模块是什么吗？"><a href="#Part-1-你能再次解释模块是什么吗？" class="headerlink" title="Part 1: 你能再次解释模块是什么吗？"></a>Part 1: 你能再次解释模块是什么吗？</h2><p>优秀的作者会将他的书分为章和节。同理，优秀的程序员能将他的程序划分为各个模块。</p>
<p>就像书的章节，模块就是词（或代码，视情况而定）的集群。</p>
<p>好的模块拥有以下特点：不同功能是高度独立的，并且它们允许被打乱、移除或在必要时进行补充，而不会扰乱系统作为一个整体。</p>
<h2 id="为什么使用模块？"><a href="#为什么使用模块？" class="headerlink" title="为什么使用模块？"></a>为什么使用模块？</h2><p>使用模块有诸多好处，如利于建立一个扩展性强的、互相依赖的代码库。而在我看来，其最重要是：</p>
<p><strong>1）可维护性：</strong>根据定义，模块是独立的。一个设计良好的模块意在尽可能减少依赖代码库的某部分，因此它才能单独地扩展与完善。更新一个从其它代码段解耦出来的独立模块显然来得更简单。</p>
<p>回到书的案例，如果书的某个章节需要进行小改动，而该改动会牵涉到其它所有章节，这无疑是个梦魇。相反，如果每章节都以某种良好方式进行编写，那么改动某章节，则不会影响其它章节。</p>
<p><strong>2）命名空间：</strong>在 JavaScript 中，如果变量声明在顶级函数的作用域外，那么这些变量都是全局的（意味着，任何地方都能读写它）。因此，造成了常见的“命名空间污染”，从而导致完全无关的代码却共享着全局变量。</p>
<p>无关代码间共享着全局变量是一个严重的 <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad" target="_blank" rel="external">编程禁忌</a>。</p>
<p>我们将在本文后面看到，模块通过为变量创建一个私有空间，从而避免了命名空间的污染。</p>
<p><strong>3）可重用性：</strong>坦诚地讲：我们都试过复制旧项目的代码到新项目上。例如，我们复制以前项目的某些功能方法到当前项目中。</p>
<p>该做法看似可行，但如果发现那段代码有更好的实现方式（即需要改动），那么你就不得不去追溯并更新任何你所粘贴到的任何地方。</p>
<p>这无疑会浪费大量的时间。因此可重用的模块显然让你编码轻松。</p>
<h2 id="如何整合为模块？"><a href="#如何整合为模块？" class="headerlink" title="如何整合为模块？"></a>如何整合为模块？</h2><p>整合为模块的方式有很多。下面就看看其中一些方法：</p>
<h3 id="模块模式（Module-pattern）"><a href="#模块模式（Module-pattern）" class="headerlink" title="模块模式（Module pattern）"></a>模块模式（Module pattern）</h3><p>模块模式用于模仿类（由于 JavaScript 并不支持原生的类），以致我们能在单个对象中存储公有和私有变量与方法——类似于其它编程语言（如 Java 或 Python ）中的类的用法。模块模式不仅允许我们创建公用接口 API（如果我们需要暴露方法时），而且也能在闭包作用域中封装私有变量和方法。</p>
<p>下面有几种方式能实现模块模式（module pattern）。第一个案例中，我将会使用匿名闭包。只需将所有代码放进匿名函数中，就能帮助我们实现目标（记住：在 JavaScript 中，函数是唯一创建新作用域的方式）。</p>
<h4 id="Example-1：匿名闭包（Anonymous-closure）"><a href="#Example-1：匿名闭包（Anonymous-closure）" class="headerlink" title="Example 1：匿名闭包（Anonymous closure）"></a>Example 1：匿名闭包（Anonymous closure）</h4><pre><code>(function () {
  // We keep these variables private inside this closure scope
  // 让这些变量在闭包作用域内变为私有（外界访问不到这些变量）。
  var myGrades = [93, 95, 88, 0, 55, 91];

  var average = function() {
    var total = myGrades.reduce(function(accumulator, item) {
      return accumulator + item}, 0);

      return &apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;;
  }

  var failing = function(){
    var failingGrades = myGrades.filter(function(item) {
      return item &lt; 70;});

    return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;;
  }

  console.log(failing());

}());

// ‘You failed 2 times.’
</code></pre><p>通过这种结构，匿名函数拥有自身的求值环境或”闭包“，并立即执行它。这就实现了对上级（全局）命名空间的隐藏。</p>
<p>这种方法的好处是：能在函数内使用本地变量，而不会意外地重写已存在的全局变量。当然，你也能获取全局变量，如：</p>
<pre><code>var global = &apos;Hello, I am a global variable :)&apos;;

(function () {
  // We keep these variables private inside this closure scope

  var myGrades = [93, 95, 88, 0, 55, 91];

  var average = function() {
    var total = myGrades.reduce(function(accumulator, item) {
      return accumulator + item}, 0);

    return &apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;;
  }

  var failing = function(){
    var failingGrades = myGrades.filter(function(item) {
      return item &lt; 70;});

    return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;;
  }

  console.log(failing());
  console.log(global);
}());

// &apos;You failed 2 times.&apos;
// &apos;Hello, I am a global variable :)&apos;
</code></pre><p>这里需要注意的是，包围着匿名函数的小括号是必须的，这是因为当语句以关键字 function 开头时，它会被认为是一个函数声明语句（记住，JavaScript 中不能拥有未命名的函数声明语句）。因此，该括号会创建一个函数表达式代替它。欲知详情，可点击 <a href="http://stackoverflow.com/questions/1634268/explain-javascripts-encapsulated-anonymous-function-syntax" target="_blank" rel="external">这里</a>。</p>
<h4 id="Example-2：全局导入（Global-import-）"><a href="#Example-2：全局导入（Global-import-）" class="headerlink" title="Example 2：全局导入（Global import ）"></a>Example 2：全局导入（Global import ）</h4><p>另一个常见的方式是类似于 <a href="https://github.com/jquery/jquery/tree/master/src" target="_blank" rel="external">jQuery</a> 的全局导入（global import）。该方式与上述的匿名闭包相似，特别之处是传入了一个全局变量作为参数：</p>
<pre><code>(function (globalVariable) {

  // Keep this variables private inside this closure scope
  var privateFunction = function() {
    console.log(&apos;Shhhh, this is private!&apos;);
  }

  // Expose the below methods via the globalVariable interface while
  // hiding the implementation of the method within the 
  // function() block
  // 通过 globalVariable 接口暴露下面的方法。当然，这些方法的实现则隐藏在 function() 块内

  globalVariable.each = function(collection, iterator) {
    if (Array.isArray(collection)) {
      for (var i = 0; i &lt; collection.length; i++) {
        iterator(collection[i], i, collection);
      }
    } else {
      for (var key in collection) {
        iterator(collection[key], key, collection);
      }
    }
  };

  globalVariable.filter = function(collection, test) {
    var filtered = [];
    globalVariable.each(collection, function(item) {
      if (test(item)) {
        filtered.push(item);
      }
    });
    return filtered;
  };

  globalVariable.map = function(collection, iterator) {
    var mapped = [];
    globalUtils.each(collection, function(value, key, collection) {
      mapped.push(iterator(value));
    });
    return mapped;
  };

  globalVariable.reduce = function(collection, iterator, accumulator) {
    var startingValueMissing = accumulator === undefined;

    globalVariable.each(collection, function(item) {
      if(startingValueMissing) {
        accumulator = item;
        startingValueMissing = false;
      } else {
        accumulator = iterator(accumulator, item);
      }
    });

    return accumulator;

  };

 }(globalVariable));
</code></pre><p>在该案例中，<code>globalVariable</code> 是唯一的全局变量。这个相对于匿名闭包的优势是：提前声明了全局变量，能让别人更清晰地阅读你的代码。</p>
<h4 id="Example-3：对象接口（Object-interface）"><a href="#Example-3：对象接口（Object-interface）" class="headerlink" title="Example 3：对象接口（Object interface）"></a>Example 3：对象接口（Object interface）</h4><p>使用一个独立的对象接口创建模块，如：</p>
<pre><code>var myGradesCalculate = (function () {

  // Keep this variable private inside this closure scope
  var myGrades = [93, 95, 88, 0, 55, 91];

  // Expose these functions via an interface while hiding
  // the implementation of the module within the function() block

  return {
    average: function() {
      var total = myGrades.reduce(function(accumulator, item) {
        return accumulator + item;
        }, 0);

      return&apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;;
    },

    failing: function() {
      var failingGrades = myGrades.filter(function(item) {
          return item &lt; 70;
        });

      return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;;
    }
  }
})();

myGradesCalculate.failing(); // &apos;You failed 2 times.&apos; 
myGradesCalculate.average(); // &apos;Your average grade is 70.33333333333333.&apos;
</code></pre><p>正如你所看到的，该方式让你决定哪个变量/方法是私有的（如 <code>myGrades</code>），哪个变量/方法是需要暴露出来的（通过将需要暴露出来的变量/方法放在 return 语句中，如 <code>average</code> &amp; <code>failing</code>）。</p>
<h4 id="Example-4-暴露模块模式（Revealing-module-pattern）"><a href="#Example-4-暴露模块模式（Revealing-module-pattern）" class="headerlink" title="Example 4: 暴露模块模式（Revealing module pattern）"></a>Example 4: 暴露模块模式（Revealing module pattern）</h4><p>这与上一个方法非常类似，只不过该方法确保所有变量和方法都是私有的，除非显式暴露它们：</p>
<pre><code>var myGradesCalculate = (function () {

  // Keep this variable private inside this closure scope
  var myGrades = [93, 95, 88, 0, 55, 91];

  var average = function() {
    var total = myGrades.reduce(function(accumulator, item) {
      return accumulator + item;
      }, 0);

    return&apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;;
  };

  var failing = function() {
    var failingGrades = myGrades.filter(function(item) {
        return item &lt; 70;
      });

    return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;;
  };

  // Explicitly reveal public pointers to the private functions 
  // that we want to reveal publicly

  return {
    average: average,
    failing: failing
  }
})();

myGradesCalculate.failing(); // &apos;You failed 2 times.&apos; 
myGradesCalculate.average(); // &apos;Your average grade is 70.33333333333333.&apos;
</code></pre><p>看似有许多知识需要我们吸收，但这只是模块模式（module patterns）的冰山一角。在我学习这方面知识时，发现了下面这些有用的资源：</p>
<ul>
<li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript" target="_blank" rel="external">Learning JavaScript Design Patterns</a>： 出自 Addy Osmani，他以极其简洁的方式对模块模式进行详细分析。</li>
<li><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">Adequately Good by Ben Cherry</a>：一篇通过案例对模块模式的高级用法进行概述的文章。</li>
<li><a href="https://carldanley.com/js-module-pattern/" target="_blank" rel="external">Blog of Carl Danley</a>：一篇对模块模式进行概述并拥有其它 JavaScript 模式资源的文章。</li>
</ul>
<h3 id="CommonJS-and-AMD"><a href="#CommonJS-and-AMD" class="headerlink" title="CommonJS and AMD"></a>CommonJS and AMD</h3><p>上述所有方法都有一个共同点：使用一个全局变量将其代码封装在一个函数中，从而利用闭包作用域为自身创建一个私有的命名空间。</p>
<p>虽每种方式都有效，但他们也有消极的一面。</p>
<p>举个例子说，作为一名开发者，需要以正确的依赖顺序去加载你的文件。更直接地说，假如你在项目中使用 Backbone，那么你需要在文件中用 script 标签引入 Backbone 的源代码。</p>
<p>然而，由于 Backbone 重度依赖于 Underscore.js，因此 Backbone 的 script 标签不能放在 Underscore 的 script 标签前。</p>
<p>作为一名开发者，有时会为了正确处理并管理好依赖而感到头痛。</p>
<p>另一个消极面是：他们仍会导致命名空间污染。例如，两个模块拥有同样的名字，或者一个模块拥有两个版本，而且你同时需要他们俩。</p>
<p>所以，你可能会想到：我们能不能设计一种方法，无须通过全局作用域去请求一个模块接口呢？</p>
<p>答案是能！</p>
<p>有两种流行且实现良好的方法：CommonJS 和 AMD。</p>
<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>CommonJS 是一个志愿工作组设计并实现的 JavaScript 声明模块 APIs</p>
<p>CommonJS 模块本质上是一片可重用的 JavaScript 代码段，将其以特定对象导出后，其它模块即可引用它。如果你接触过 Node.js，那么你应该非常熟悉这种格式。</p>
<p>通过 CommonJS，每个 JavaScript 文件保存的模块都拥有其独一无二的模块上下文（就像封装在闭包内）。在此作用域中，我们使用 <code>module.exports</code> 对象导出模块，然后通过 require 导入它们。</p>
<p>当你定义一个 CommonJS 模块时，代码类似：</p>
<pre><code>function myModule() {
  this.hello = function() {
    return &apos;hello!&apos;;
  }

  this.goodbye = function() {
    return &apos;goodbye!&apos;;
  }
}

module.exports = myModule;
</code></pre><p>我们使用特定对象模块，并将 module.exports 指向我们的函数。这让 CommonJS 模块系统知道我们想导出什么，并让其它文件能访问到它。</p>
<p>然后，当有人想使用 <code>myModule</code> 时，他们可在文件内将其 <code>require</code> 进来，如：</p>
<pre><code>var myModule = require(&apos;myModule&apos;);

var myModuleInstance = new myModule();
myModuleInstance.hello(); // &apos;hello!&apos;
myModuleInstance.goodbye(); // &apos;goodbye!&apos;
</code></pre><p>该方法相对于我们先前讨论的模块模式有两个显而易见的好处：</p>
<ol>
<li>避免了全局命名空间的污染</li>
<li>让依赖关系更明确</li>
</ol>
<p>此外，该语法非常紧凑简单，我个人非常喜欢。</p>
<p>另外需要注意的一点是：CommonJS 采用服务器优先的方式，并采用同步的方式加载模块。这点很重要，因为如果我们有其它三个模块需要 <code>require</code> 进来的话，这些模块会被一个接一个地加载。</p>
<p>这种工作方式很适合应用在服务器上。但不幸的是，当你将这种方式应用在浏览器端时，就会出现问题。因为相对于硬盘，从 web 上读取模块<strong>更耗时</strong>（网络传输等因素）。而且，只要模块正在加载，就会阻塞浏览器运行其它任务。这是由于 JavaScript 线程会在代码加载完成前被停止。（在 Part 2 的模块打包部分，我会告诉你如何解决此问题。而现在，只需了解到这）。</p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>CommonJS 是不错，但如果我们想异步加载模块呢？答案是异步模块定义（Asynchronous Module Definition），或简称 AMD。</p>
<p>使用 AMD 加载模块的代码类似：</p>
<pre><code>define([&apos;myModule&apos;, &apos;myOtherModule&apos;], function(myModule, myOtherModule) {
  console.log(myModule.hello());
});
</code></pre><p><code>define</code> 函数的第一个参数是一个包含本模块所依赖的模块数组。这些依赖都在后台加载（以不阻塞的方式）。加载完成后，<code>define</code> 会调用其指定的回调函数。</p>
<p>接着，回调函数会将加载完成后的依赖作为其参数（一一对应）——在该案例中，是 <code>myModule</code> 和 <code>myOtherModule</code>。因此，回调函数就能使用这些依赖。当然，这些依赖本身也需要通过 <code>define</code> 关键字定义。<br>例如，<code>myModule</code> 类似：</p>
<pre><code>define([], function() {

  return {
    hello: function() {
      console.log(&apos;hello&apos;);
    },
    goodbye: function() {
      console.log(&apos;goodbye&apos;);
    }
  };
});
</code></pre><p>不像 CommonJS，AMD 采取浏览器优先的方式，通过异步加载的方式完成任务。（注意，有很多人并不赞成此方式，因为他们坚信在代码开始运行时动态且逐个地加载文件是不好的。我将会在下一节的模块构建（module-building）中探讨更多相关信息）。</p>
<p>除了异步外，AMD 的另一个好处是：模块可以是一个对象、函数、构造函数、字符串、JSON 或其它各种类型，而 CommonJS 仅支持对象作为模块。</p>
<p>话虽如此，AMD 不兼容 io、文件系统（filesystem）和其它通过 CommonJS 实现的面向服务器的功能，而且其通过函数封装的语法与简单的 require 语句相比显得有点啰嗦。</p>
<h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h4><p>对于需要同时支持 AMD 和 CommonJS 特性的项目，你可选择另一种规范：通用的模块定义（Universal Module Defintion，简称 UMD）。</p>
<p>UMD 在本质上创建了一种使用二者其一的方式，同时也支持定义全局变量。因此，UMD 模块适用于客户端和服务器端。</p>
<p>下面快速浏览 UMD 是如何处理其业务的：</p>
<pre><code>(function (root, factory) {
  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) {
      // AMD
    define([&apos;myModule&apos;, &apos;myOtherModule&apos;], factory);
  } else if (typeof exports === &apos;object&apos;) {
      // CommonJS
    module.exports = factory(require(&apos;myModule&apos;), require(&apos;myOtherModule&apos;));
  } else {
    // Browser globals (Note: root is window)
    root.returnExports = factory(root.myModule, root.myOtherModule);
  }
}(this, function (myModule, myOtherModule) {
  // Methods
  function notHelloOrGoodbye(){}; // A private method
  function hello(){}; // A public method because it&apos;s returned (see below)
  function goodbye(){}; // A public method because it&apos;s returned (see below)

  // Exposed public methods
  return {
      hello: hello,
      goodbye: goodbye
  }
}));
</code></pre><p>想获取更多关于 UMD 的案例，可看看 Github 上的 <a href="https://github.com/umdjs/umd" target="_blank" rel="external">enlightening repo</a>。</p>
<h3 id="原生-JS（Native-JS）"><a href="#原生-JS（Native-JS）" class="headerlink" title="原生 JS（Native JS）"></a>原生 JS（Native JS）</h3><p>哊！我没把你绕晕了吧？好吧，下面还有<strong>另一种</strong>定义模块的方式。</p>
<p>可能你已注意到：上述的模块都不是原生 JavaScript 模块。它们只不过是我们用模块模式（module pattern）、CommonJS 或 AMD <strong>模仿</strong>的模块系统。</p>
<p>幸运的是，机智的标准制定者在 TC39（该标准定义了 ECMAScript 的语法与语义）已经为 ECMAScript 6（ES6）引入内置的模块系统了。</p>
<p>ES6 为导入（importing）导出（exporting）模块带来了很多可能性。下面是很好的资源：</p>
<ul>
<li><a href="http://jsmodules.io/cjs.html" target="_blank" rel="external">jsmodules.io</a></li>
<li><a href="http://exploringjs.com/es6/ch_modules.html" target="_blank" rel="external">exploringjs.com</a></li>
</ul>
<p>相对于 CommonJS 或 AMD，ES6 模块如何设法提供两全其美的实现方案：简洁紧凑的声明式语法和异步加载，另外能更好地支持循环依赖。</p>
<p>我最喜欢 ES6 模块的特性应该是导入的都是<strong>动态</strong>且只读的导出视图（CommonJS 导入的都是导出的副本，因此不是动态的）。</p>
<blockquote>
<p>上一句的原文是：Probably my favorite feature of ES6 modules is that imports<br>are live read-only views of the exports. (Compare this to CommonJS,<br>where imports are copies of exports and consequently not alive).</p>
</blockquote>
<p>下面这个例子展示了它（CommonJS）如何运行：</p>
<pre><code>// lib/counter.js

var counter = 1;

function increment() {
  counter++;
}

function decrement() {
  counter--;
}

module.exports = {
  counter: counter,
  increment: increment,
  decrement: decrement
};

// src/main.js

var counter = require(&apos;../../lib/counter&apos;);

counter.increment();
console.log(counter.counter); // 1
</code></pre><p>在此案例中，我们主要构造了该模块的两个副本：一个是在我们导出它时，另一个是在我们引入它时。</p>
<p>此外，在 main.js 的副本与原来的模块是分离的。这就是为什么当我们的计数器自增时，仍返回 1 —— 因为我们导入的计数器变量（counter）与来自原本模块的计数器副本是分离的。</p>
<p>所以，计算器的自增只会在模块内自增，并不会在复制的版本自增。要修改复制版本的计数器的唯一方式是手动自增。</p>
<pre><code>counter.counter++;
console.log(counter.counter); // 2
</code></pre><p>对于ES6，它会在导入时创建一个动态的、只读的模块视图。</p>
<pre><code>// lib/counter.js
export let counter = 1;

export function increment() {
  counter++;
}

export function decrement() {
  counter--;
}

// src/main.js
import * as counter from &apos;../../counter&apos;;

console.log(counter.counter); // 1
counter.increment();
console.log(counter.counter); // 2
</code></pre><p>很酷对吧？但我认为动态且只读的视图的真正引人注目的是，它允许你将模块分成更小的片段，而又不导致功能的缺失。</p>
<p>你可以反过来再次合并他们，且不会导致任何问题。</p>
<h3 id="期待：模块打包（bundling-modules）"><a href="#期待：模块打包（bundling-modules）" class="headerlink" title="期待：模块打包（bundling modules）"></a>期待：模块打包（bundling modules）</h3><p>哇！时间过得真快。这是个疯狂之旅，但我真心希望本文能让你更好地了解 JavaScript 模块。</p>
<p>在下一节，我将会讲述模块打包（module bundling）和覆盖以下核心主题：</p>
<ul>
<li>为什么需要模块打包</li>
<li>以不同方式进行打包</li>
<li>ECMAScript 的模块加载 API</li>
<li>等等 :）</li>
</ul>
<p>注意：为了尽可能通俗易懂，我跳过了一些细节（如：循环依赖）。如果我漏了任何重要或有趣的知识，请在评论里告诉我！</p>
<hr>
<p>本文由 <a href="http://web.jobbole.com/" target="_blank" rel="external">伯乐在线</a> - <a href="http://www.jobbole.com/members/q574805242" target="_blank" rel="external">刘健超-J.c</a> 翻译，等待校稿。未经许可，禁止转载！</p>
<p>英文出处：<a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc" target="_blank" rel="external">JavaScript Modules: A Beginner’s Guide</a>。欢迎加入翻译组。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xq7nb.com1.z0.glb.clouddn.com/e36f4ad51fef734fae6cdf155b053239.jpeg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你刚接触 JavaScript，想必已经被“module bundlers vs. module loaders”、“Webpack vs. Browserify”和“AMD vs. CommonJS” 等诸如此类的行业术语所吓到。&lt;/p&gt;
&lt;p&gt;JavaScript 模块系统听起来挺吓人的，但明白它是每个 Web 开发者所必备的要求。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="module" scheme="http://yoursite.com/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>关于 Glob (gulp)的学习</title>
    <link href="http://yoursite.com/2016/02/24/2016-2-24-study-glob/"/>
    <id>http://yoursite.com/2016/02/24/2016-2-24-study-glob/</id>
    <published>2016-02-24T04:47:42.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">https://github.com/isaacs/node-glob</a><br>下文是关于 Gulp 的 <code>gulp.src(globs[, options])</code> 方法的第一个参数 <code>globs</code> 的学习。<br>需要注意的是：<br>当该参数 <code>globs</code> 为数组时，其包含的多个 glob 会<strong>按顺序进行解析</strong>，这意味着以下意图是可以实现的：<br><a id="more"></a><br>    // 排除所有以字母 b 开头的 js 文件，但不排除 bad.js<br>    gulp.src([‘<em>.js’, ‘!b</em>.js’, ‘bad.js’])</p>
<hr>
<h2 id="Glob"><a href="#Glob" class="headerlink" title="Glob"></a>Glob</h2><p>使用 shell 里的 patterns 匹配文件，如 <code>*</code> 等。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="用-npm-安装-glob"><a href="#用-npm-安装-glob" class="headerlink" title="用 npm 安装 glob"></a>用 npm 安装 glob</h3><pre><code>npm i glob
</code></pre><p>编写js代码：</p>
<pre><code>var glob = require(&quot;glob&quot;);

// options 是可选参数
glob(&quot;**/*.js&quot;, options, function (er, files) {
  // files 参数是一个文件名数组。
  // 若参数 options 的 `nonull` 属性为 true，则在匹配不到文件时， files 参数则为 [&quot;**/*.js&quot;]。
  //（ 若 `nonull` 为 false 时， files 为空数组）。
  // er 是一个 error 对象或 null。
})
</code></pre><h2 id="Glob-初级"><a href="#Glob-初级" class="headerlink" title="Glob 初级"></a>Glob 初级</h2><p>“Globs” 是你通过在命令行输入字符后完成某些操作时的 pattern。如 <code>ls *.js</code>，或将 <code>build/*</code> 放在 <code>.gitignore</code>。</p>
<p>在解析路径段的 patterns 前，braced sections 会展开为一个集合。braced sections 以 <code>{</code> 开头，<code>}</code> 为结尾，中间部分以英文逗号 <code>,</code> 分隔。braced sections 可以含有斜杠符号 <code>/</code>。因此，<code>a{/b/c,bcd}</code> 会展开为 <code>a/b/c</code> 和 <code>abcd</code>。</p>
<p>以下字符用在路径段时，会拥有特别的含义：</p>
<ul>
<li><p><code>*</code> ： 匹配0或多个字符。</p>
<pre><code>glob(&quot;js/*.js&quot;, function(err, files){
    console.log(files);
});
</code></pre><p>获取js目录下的所有js文件（不包括以<code>.</code>开头的文件，下文有方法解决：对 glob 方法的 options 参数的属性 <code>dot:true</code>）。</p>
</li>
</ul>
<ul>
<li><p><code>?</code> ： 匹配一个字符（不能为空）。</p>
<pre><code>glob(&quot;js/a?.js&quot;, function(err, files){
    console.log(files);
}
</code></pre><p>获取js目录下所有文件名长度为1字符的js文件。例如：能匹配 js/ab.js，不能匹配 js/a.js。</p>
</li>
</ul>
<ul>
<li><p><code>[...]</code> ： 匹配该路径段中在指定范围内的一个字符。<br>注意：不能组合，只能匹配其中<strong>一个</strong>字符。另外，如果指定范围的首字符是 <code>!</code> 或 <code>^</code>，则匹配<strong>不在指定范围内</strong>的<strong>一个</strong>字符。</p>
<pre><code>glob(&quot;js/a[0-3].js&quot;, function(err, files){
    console.log(files);
})
</code></pre><p>获取js目录下以<code>a</code>开头，第二个字符为0-3之间（包括0和3）的js文件。若改为 <code>[&quot;js/[^ab].js&quot;]</code>，则匹配  js/c.js，不匹配 js/cd.js、js/ac.js。</p>
</li>
</ul>
<ul>
<li><p><code>!(pattern|pattern|pattern)</code> ： 匹配（完全且精确地匹配，且不可组合）不符合任何模型之一的字符。注意 <code>|</code> 前后不能有空格，下同。</p>
<pre><code>glob(&quot;js/!(a|b).js&quot;, function(err, files){
    console.log(files);
});
</code></pre><p>匹配 js 目录下的 aa.js、ab.js、ba.js、c.js 不匹配 a.js、b.js。</p>
</li>
</ul>
<ul>
<li><p><code>?(pattern|pattern|pattern)</code>：匹配多个 pattern 中 0 或 1 个（精确匹配，不可以组合）。</p>
<pre><code>glob(&quot;js/?(a|b).js&quot;, function(err, files){
    console.log(files);
});
</code></pre><p>匹配 js 目录下的 a.js、b.js，不匹配 ab.js</p>
</li>
</ul>
<ul>
<li><p><code>+(pattern|pattern|pattern)</code> ： 至少匹配多个 pattern 中的一个。与<code>*(pattern|pattern|pattern)</code> 不用的是，它必须1个及以上，不能为空。</p>
<pre><code>glob(&quot;js/+(a|b)b.js&quot;, function(err, files){
     console.log(files);
});
</code></pre><p>匹配 js 目录下的 ab.js、bb.js、ababab.js，不能匹配 abcd.js（也就是说：只允许匹配出现在范围内的字符） ，也不能像 <code>js/*(a|b)b.js</code> 那样匹配 b.js。</p>
</li>
</ul>
<ul>
<li><p><code>*(a|b|c)</code> ： 匹配括号中多个 pattern 中0或任意多个（pattern可相互组合）。 </p>
<pre><code>glob(&quot;js/*(a|b|c).js&quot;, function(err, files){
    console.log(files);
});
</code></pre><p>匹配 js 目录下的 a.js、ab.js、abc.js、ba.js，不匹配 abcd.js（也就是说：只允许匹配出现在范围内的字符）。</p>
</li>
</ul>
<ul>
<li><p><code>@(pattern|pattern|pattern)</code> 匹配多个 pattern 中的任意一个（即不可以组合，且不能为空或大于1个）。与 <code>?(pattern|pattern|pattern)</code> 区别是不可为空。</p>
<pre><code>glob(&quot;js/@(a|b)b.js&quot;, function(err, files){
    console.log(files);
});
</code></pre><p>匹配 js 目录下的 ab.js、bb.js，不匹配 b.js、abb.js、abc.js。</p>
</li>
</ul>
<ul>
<li><p><code>**</code> 与 <code>*</code> 类似，可以匹配任何内容（可匹配空），但 <code>**</code> 不仅能匹配路径中的特定一段，还能匹配后代所有目录（即多段路径段）。</p>
<pre><code>glob(&quot;js/**/*.js&quot;, function(err, files){
    console.log(files);
});
</code></pre><p>匹配 js 目录下所有js文件，如 js/a.js 或 js/a/b/c/d.js。</p>
</li>
</ul>
<h2 id="Dots-即"><a href="#Dots-即" class="headerlink" title="Dots(即 .)"></a>Dots(即 <code>.</code>)</h2><p>如果文件或目录的某路径段以 <code>.</code> 作为首字符，那么该路径段不会符合任何  glob pattern，除非该 pattern 的相应路径段同样以 <code>.</code> 作为首字符。</p>
<p>例如，pattern <code>a/.*/c</code> 会匹配文件 <code>a/.b/c</code>，而 pattern <code>a/*/c</code> 则不会匹配该文件，因为 <code>*</code> 不会匹配以 <code>.</code> 字符开头的文件。</p>
<p>可通过在 options 设置 <code>dot: true</code>，让 glob 将 <code>.</code> 视为普通字符。</p>
<h2 id="Basename-匹配"><a href="#Basename-匹配" class="headerlink" title="Basename 匹配"></a>Basename 匹配</h2><p>如果在 options 设置 <code>matchBase: true</code>，且 pattern 不含有 <code>/</code>，那么将会寻找任何匹配 basename 的文件，即在当前路径下的文件树进行搜索。例如，<code>*.js</code> 会匹配 <code>test/simple.basic.js</code>。</p>
<h2 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h2><p>如果不匹配任何文件，则会返回空数组。这点与 shell 不同，shell 会返回自身 pattern。</p>
<pre><code>$echo echo a*s*d*f
a*s*d*f
</code></pre><p>若想得到 bash 那样的行为，可对 options 参数设置 <code>nonull:true</code>。</p>
<p>若发现文中有任何错误，或有任何好的建议，欢迎评论。</p>
<hr>
<p>GitHub：<a href="https://github.com/JChehe/blog/blob/master/posts/%E5%85%B3%E4%BA%8E%20Glob%20%E7%9A%84%E5%AD%A6%E4%B9%A0.md" target="_blank" rel="external">关于 Glob (gulp) 的学习</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;a href=&quot;https://github.com/isaacs/node-glob&quot;&gt;https://github.com/isaacs/node-glob&lt;/a&gt;&lt;br&gt;下文是关于 Gulp 的 &lt;code&gt;gulp.src(globs[, options])&lt;/code&gt; 方法的第一个参数 &lt;code&gt;globs&lt;/code&gt; 的学习。&lt;br&gt;需要注意的是：&lt;br&gt;当该参数 &lt;code&gt;globs&lt;/code&gt; 为数组时，其包含的多个 glob 会&lt;strong&gt;按顺序进行解析&lt;/strong&gt;，这意味着以下意图是可以实现的：&lt;br&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="glob" scheme="http://yoursite.com/tags/glob/"/>
    
  </entry>
  
  <entry>
    <title>用Mocha和Chai对JavaScript进行单元测试</title>
    <link href="http://yoursite.com/2016/02/06/2016-2-6-unit-test-javascript-mocha-chai/"/>
    <id>http://yoursite.com/2016/02/06/2016-2-6-unit-test-javascript-mocha-chai/</id>
    <published>2016-02-06T03:28:13.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>你曾试过修改代码后，导致其它地方出现问题吗？</p>
<p>也许有大多数人试过。因为这是几乎不可避免的，特别在庞大的代码面前。由于代码间可能是环环相扣的，改变一处会影响另一处。</p>
<p>但如果这种情况不会发生呢？如果你有一种方法能知道改变后会出现的结果呢？这无疑是极好的。因为修改代码后无需担心会破坏什么东西，从而程序出现 bug 的概率更低，在 debug 上花费时间更少。<br><a id="more"></a><br>这就是单元测试的魅力。它能自动检测代码中的任何问题。在修改代码后进行相应测试，若有问题，能立刻知道问题是什么，问题在哪和正确的做法是什么。这完全消除任何猜测！</p>
<p>在本文，我会让你了解如何对 JavaScript 代码进行单元测试。而且，在本文出现的案例和技术可同时应用到基于浏览器的代码和 Node.js 的代码。</p>
<p>教程中的代码也可到我的 <a href="https://github.com/sitepoint-editors/mocha-unit-testing" target="_blank" rel="external">GitHub repo</a> 中得到。</p>
<h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p>当你对代码库进行测试时，可先取一段代码（如函数），然后在特定情况下，验证其行为是否正确。而单元测试就是这方面的一种结构化和自动化的方法。当然，写的测试越多，获得的益处也更大。这也让你进行开发时会更加自信。</p>
<p>单元测试的核心思想是给函数特定的输入，测试其行为。也就是说，以特定的参数调用函数，然后检查是否得到正确的结果。</p>
<pre><code>// Given 1 and 10 as inputs...
// 输入 1 和 10...
var result = Math.max(1, 10);

// ...we should receive 10 as the output
// ...应该输出 10
if(result !== 10) {
  throw new Error(&apos;Failed&apos;);
}
</code></pre><p>在实际中，测试有时会更复杂。例如，如果你的函数含有一个 Ajax 请求，那么测试就需要设定更多的东西。当然，“赋予特定的输入，期待得到一个特定的输出”原理仍然适用。</p>
<h2 id="设置工具"><a href="#设置工具" class="headerlink" title="设置工具"></a>设置工具</h2><p>在本文，我们选择 Mocha。它入门简单，能同时适用于基于浏览器的测试和 Node.js 的测试，而且与其它测试工具运行良好。</p>
<p>安装 Mocha 的最简单方式是 npm（为此，也需要安装 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>）。如果你不懂得如何在你的电脑上安装 npm 或 Node.js，可查看我的教程 <a href="http://www.sitepoint.com/beginners-guide-node-package-manager/" target="_blank" rel="external">A Beginner’s Guide to npm — the Node Package Manager</a>。</p>
<p>安装好 Node.js 后，在你的项目目录下打开 terminal 或 command line。</p>
<ul>
<li>如果你想在浏览器上测试代码，执行 <code>npm install mocha chai --save-dev</code>。</li>
<li>如果你想测试 Node.js 代码，除了执行上面那行命令，也要执行 <code>npm install -g mocha</code>。</li>
</ul>
<p>这就安装了 <code>mocha</code> 和 <code>chai</code> 包（package）了。<a href="https://mochajs.org/" target="_blank" rel="external">Mocha</a> 是一个运行测试的库，而 <a href="http://chaijs.com/" target="_blank" rel="external">Chai</a> 包含一些有用的功能，我们能利用这些功能对我们的测试结果进行验证。</p>
<h3 id="Node-js-vs-Browser-测试对比"><a href="#Node-js-vs-Browser-测试对比" class="headerlink" title="Node.js vs Browser 测试对比"></a>Node.js vs Browser 测试对比</h3><p>下面的案例是在浏览器上运行测试的。如果想为你的 Node.js 应用进行单元测试，要遵循以下步骤。</p>
<ul>
<li>对于 Node，无需测试运行文件（test runner file）。</li>
<li>为了引入 Chari，需在测试文件顶部添加语句 <code>var chai = require(&#39;chai&#39;);</code>。</li>
<li>用 <code>mocha</code> 命令执行单元测试，而不是打开浏览器。</li>
</ul>
<h2 id="设置目录结构"><a href="#设置目录结构" class="headerlink" title="设置目录结构"></a>设置目录结构</h2><p>为了让文件结构更清晰，应将测试文件放在主代码文件的一个独立目录下。这是为了方便以后添加其它类型的测试（如<a href="https://en.wikipedia.org/wiki/Integration_testing" target="_blank" rel="external">集成测试（integration tests）</a> 和 <a href="https://en.wikipedia.org/wiki/Functional_testing" target="_blank" rel="external">功能测试（functional tests）</a>）。</p>
<p>对于 JavaScript，最流行的实践方案是在项目根目录下创建一个 <code>test/</code> 文件夹。然后，将每个测试文件放置在该文件夹下，如 <code>test/someModuleTest.js</code>。另一种方案是，在 <code>test/</code> 目录下，再创建文件夹。但我建议尽量保持简单——这样能保证在后面必要时进行（快速）修改。</p>
<h2 id="设置测试运行器（Test-Runner）"><a href="#设置测试运行器（Test-Runner）" class="headerlink" title="设置测试运行器（Test Runner）"></a>设置测试运行器（Test Runner）</h2><p>为了能在浏览器上进行测试，我们需要创建一个简单的 HTML 页面作为测试运行页（test runner page）。该页面会加载 Mocha、测试库文件和实际测试文件。为了运行这些测试，我们只需在浏览器打开运行器（runner）。</p>
<p>如果你使用 Node.js，你可跳过这一步。Node.js 的单元测试能通过命令 <code>mocha</code> 运行，前提是按照我推荐的目录结构。</p>
<p>下面是我们用于测试运行器（test runner）的代码。我将其存为 <code>testrunner.html</code>。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Mocha Tests&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/mocha/mocha.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;node_modules/mocha/mocha.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/chai/chai.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;mocha.setup(&apos;bdd&apos;)&lt;/script&gt;

    &lt;!-- load code you want to test here --&gt;

    &lt;!-- load your test files here --&gt;

    &lt;script&gt;
      mocha.run();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>该测试运行器的几个重要点：</p>
<ul>
<li>为了让测试结果拥有漂亮的样式，我们加载了 Mocha 的 CSS 文件。</li>
<li>创建了一个 ID 为 mochat 的 div 标签。测试结果将放在该标签内。</li>
<li>加载 Mocha 和 Chai 脚本文件。由于这两个文件是通过 npm 安装的，它们被放在 node_modules 目录的相应文件夹下。</li>
<li>通过调用 mocha.setup，开启 Mocha 的测试功能（testing helpers）。</li>
<li>然后，加载需要的测试项和相应测试的文件。尽管我们还没在这放置任何代码。</li>
<li>最后，调用了 mocha.run 执行相应测试。当然，要确保在资源和测试文件加载完成后才调用该函数。</li>
</ul>
<h2 id="基本的测试骨架"><a href="#基本的测试骨架" class="headerlink" title="基本的测试骨架"></a>基本的测试骨架</h2><p>现在我们可以运行测试了，下面就开始写点测试相关的东西吧。</p>
<p>首先，创建 <code>test/arrayTest.js</code>。每个文件名都有其具体含义，显然它是个测试文件，并会测试 array 的基本功能。</p>
<p>每个测试案例文件都会遵循以下基本模式。首先，有个 <code>describe</code> 块：</p>
<pre><code>describe(&apos;Array&apos;, function() {
  // Further code for tests goes here
});
</code></pre><p><code>describe</code> 用于把单独的测试聚合在一起。其第一个参数用于指示测试什么。在本例中，由于我们打算测试 array 功能，我传入一个 <code>&#39;Array&#39;</code> 字符串。</p>
<p>然后，在 <code>describe</code> 内需有 <code>it</code> 块：</p>
<pre><code>describe(&apos;Array&apos;, function() {
  it(&apos;should start empty&apos;, function() {
    // Test implementation goes here
  });

  // We can have more its here
});
</code></pre><p><code>it</code> 用于创建实际的测试。其第一个参数是对该测试的描述，且该描述的语言应该是人类可读的（而非编程语言）。如在本例中，“it should empty”能很好地描述了 array 的行为。实现该测试的具体代码则写在 <code>it</code> 的第二个参数 function 内。</p>
<p>所有 Mocha 测试都以同样的骨架编写，而且它们遵循这相同且基本的模式。</p>
<ul>
<li>首先，使用 <code>describe</code> 表明我们测试什么，如“描述 array 该如何运行”。</li>
<li>然后，使用多个 <code>it</code> 函数创建独立的测试，每个 <code>it</code> 应该描述一个特定的行为，如上述的案例 “it should start empty（array 运行前应为空）”</li>
</ul>
<h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>现在我们已经知道如何构造测试案例了，下面就开始更有趣的部分——实现测试。</p>
<p>由于我们的测试是 array 初始值应为空，即我们需要创建一个数组并确保它为空。实现该测试是非常简单的：</p>
<pre><code>var assert = chai.assert;

describe(&apos;Array&apos;, function() {
  it(&apos;should start empty&apos;, function() {
    var arr = [];

    assert.equal(arr.length, 0);
  });
});
</code></pre><p>请注意首行代码，我们设置了 <code>assert</code> 变量。这样就不用每次需要它时输入 <code>chai.assert</code> 了。</p>
<p>在 <code>it</code> 函数里，我们创建了一个数组并检查其长度。尽管简单，但很好地展示了测试是如何工作的。</p>
<p>首先，你有东西需要被测试——这叫 <a href="https://zh.wikipedia.org/wiki/%E8%A2%AB%E6%B5%8B%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">被测系统（System Under Test，SUT）</a>。若有需要，则对被测系统进行相应操作。对于上述案例，由于检查数组初始值是否为空，我们没做任何操作。</p>
<p>测试的最后步骤应该是验证——对结果进行断言（assertion）检查。对于上述案例，我们对此使用 <code>assert.equal</code>。大多数断言函数的参数顺序是一致的：首先是“实际”值，然后是“期待”值。 </p>
<p>实际值是测试代码的结果，因此，在该案例中是 <code>arr.length</code>。</p>
<p>期待值是预想的结果。由于数组的初始值应为空，因此，在该案例中的期待值是 <code>0</code>。</p>
<p>虽然 Chai 提供了两种不同的断言（assertion）编写方式，但现在为了保持简单，我们使用了 <a href="http://chaijs.com/api/assert/" target="_blank" rel="external">assert</a>。当你能熟练编写测试时，你可能更想用 <a href="http://chaijs.com/api/bdd/" target="_blank" rel="external">expect assertions</a> ，因为它提供了更灵活的操作。</p>
<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>为了运行该测试，我们需要将其添加到先前创建的测试运行器文件内。</p>
<p>对于 Node.js，可跳过此步骤，然后使用命令 <code>mocha</code> 执行测试。你会在 terminal 里看到测试结果。</p>
<p>向运行器添加该测试（针对浏览器端）：</p>
<pre><code>&lt;!-- load your test files here --&gt;
&lt;script src=&quot;test/arrayTest.js&quot;&gt;&lt;/script&gt;
</code></pre><p>你一旦添加了脚本，就可以加载测试运行器页面了（若选择在浏览器进行测试）。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>当你运行这些测试，其测试结果看起来和下图类似：</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/1mocha-test-results.jpg" alt="Mocha test results - 1 test passing"></p>
<p>注意：在 <code>describe</code> 和 <code>it</code> 函数的描述语句都在页面展示出来了——测试项（如：should start empty）都分组放在描述（如：Array）下。当然，也可以对 <code>describe</code> 块再嵌套，以创建更深的子分组。</p>
<p>下面看看测试失败是显示什么。</p>
<p>将测试的该行代码进行修改：</p>
<pre><code>assert.equal(arr.length, 0);
</code></pre><p>将 0 改为 1。这无疑会导致测试失败，因为数组长度不再匹配期待值。</p>
<p>如果你再次运行测试，那么在测试结果中，运行错误的描述将以红色显示。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/2mochatest-error.jpg" alt="Mocha test error - one test failing"></p>
<p>测试的一项好处是能帮助你更快地找到 bug，尽管错误信息在这并不是非常详细。</p>
<p>大多数断言函数都带有一个可选的 <code>message</code> 参数。该信息参数会在断言失败时显示。因此我们可以利用该参数，让错误信息更易被我们所理解。</p>
<p>我们能像下面那样向断言添加 <code>message</code> 参数：</p>
<pre><code>assert.equal(arr.length, 1, &apos;Array length was not 0&apos;);
</code></pre><p>如果你再次运行测试，那么自定义的信息会取代默认的信息而显示出来。</p>
<p>OK，让我们将 <code>1</code> 改回 <code>0</code>，确保测试通过。</p>
<h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><p>到目前为止，案例都是相当简单的。那么下面就让我们将学到的知识付诸实践，看看如何测试一段实际当中所用到的代码。</p>
<p>下面是一个将 CSS 类名添加到元素的函数。我们将该函数放进新文件 <code>js/className.js</code>。</p>
<pre><code>function addClass(el, newClass) {
  if(el.className.indexOf(newClass) === -1) {
    el.className += newClass;
  }
}
</code></pre><p>当元素的 <code>className</code> 属性不含有新类名时，才向元素添加新类名——毕竟谁想看到 <code>&lt;div class=&quot;hello hello hello hello&quot;&gt;</code>。</p>
<p>在最好的情况下，我们要在编写代码前先为该函数编写测试。但 <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="external">测试驱动开发（test-driven development）</a> 是一个复杂的主题，因此我们现在仅专注于编写测试。</p>
<p>开始前，让我们重温单元测试的基本思想：赋予函数特定的输入，然后验证函数的行为是否符合预期。所以，该函数的输入和行为是什么呢？</p>
<p>给定一个元素和一个类名：</p>
<ul>
<li>若元素的 <code>className</code> 属性未含有该类名，则应添加。</li>
<li>若元素的 <code>className</code> 属性已含有该类名，则不应添加。</li>
</ul>
<p>将这两种情况转化为两个测试。在 <code>test</code> 目录下，创建新文件 <code>classNameTest.js</code> 并添加以下内容： </p>
<pre><code>describe(&apos;addClass&apos;, function() {
  it(&apos;should add class to element&apos;);
  it(&apos;should not add a class which already exists&apos;);
});
</code></pre><p>我们也可以将措词稍微地改成“it should do X”，虽然可读性更强一点，但本质上仍然与我们上述语句的可读性一致。根据原来的措词联想到相应的测试也不难。</p>
<p>等等，测试函数跑去哪了？当我们省略 <code>it</code> 的第二个参数，Mocha 会在测试结果中标记这些测试为待测试项。这让设置多个测试变得更方便——就像一个备忘录，列着打算编写的测试。</p>
<p>接着实现第一个测试。</p>
<pre><code>describe(&apos;addClass&apos;, function() {
  it(&apos;should add class to element&apos;, function() {
    var element = { className: &apos;&apos; };

    addClass(element, &apos;test-class&apos;);

    assert.equal(element.className, &apos;test-class&apos;);
  });

  it(&apos;should not add a class which already exists&apos;);
});
</code></pre><p>在该测试中，我们创建了 <code>element</code> 变量，并将其与字符串 <code>test-class</code>（作为元素的新类名） 作为参数传入 <code>addClass</code> 函数。然后，使用断言检查该类名是否已包含在值（element.className）里。</p>
<p>再一次，我们从初始的想法出发——给定一个元素和一个类名，将类名添加到 class 列表，然后以简单的方式将其转化为代码。</p>
<p>尽管该函数（addClass）是针对 DOM 元素的，但我们在此使用了一个简单JS对象（plain JS object，根据 jQuery 官方定义：含有零个或多个键值对的对象）。是的，有时我们可以利用 JavaScript 的动态特性，以上述方式简化测试。如果不这样做，我们就要创建一个实际的元素，这无疑会使测试代码变复杂。当然，这还有另一个好处，由于没使用 DOM，该测试也能在 Node.js 运行。</p>
<h3 id="在浏览器运行测试"><a href="#在浏览器运行测试" class="headerlink" title="在浏览器运行测试"></a>在浏览器运行测试</h3><p>为了在浏览器运行测试，你需要在运行器添加 <code>className.js</code> 和 <code>classNameTest.js</code>。</p>
<pre><code>&lt;!-- load code you want to test here --&gt;
&lt;script src=&quot;js/className.js&quot;&gt;&lt;/script&gt;

&lt;!-- load your test files here --&gt;
&lt;script src=&quot;test/classNameTest.js&quot;&gt;&lt;/script&gt;
</code></pre><p>正如 CodePen 所显示：一个测试通过，而另一个显示待测试。注意：为了让代码运行在 CodePen 环境下，代码需稍作调整。</p>
<iframe height="268" scrolling="no" src="//codepen.io/SitePoint/embed/XXzXLX/?height=268&theme-id=0&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SitePoint/pen/XXzXLX/" target="_blank" rel="external">Unit Testing with Mocha (1)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p></p><p data-height="268" data-theme-id="0" data-slug-hash="XXzXLX" data-default-tab="result" data-user="SitePoint" class="codepen">See the Pen <a href="http://codepen.io/SitePoint/pen/XXzXLX/" target="_blank" rel="external">Unit Testing with Mocha (1)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>接着，实现第二个测试…</p>
<pre><code>it(&apos;should not add a class which already exists&apos;, function() {
  var element = { className: &apos;exists&apos; };

  addClass(element, &apos;exists&apos;);

  var numClasses = element.className.split(&apos; &apos;).length;
  assert.equal(numClasses, 1);
});
</code></pre><p>经常运行测试是一种好习惯。因此，让我们现在运行测试看看会发生什么。</p>
<p>不出所料，两者均通过。</p>
<p>下面是在 CodePen 实现第二个测试的例子。</p>
<iframe height="268" scrolling="no" src="//codepen.io/SitePoint/embed/pgdyzz/?height=268&theme-id=0&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SitePoint/pen/pgdyzz/" target="_blank" rel="external">Unit Testing with Mocha (2)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p></p><p data-height="268" data-theme-id="0" data-slug-hash="pgdyzz" data-default-tab="result" data-user="SitePoint" class="codepen">See the Pen <a href="http://codepen.io/SitePoint/pen/pgdyzz/" target="_blank" rel="external">Unit Testing with Mocha (2)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>


<p>但事情没那么简单！该函数的第三种情况我们并没有考虑到，这也是该函数的一个非常严重的 Bug。虽然该函数只有三行代码，但你注意到了吗？</p>
<p>下面为第三种情况编写多一个案例，让这个 Bug 暴露出来。</p>
<pre><code>it(&apos;should append new class after existing one&apos;, function() {
  var element = { className: &apos;exists&apos; };

  addClass(element, &apos;new-class&apos;);

  var classes = element.className.split(&apos; &apos;);
  assert.equal(classes[1], &apos;new-class&apos;);
});
</code></pre><p>你可在下面的 CodePen 看到，这次测试失败了。导致该问题的原因很简单：元素上的 CSS 类名应以空格隔开。然而，现在实现的 <code>addClass</code> 并未加空格！</p>
<iframe height="268" scrolling="no" src="//codepen.io/SitePoint/embed/oboxve/?height=268&theme-id=0&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SitePoint/pen/oboxve/" target="_blank" rel="external">Unit Testing with Mocha (3)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p></p><p data-height="268" data-theme-id="0" data-slug-hash="oboxve" data-default-tab="result" data-user="SitePoint" class="codepen">See the Pen <a href="http://codepen.io/SitePoint/pen/oboxve/" target="_blank" rel="external">Unit Testing with Mocha (3)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>修复该函数，让测试通过。</p>
<pre><code>function addClass(el, newClass) {
  if(el.className.indexOf(newClass) !== -1) {
    return;
  }

  if(el.className !== &apos;&apos;) {
    //ensure class names are separated by a space
    newClass = &apos; &apos; + newClass;
  }

  el.className += newClass;
}
</code></pre><p>修复后，最终在 CodePen 测试通过。</p>
<iframe height="268" scrolling="no" src="//codepen.io/SitePoint/embed/BjmKBG/?height=268&theme-id=0&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SitePoint/pen/BjmKBG/" target="_blank" rel="external">Unit Testing with Mocha (4)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p></p><p data-height="268" data-theme-id="0" data-slug-hash="BjmKBG" data-default-tab="result" data-user="SitePoint" class="codepen">See the Pen <a href="http://codepen.io/SitePoint/pen/BjmKBG/" target="_blank" rel="external">Unit Testing with Mocha (4)</a> by SitePoint (<a href="http://codepen.io/SitePoint" target="_blank" rel="external">@SitePoint</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<h3 id="在-Node-运行测试"><a href="#在-Node-运行测试" class="headerlink" title="在 Node 运行测试"></a>在 Node 运行测试</h3><p>在 Node，由于 <code>className.js</code> 和 <code>classNameTest.js</code> 在不同文件下，我们需要一种方式将一个文件导出到另一个文件内。而标准的方式是通过 <code>module.exports</code>。如果你需要复习相关知识，你可以看看 <a href="http://www.sitepoint.com/understanding-module-exports-exports-node-js/" target="_blank" rel="external">Understanding module.exports and exports in Node.js</a>。</p>
<p>代码本质不变，只是结构稍微不同：</p>
<pre><code>// className.js

module.exports = {
  addClass: function(el, newClass) {
    if(el.className.indexOf(newClass) !== -1) {
      return;
    }

    if(el.className !== &apos;&apos;) {
      //ensure class names are separated by a space
      newClass = &apos; &apos; + newClass;
    }

    el.className += newClass;
  }
}


// classNameTest.js

var chai = require(&apos;chai&apos;);
var assert = chai.assert;

var className = require(&apos;../js/className.js&apos;);
var addClass = className.addClass;

// The rest of the file remains the same
// 文件其它部分保持不变
describe(&apos;addClass&apos;, function() {
  ...
});
</code></pre><p>正如你所看到的，测试通过。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/3running-mocha-in-the-terminal.png" alt="Mocha terminal output - 4 tests passing"></p>
<h2 id="下一步呢？"><a href="#下一步呢？" class="headerlink" title="下一步呢？"></a>下一步呢？</h2><p>正如你所看到的，测试并不复杂或困难。与编写 JavaScript 应用的其它方面一样，有一些重复的基本模式。一旦你熟悉这些，你可以一次又一次使用它们。</p>
<p>但这些只是单元测试的皮毛，还有很多相关知识需要学习。</p>
<ul>
<li>测试更复杂的系统</li>
<li>如何处理Ajax、数据库和其它“外部”的东西。</li>
<li>测试驱动开发</li>
</ul>
<p>如果你想继续学习更多相关知识，可看看我编写的 <a href="http://codeutopia.net/blog/h/subscribe" target="_blank" rel="external">免费的 JavaScript 单元测试快速入门系列</a>。如果你觉得本文有用，你更应该点击 <a href="http://codeutopia.net/blog/h/subscribe" target="_blank" rel="external">这里</a> 看看。</p>
<hr>
<p>本文由 <a href="http://web.jobbole.com/" target="_blank" rel="external">伯乐在线</a> - <a href="http://www.jobbole.com/members/q574805242" target="_blank" rel="external">刘健超-J.c</a> 翻译，等待校稿。未经许可，禁止转载！ </p>
<p>英文出处：<a href="http://www.sitepoint.com/unit-test-javascript-mocha-chai/" target="_blank" rel="external">Unit Test Your JavaScript Using Mocha and Chai</a>。欢迎加入翻译组。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你曾试过修改代码后，导致其它地方出现问题吗？&lt;/p&gt;
&lt;p&gt;也许有大多数人试过。因为这是几乎不可避免的，特别在庞大的代码面前。由于代码间可能是环环相扣的，改变一处会影响另一处。&lt;/p&gt;
&lt;p&gt;但如果这种情况不会发生呢？如果你有一种方法能知道改变后会出现的结果呢？这无疑是极好的。因为修改代码后无需担心会破坏什么东西，从而程序出现 bug 的概率更低，在 debug 上花费时间更少。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="BDD" scheme="http://yoursite.com/tags/BDD/"/>
    
      <category term="chai" scheme="http://yoursite.com/tags/chai/"/>
    
      <category term="mocha" scheme="http://yoursite.com/tags/mocha/"/>
    
      <category term="tdd" scheme="http://yoursite.com/tags/tdd/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript（ES5）的面向对象精要》读书笔记</title>
    <link href="http://yoursite.com/2016/01/20/2016-1-19-object-oriented-programming-notes/"/>
    <id>http://yoursite.com/2016/01/20/2016-1-19-object-oriented-programming-notes/</id>
    <published>2016-01-20T02:04:36.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年1月16日-17日两天看完了《JavaScript面向对象精要》（参加异步社区的活动送的），这本书虽然不够100页，但都是精华，不愧是《JavaScript高级程序设计》作者 Nicholas C.Zakas 的最新力作。</p>
<a id="more"></a>
<p>下面是我的读书笔记（ES5）：</p>
<h2 id="原始类型和引用类型"><a href="#原始类型和引用类型" class="headerlink" title="原始类型和引用类型"></a>原始类型和引用类型</h2><h3 id="什么是类型"><a href="#什么是类型" class="headerlink" title="什么是类型"></a>什么是类型</h3><p><strong>原始类型</strong> 保存为简单数据值。<br><strong>引用类型</strong> 保存为对象，其本质是指向内存位置的引用。</p>
<p>为了让开发者能够把原始类型和引用类型按相同的方式处理，JavaScript花费了很大的努力来保证语言的一致性。</p>
<p>其他编程语言用栈存原始类型，用对存储引用类型。而JavaScript则完全不同：它使用一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。</p>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>原始类型代表照原样保存的一些简单数据。<br>JavaScript共有 <strong>5</strong> 种原始类型：</p>
<ul>
<li>boolean    布尔，值为 <code>true</code> or <code>false</code></li>
<li>number     数字，值为任何整型或浮点数值</li>
<li>string     字符串，值为由单引号或双引号括住的单个字符或连续字符</li>
<li>null       空类型，仅有一个值：null</li>
<li>undefined  未定义，只有一个值：undefined（undefined会被赋给一个还没有初始化的变量）</li>
</ul>
<p>JavaScript和许多其他语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。</p>
<pre><code>var color1 = &quot;red&quot;;
var color2 = color1;

console.log(color1); // &quot;red&quot;
console.log(color2); // &quot;red&quot;

color1 = &quot;blue&quot;;

console.log(color1); // &quot;blue&quot;
console.log(color2); // &quot;red&quot;
</code></pre><h4 id="鉴别原始类型"><a href="#鉴别原始类型" class="headerlink" title="鉴别原始类型"></a>鉴别原始类型</h4><p>鉴别原始类型的最佳方式是使用 <code>typeof</code> 操作符。</p>
<pre><code>console.log(typeof &quot;Nicholas&quot;); // &quot;string&quot;
console.log(typeof 10);         // &quot;number&quot;
console.log(typeof true);       // &quot;boolean&quot;
console.log(typeof undefined);  // &quot;undefined&quot;
</code></pre><p>至于空类型（null）则有些棘手。</p>
<pre><code>console.log(typeof null); // &quot;object&quot;
</code></pre><p>对于 typeof null，结果是”object”。（其实这已被设计和维护JavaScript的委员会TC39认定是一个错误。在逻辑上，你可以认为 <code>null</code> 是一个空的对象指针，所以结果为”object”，但这还是很令人困惑。）</p>
<p>判断一个值是否为空类型（null）的最佳方式是直接和 <code>null</code> 比较：</p>
<pre><code>console.log(value === null); // true or false
</code></pre><blockquote>
<p><strong>注意：以上这段代码使用了三等号（全等===）</strong>，因为三等号（全等）不会将变量强制转换为另一种类型。</p>
</blockquote>
<pre><code>console.log(&quot;5&quot; == 5); // true
console.log(&quot;5&quot; === 5); // false

console.log(undefined == null); // true
console.log(undefined === null); // false
</code></pre><h4 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h4><p>虽然字符串、数字和布尔值是原始类型，但是它们也拥有方法（null和undefined没有方法）。</p>
<pre><code>var name = &quot;Nicholas&quot;;
var lowercaseName = name.toLowerCase(); // 转为小写

var count = 10;
var fixedCount = count.toFixed(2); // 转为10.00

var flag = true;
var stringFlag = flag.toString(); // 转为&quot;true&quot;

console.log(&quot;YIBU&quot;.charAt(0)); // 输出&quot;Y&quot;
</code></pre><blockquote>
<p>尽管原始类型拥有方法，但它们不是对象。JavaScript使它们看上去像对象一样，以此来提高语言上的一致性体验。</p>
</blockquote>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型是指JavaScript中的对象，同时也是你在该语言中能找到最接近类的东西。<br>引用值是引用类型的实例，也是对象的同义词（后面将用对象指代引用值）。对象是属性的无序列表。属性包含键（始终是字符串）和值。如果一个属性的值是函数，它就被称为方法。除了函数可以运行以外，一个包含数组的属性和一个包含函数的属性没有什么区别。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>有时候，把JavaScript对象想象成哈希表可以帮助你更好地理解对象结构。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/Object_hash.jpg" alt="Object"></p>
<p>JavaScript 有好几种方法可以创建对象，或者说实例化对象。第一种是使用 <code>new</code> 操作符和构造函数。<br>构造函数就是通过 <code>new</code> 操作符来创建对象的函数——任何函数都可以是构造函数。根据命名规范，JavaScript中的构造函数用<strong>首字母大写</strong>来跟非构造函数进行区分。</p>
<pre><code>var object = new Object();
</code></pre><p>因为引用类型不再变量中直接保存对象，所以本例中的 <code>object</code> 变量实际上并<strong>不包含对象的实例，而是一个指向内存中实际对象所在位置的指针（或者说引用）</strong>。这是对象和原始值之间的一个基本差别，原始值是直接保存在变量中。</p>
<p>当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。这意味着，将一个变量赋值给另外一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的同一个对象。</p>
<pre><code>var obj1 = new Object();
var obj2 = obj1;
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/copy_obj.jpg" alt="copy_obj"></p>
<h4 id="对象引用解除"><a href="#对象引用解除" class="headerlink" title="对象引用解除"></a>对象引用解除</h4><p>JavaScript语言有垃圾收集的功能，因此当你使用引用类型时无需担心内存分配。<strong>但最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为 <code>null</code>。</strong></p>
<pre><code>var obj1 = new Object();
// dosomething
obj1 = null; // dereference
</code></pre><h4 id="添加删除属性"><a href="#添加删除属性" class="headerlink" title="添加删除属性"></a>添加删除属性</h4><p>在JavaScript中，你可以随时添加和删除其属性。</p>
<pre><code>var obj1 = new Object();
var obj2 = obj1;

obj1.myCustomProperty = &quot;Awsome!&quot;;
console.log(obj2.myCustomProperty); // &quot;Awsome!&quot; 因为obj1和obj2指向同一个对象。
</code></pre><h3 id="内建类型实例化"><a href="#内建类型实例化" class="headerlink" title="内建类型实例化"></a>内建类型实例化</h3><p>内建类型如下：</p>
<ul>
<li>Array       数组类型，以数字为索引的一组值的有序列表</li>
<li>Date        日期和时间类型</li>
<li>Error       运行期错误类型</li>
<li>Function    函数类型</li>
<li>Object      通用对象类型</li>
<li>RegExp      正则表达式类型    </li>
</ul>
<p>可使用 <code>new</code> 来实例化每一个内建引用类型：</p>
<pre><code>var items = new Array();
var new = new Date();
var error = new Error(&quot;Something bad happened.&quot;);
var func = new Function(&quot;console.log(&apos;HI&apos;);&quot;);
var object = new Object();
var re = new RegExp();
</code></pre><h4 id="字面形式"><a href="#字面形式" class="headerlink" title="字面形式"></a>字面形式</h4><p>内建引用类型有字面形式。字面形式允许你在不需要使用 <code>new</code> 操作符和构造函数显示创建对象的情况下生成引用值。属性的<strong>键</strong>可以是标识符或字符串（若含有空格或其他特殊字符）</p>
<pre><code>var book = {
    name: &quot;Book_name&quot;,
    year: 2016
}
</code></pre><p>上面代码与下面这段代码等价：</p>
<pre><code>var book = new Object();
book.name = &quot;Book_name&quot;;
book.year = 2016;
</code></pre><blockquote>
<p>虽然使用字面形式并没有调用 new Object()，但是JavaScript引擎背后做的工作和 new Object()一样，除了没有调用构造函数。其他引用类型的字面形式也是如此。</p>
</blockquote>
<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>可通过 <code>.</code> 和 <code>中括号</code> 访问对象的属性。<br>中括号<code>[]</code>在需要动态决定访问哪个属性时，特别有用。因为你可以用<strong>变量</strong>而不是字符串字面形式来指定访问的属性。</p>
<h3 id="鉴别引用类型"><a href="#鉴别引用类型" class="headerlink" title="鉴别引用类型"></a>鉴别引用类型</h3><p>函数是最容易鉴别的引用类型，因为对函数使用 <code>typeof</code> 操作符时，返回”function”。</p>
<pre><code>function reflect(value){
    return value;
}
console.log(typeof reflect); // &quot;function&quot;
</code></pre><p>对其他引用类型的鉴别则较为棘手，因为对于所有非函数的引用类型，<code>typeof</code> 返回 <code>object</code>。为了更方便地鉴别引用类型，可以使用 JavaScript 的 <code>instanceof</code> 操作符。</p>
<pre><code>var items = [];
var obj = {};
function reflect(value){
    return value;
}

console.log(items instanceof Array); // true;
console.log(obj instanceof Object); // true;
console.log(reflect instanceof Function); // true;
</code></pre><p><code>instanceof</code> 操作符可鉴别继承类型。这意味着所有对象都是 <code>Oject</code> 的实例，因为所有引用类型都继承自 <code>Object</code>。</p>
<blockquote>
<p>虽然 instanceof 可以鉴别对象类型（如数组），但是有一个列外。JavaScript 的值可以在同一个网页的不用框架之间传来传去。由于每个网页拥有它自己的全局上下文——Object、Array以及其他内建类型的版本。所以当你把一个对象（如数组）从一个框架传到另外一个框架时，instanceof就无法识别它。</p>
</blockquote>
<h3 id="原始封装类型"><a href="#原始封装类型" class="headerlink" title="原始封装类型"></a>原始封装类型</h3><p>原始封装类型有 <code>3</code> 种：String、Number 和 Boolean。<br>当读取字符串、数字或布尔值时，原始封装类型将被自动创建。</p>
<pre><code>var name = &quot;Nicholas&quot;;
var firstChar = name.charAt(0); // &quot;N&quot;
</code></pre><p>这在背后发生的事情如下：</p>
<pre><code>var name = &quot;Nichola&quot;;
var temp = new String(name);
var firstChar = temp.charAt(0);
temp = null;
</code></pre><p>由于第二行把字符串当成对象使用，JavaScript引擎创建了一个字符串的实体让 <code>charAt(0)</code> 可以工作。字符串对象的存在仅用于该语句并在随后销毁（一种被称为自动打包的过程）。为了测试这一点，试着给字符串添加一个属性看看它是不是对象。</p>
<pre><code>var name = &quot;Nicholas&quot;;
name.last = &quot;Zakas&quot;;

console.log(name.last); // undefined;
</code></pre><p>下面是在JavaScript引擎中实际发生的事情：</p>
<pre><code>var name = &quot;Nicholas&quot;;
var temp = new String(name);
temp.last = &quot;Zakas&quot;;
temp = null; // temporary object destroyed

var temp = new String(name);
console.log(temp.last);
temp = null;
</code></pre><p>新属性 <code>last</code> 实际上是在一个立刻就被销毁的临时对象上而不是字符串上添加。之后当你试图访问该属性时，另一个不同的临时对象被创建，而新属性并不存在。</p>
<p>虽然原始封装类型会被自动创建，在这些值上进行 <code>instanceof</code> 检查对应类型的返回值却是 <code>false</code>。<br>这是因为<strong>临时对象仅在值被读取时创建</strong>。<code>instanceof</code> 操作符并没有真的读取任何东西，也就没有临时对象的创建。</p>
<p>当然你也可以手动创建原始封装类型。</p>
<pre><code>var str = new String(&quot;me&quot;);
str.age = 18;

console.log(typeof str); // object
console.log(str.age); // 18
</code></pre><p>如你所见，手动创建原始封装类型实际会创建出一个 <code>object</code>。这意味着 <code>typeof</code> 无法鉴别出你实际保存的数据的类型。</p>
<p>另外，手动创建原始封装类型和使用原始值是有一定区别的。所以尽量避免使用。</p>
<pre><code>var found = new Boolean(false);
if(found){
    console.log(&quot;Found&quot;); // 执行到了，尽管对象的值为 false
}
</code></pre><p>这是因为一个对象(如 <code>{}</code> )在条件判断语句中总被认为是 <code>true</code>;</p>
<blockquote>
<p>MDN:Any object whose value is not undefined or null, including a Boolean oject whose value is false, evaluates to true when passed to a conditional statement.</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一章的东西都是我们一些比较熟悉的知识。但是也有一些需要注意的地方：</p>
<ul>
<li>正确区分原始类型和引用类型</li>
<li>对于 <code>5</code> 种原始类型都可以用typeof来鉴别，而空类型必须直接跟 <code>null</code> 进行全等比较。</li>
<li>函数也是对象，可用 <code>typeof</code> 鉴别。其它引用类型，可用 <code>instanceof</code> 和一个构造函数来鉴别。（当然可以用  <code>Object.prototype.toString.call()</code> 鉴别，它会返回[object Array]之类的）。</li>
<li>为了让原始类型看上去更像引用类型，JavaScript提供了 <code>3</code> 种封装类型。JavaScript会在背后创建这些对象使得你能够像使用普通对象那样使用原始值。但这些临时对象在使用它们的语句结束时就立刻被销毁。虽然可手动创建，但不建议。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也是对象，使对象不同于其它对象的决定性特点是函数存在一个被称为 <code>[[Call]]</code> 的内部属性。<br><strong>内部属性无法通过代码访问而是定义了代码执行时的行为</strong>。ECMAScript为JavaScript的对象定义了多种内部属性，这些<strong>内部属性都用双重中括号来标注</strong>。</p>
<p><strong>[[Call]]属性是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript 定义typeof操作符对任何具有[[Call]]属性的对象返回”function”</strong>。过去因某些浏览器曾在正则表达式中包含 <code>[[Call]]</code> 属性，导致正则表达式被错误鉴别为函数。</p>
<h3 id="声明还是表达式"><a href="#声明还是表达式" class="headerlink" title="声明还是表达式"></a>声明还是表达式</h3><p>两者的一个重要区别是：函数声明会被提升至上下文（要么是该函数被声明时所在的函数范围，要么是全局范围）的顶部。</p>
<h3 id="函数就是值"><a href="#函数就是值" class="headerlink" title="函数就是值"></a>函数就是值</h3><p>可以像使用对象一样使用函数（因为函数本来就是对象，Function构造函数更加容易说明）。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>函数参数保存在类数组对象 <code>argument</code> （<code>Array.isArray(arguments)</code> 返回 <code>false</code>）中。可以接收任意数量的参数。<br>函数的 <code>length</code> 属性表明其期望的参数个数。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>大多数面向对象语言支持函数重载，它能让一个函数具有多个签名。函数签名由函数的名字、参数的个数及其类型组成。<br>而JavaScript可以接收任意数量的参数且参数类型完全没有限制。这说明JavaScript函数根本就没有签名，因此也不存在重载。</p>
<pre><code>function sayMessage(message){
    console.log(message);
}
function sayMessage(){
    console.log(&quot;Default Message&quot;);
}

sayMessage(&quot;Hello!&quot;); // 输出&quot;Default Message&quot;;
</code></pre><p>在Javscript里，当你试图定义多个同名的函数时，只有最后的定义有效，之前的函数声明被完全删除（函数也是对象，变量只是存指针)。</p>
<pre><code>var sayMessage = new Function(&quot;message&quot;, &quot;console.log(message)&quot;);
var sayMessage = new Function(&quot;console.log(\&quot;Default Message\&quot;);&quot;);

sayMessage(&quot;Hello!&quot;); 
</code></pre><p>当然，你可以根据传入参数的数量来模仿重载。</p>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>对象的值是函数，则该属性被称为方法。</p>
<h4 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h4><p>JavaScript 所有的函数作用域内都有一个 <code>this</code> 对象代表调用该函数的对象。在全局作用域中，<code>this</code> 代表全局对象（浏览器里的window）。当一个函数作为对象的方法调用时，默认 <code>this</code> 的值等于该对象。<br><strong>this在函数调用时才被设置。</strong></p>
<pre><code>function sayNameForAll(){
    console.log(this.name);
}

var person1 = {
    name: &quot;Nicholas&quot;,
    sayName: sayNameForAll
}

var name = &quot;Jack&quot;;

person1.sayName(); // 输出 &quot;Nicholas&quot;
sayNameforAll(); // 输出 &quot;Jack&quot;
</code></pre><h4 id="改变this"><a href="#改变this" class="headerlink" title="改变this"></a>改变this</h4><p>有 <code>3</code> 种函数方法运行你改变 <code>this</code> 值。</p>
<ol>
<li>fun.call(thisArg[, arg1[, arg2[, …]]]);</li>
<li>fun.apply(thisArg, [argsArray]);</li>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
</ol>
<p>使用 <code>call</code> 或 <code>apply</code> 方法，就不需要将函数加入每个对象——你显示地指定了 <code>this</code> 的值而不是让JavaScript引擎自动指定。</p>
<p><code>call</code> 与 <code>apply</code> 的不同地方是，<code>call</code> 需要把所有参数一个个列出来，而 <code>apply</code> 的参数需要一个数组或者类似数组的对象（如 <code>arguments</code> 对象）。</p>
<p><code>bind</code> 是ECMAScript 5 新增的，它会创建一个新函数返回。其参数与 <code>call</code> 类似，而且其所有参数代表需要被<strong>永久</strong>设置在新函数中的命名参数（绑定了的参数（没绑定的参数依然可以传入），就算调用时再传入其它参数，也不会影响这些绑定的参数）。</p>
<pre><code>function sayNameForAll(label){
    console.log(label + &quot;:&quot; + this.name);
}
var person = {
    name: &quot;Nicholas&quot;
}

var sayNameForPerson = sayNameForAll.bind(person);
sayNameForPerson(&quot;Person&quot;); // 输出&quot;Person:Nicholas&quot;

var sayName = sayNameForAll.bind(person, &quot;Jc&quot;);

sayName(&quot;change&quot;); // 输出&quot;Jc:Nicholas&quot; 因为绑定的形参，会忽略调用时再传入参数
</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>函数也是对象，所以它可以被访问、复制和覆盖。</li>
<li>函数与其他对象最大的区别在于它们有一个特殊的内部属性 <code>[[Call]]</code>，包含了该函数的执行指令。</li>
<li>函数声明会被提升至上下文的顶部。</li>
<li>函数是对象，所以存在一个 <code>Function</code> 构造函数。但这会使你的代码难以理解和调试，除非函数的真实形式要直到运行时才能确定的时候才会利用它。</li>
</ul>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>JavaScript中的对象是动态的，可在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象。</p>
<h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><p>当一个属性第一次被添加到对象时，JavaScript会在对象上调用一个名为 <code>[[Put]]</code> 的内部方法。<code>[[Put]]</code> 方法会在对象上创建一个新节点来保存属性。<br>当一个已有的属性被赋予一个新值时，调用的是一个名为 <code>[[Set]]</code> 的方法。</p>
<h3 id="属性探测"><a href="#属性探测" class="headerlink" title="属性探测"></a>属性探测</h3><p>检查对象是否已有一个属性。JavaScript开发新手错误地使用以下模式检测属性是否存在。</p>
<pre><code>if(person.age){
    // do something with ag
}
</code></pre><p>上面的问题在于JavaScript的类型强制会影响该模式的输出结果。<br>当if判断中的值如下时，会判断为<strong>真</strong>：</p>
<ul>
<li>对象</li>
<li>非空字符串</li>
<li>非零</li>
<li>true</li>
</ul>
<p>当if判断中的值如下时，会判断为<strong>假</strong>：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>0</li>
<li>false</li>
<li>NaN</li>
<li>空字符串</li>
</ul>
<p>因此判断属性是否存在的方法是使用 <code>in</code> 操作符。<br><code>in</code> 操作符会检查<strong>自有属性和原型属性</strong>。<br>所有的对象都拥有的 <code>hasOwnProperty()</code> 方法（其实是 <code>Object.prototype</code> 原型对象的），该方法在给定的属性存在且为<strong>自有属性</strong>时返回 <code>true</code>。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

console.log(&quot;name&quot; in person); // true
console.log(person.hasOwnpropert(&quot;name&quot;)); // true

console.log(&quot;toString&quot; in person); // true
console.log(person.hasOwnproperty(&quot;toString&quot;)); // false
</code></pre><h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>设置一个属性的值为 <code>null</code> 并不能从对象中彻底移除那个属性，这只是调用 <code>[[Set]]</code> 将 <code>null</code> 值替换了该属性原来的值而已。<br><code>delete</code> 操作符针对单个对象属性调用名为 <code>[[Delete]]</code> 的内部方法。删除成功时，返回 <code>true</code>。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

person.name = null;
console.log(&quot;name&quot; in person); // true
delete person.name;
console.log(person.name); // undefined 访问一个不存在的属性将返回 undefined
console.log(&quot;name&quot; in person); // false
</code></pre><h3 id="属性枚举"><a href="#属性枚举" class="headerlink" title="属性枚举"></a>属性枚举</h3><p>所有人为添加的属性默认都是可枚举的。可枚举的内部特征 <code>[[Enumerable]]</code> 都被设置为 <code>true</code>。<br><code>for-in</code> 循环会枚举一个对象所有的可枚举属性。</p>
<blockquote>
<p>我的备注：在Chrome中，对象属性会按ASCII表排序，而不是定义时的顺序。</p>
</blockquote>
<p>ECMAScript 5 的 Object() 方法可以获取可枚举属性的名字的数组。</p>
<pre><code>var person = {
    name: &quot;Ljc&quot;,
    age: 18
}

Object.keys(person); // [&quot;name&quot;, &quot;age&quot;];
</code></pre><p><code>for-in</code> 与 <code>Object.keys()</code> 的一个区别是：前者也会遍历原型属性，而后者返回自有(实例)属性。</p>
<p>实际上，对象的大部分原生方法的 <code>[[Enumerable]]</code> 特征都被设置为 <code>false</code>。可用 <code>propertyIsEnumerable()</code> 方法检查一个属性是否为可枚举的。</p>
<pre><code>var arr = [&quot;abc&quot;, 2];
console.log(arr.propertyIsEnumerable(&quot;length&quot;)); // false
</code></pre><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>属性有两种类型：<strong>数据属性</strong>和<strong>访问器属性</strong>。<br>数据属性包含一个值。<code>[[Put]]</code> 方法的默认行为是创建<strong>数据属性</strong>。<br>访问器属性不包含值而是定义了一个当属性被读取时调用的函数（称为<code>getter</code>）和一个当属性被写入时调用的函数（称为<code>setter</code>）。访问器属性仅需要 <code>getter</code> 或 <code>setter</code> 两者中的任意一个，当然也可以两者。</p>
<pre><code>// 对象字面形式中定义访问器属性有特殊的语法：
var person = {
    _name: &quot;Nicholas&quot;,

    get name(){
        console.log(&quot;Reading name&quot;);
        return this._name;
    },
    set name(value){
        console.log(&quot;Setting name to %s&quot;, value);
        this._name = value;
    }
};

console.log(person.name); // &quot;Reading name&quot; 然后输出 &quot;Nicholas&quot;

person.name = &quot;Greg&quot;;
console.log(person.name); // &quot;Setting name to Greg&quot; 然后输出 &quot;Greg&quot;
</code></pre><blockquote>
<p>前置下划线_ 是一个约定俗成的命名规范，表示该属性是私有的，实际上它还是公开的。</p>
</blockquote>
<p>访问器就是定义了我们在对象读取或设置属性时，触发的动作（函数），<code>_name</code> 相当于一个内部变量。<br>当你希望赋值（读取）操作会触发一些行为，访问器就会非常有用。</p>
<blockquote>
<p>当只定义getter或setter其一时，该属性就会变成只读或只写。</p>
</blockquote>
<h3 id="属性特征"><a href="#属性特征" class="headerlink" title="属性特征"></a>属性特征</h3><p>在ECMAScript 5 之前没有办法指定一个属性是否可枚举。实际上根本没有方法访问属性的任何内部特征。为了改变这点，ECMAScript 5引入了多种方法来和属性特征值直接互动。</p>
<h4 id="通用特征"><a href="#通用特征" class="headerlink" title="通用特征"></a>通用特征</h4><p>数据属性和访问器属性均由以下两个属性特制：<br><code>[[Enumerable]]</code> 决定了是否可以遍历该属性；<br><code>[[Configurable]]</code> 决定了该属性是否可配置。</p>
<p>所有人为定义的属性默认都是可枚举、可配置的。</p>
<p>可以用 <code>Object.defineProperty()</code> 方法改变属性特征。<br>其参数有三：拥有该属性的对象、属性名和包含需要设置的特性的属性描述对象。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}
Object.defineProperty(person, &quot;name&quot;, {
    enumerable: false
})

console.log(&quot;name&quot; in person); // true
console.log(person.propertyIsEnumerable(&quot;name&quot;)); // false

var properties = Object.keys(person);
console.log(properties.length); // 0

Object.defineProperty(person, &quot;name&quot;,{
    configurable: false
})

delete person.name; // false
console.log(&quot;name&quot; in person); // true

Object.defineProperty(person, &quot;name&quot;,{ // error! 
// 在 chrome：Uncaught TypeError: Cannot redefine property: name
    configurable: true
})
</code></pre><blockquote>
<p>无法将一个不可配置的属性变为可配置，相反则可以。</p>
</blockquote>
<h4 id="数据属性特征"><a href="#数据属性特征" class="headerlink" title="数据属性特征"></a>数据属性特征</h4><p>数据属性额外拥有两个访问器属性不具备的特征。<br><code>[[Value]]</code> 包含属性的值(哪怕是函数)。<br><code>[[Writable]]</code> 布尔值，指示该属性是否可写入。所有属性默认都是可写的。</p>
<pre><code>var person = {};

Object.defineProperty(person, &quot;name&quot;, {
    value: &quot;Nicholas&quot;,
    enumerable: true,
    configurable: true,
    writable: true
})
</code></pre><p>在 <code>Object.defineProperty()</code> 被调用时，如果属性本来就有，则会按照新定义属性特征值去覆盖默认属性特征（<code>enumberable</code>、<code>configurable</code> 和 <code>writable</code> 均为 <code>true</code>）。但如果用该方法定义新的属性时，没有为所有的特征值指定一个值，则所有布尔值的特征值会被默认设置为 <code>false</code>。即不可枚举、不可配置、不可写的。<br>当你用 <code>Object.defineProperty()</code> 改变一个已有的属性时，只有你指定的特征会被改变。</p>
<h4 id="访问器属性特征"><a href="#访问器属性特征" class="headerlink" title="访问器属性特征"></a>访问器属性特征</h4><p>访问器属性额外拥有两个特征。<code>[[Get]]</code> 和 <code>[[Set]]</code>，内含 <code>getter</code> 和 <code>setter</code> 函数。<br>使用访问其属性特征比使用对象字面形式定义访问器属性的优势在于：可以为已有的对象定义这些属性。而后者只能在创建时定义访问器属性。</p>
<pre><code>var person = {
    _name: &quot;Nicholas&quot;
};

Object.defineProperty(person, &quot;name&quot;, {
    get: function(){
        return this._name;
    },
    set: function(value){
        this._name = value;
    },
    enumerable: true,
    configurable: true
})

for(var x in person){
    console.log(x); // _name \n(换行) name（访问器属性）
}
</code></pre><p>设置一个不可配置、不可枚举、不可以写的属性：</p>
<pre><code>Object.defineProperty(person, &quot;name&quot;,{
    get: function(){
        return this._name;
    }
})
</code></pre><p>对于一个新的访问器属性，没有显示设置值为布尔值的属性，默认为 <code>false</code>。</p>
<h4 id="定义多重属性"><a href="#定义多重属性" class="headerlink" title="定义多重属性"></a>定义多重属性</h4><p><code>Object.defineProperties()</code> 方法可以定义任意数量的属性，甚至可以同时改变已有的属性并创建新属性。</p>
<pre><code>var person = {};

Object.defineProperties(person, {

    // data property to store data
    _name: {
        value: &quot;Nicholas&quot;,
        enumerable: true,
        configurable: true,
        writable: true
    },

    // accessor property
    name: {
        get: function(){
            return this._name;
        },
        set: function(value){
            this._name = value;
        }
    }
})
</code></pre><h4 id="获取属性特征"><a href="#获取属性特征" class="headerlink" title="获取属性特征"></a>获取属性特征</h4><p><code>Object.getOwnPropertyDescriptor()</code> 方法。该方法接受两个参数：对象和属性名。如果属性存在，它会返回一个属性描述对象，内涵<code>4</code>个属性：<code>configurable</code> 和 <code>enumerable</code>，另外两个属性则根据属性类型决定。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

var descriptor = Object.getOwnPropertyDescriptor(person, &quot;name&quot;);

console.log(descriptor.enumerable); // true
console.log(descriptor.configuable); // true
console.log(descriptor.value); // &quot;Nicholas&quot;
console.log(descriptor.wirtable); // true
</code></pre><h3 id="禁止修改对象"><a href="#禁止修改对象" class="headerlink" title="禁止修改对象"></a>禁止修改对象</h3><p>对象和属性一样具有指导其行为的内部特性。其中， <code>[[Extensible]]</code> 是布尔值，指明该对象本身是否可以被修改。默认是 <code>true</code>。当值为 <code>false</code> 时，就能禁止新属性的添加。</p>
<blockquote>
<p>建议在 “use strict”; 严格模式下进行。</p>
</blockquote>
<h4 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h4><p><code>Object.preventExtensions()</code> 创建一个不可扩展的对象（即<strong>不能添加新属性</strong>）。<br><code>Object.isExtensible()</code> 检查 <code>[[Extensible]]</code> 的值。</p>
<pre><code>var person = {
    name: &quot;Nocholas&quot;
}

Object.preventExtensions(person);

person.sayName = function(){
    console.log(this.name)
}

console.log(&quot;sayName&quot; in person); // false
</code></pre><h4 id="对象封印"><a href="#对象封印" class="headerlink" title="对象封印"></a>对象封印</h4><p>一个被封印的对象是不可扩展的且其所有属性都是不可配置的（即不能添加、删除属性或修改其属性类型（从数据属性变成访问器属性或相反））。<strong>只能读写它的属性</strong>。<br>Object.seal()。调用此方法后，该对象的 <code>[[Extensible]]</code> 特征被设置为 <code>false</code>，其所有属性的 <code>[[configurable]]</code> 特征被设置为 <code>false</code>。<br><code>Object.isSealed()</code> 判断一个对象是否被封印。</p>
<h4 id="对象冻结"><a href="#对象冻结" class="headerlink" title="对象冻结"></a>对象冻结</h4><p>被冻结的对象不能添加或删除属性，不能修改属性类型，也不能写入任何数据属性。简言而之，被冻结对象是一个<strong>数据属性都为只读</strong>的被封印对象。<br><code>Object.freeze()</code> 冻结对象。<br><code>Object.isFrozen()</code> 判断对象是否被冻结。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>in</code> 操作符检测自有属性和原型属性，而 <code>hasOwnProperty()</code> 只检查自有属性。</li>
<li>用 <code>delete</code> 操作符删除对象属性。</li>
<li>属性有两种类型：数据属性和访问器属性。</li>
<li>所有属性都有一些相关特征。<code>[[Enumerable]]</code> 和 <code>[[Configurable]]</code> 的两种属性都有的，而数据属性还有 <code>[[Value]]</code> 和 <code>[[Writable]]</code>，访问器属性还有 <code>[[Get]]</code> 和 <code>[[Set]]</code>。可通过 <code>Object.defineProperty()</code> 和 <code>Object.defineProperties()</code> 改变这些特征。用 <code>Object.getOwnPropertyDescriptor()</code> 获取它们。</li>
<li>有 <code>3</code> 种可以锁定对象属性的方式。</li>
</ul>
<h2 id="构造函数和原型对象"><a href="#构造函数和原型对象" class="headerlink" title="构造函数和原型对象"></a>构造函数和原型对象</h2><p>由于JavaScript(ES5)缺乏类，但可用构造函数和原型对象给对象带来与类相似的功能。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数的函数名首字母应大写，以此区分其他函数。<br>当没有需要给构造函数传递参数，可忽略小括号：</p>
<pre><code>var Person = {
    // 故意留空
}
var person = new Person;
</code></pre><p>尽管 Person 构造函数没有显式返回任何东西，但 new 操作符会自动创建给定类型的对象并返回它们。</p>
<p>每个对象在创建时都自动拥有一个构造函数属性（constructor，其实是它们的原型对象上的属性），其中包含了一个指向其构造函数的引用。<br>通过对象字面量形式（{}）或Object构造函数创建出来的泛用对象，其构造函数属性（constructor）指向 Object；而那些通过自定义构造函数创建出来的对象，其构造函数属性指向创建它的构造函数。</p>
<pre><code>console.log(person.constructor === Person); // true
console.log(({}).constructor === Object); // true
console.log(([1,2,3]).constructor === Object); // true

// 证明 constructor是在原型对象上
console.log(person.hasOwnPrototype(&quot;constructor&quot;)); // false
console.log(person.constructor.prototype.hasOwnPrototype(&quot;constructor&quot;)); // true
</code></pre><p>尽管对象实例及其构造函数之间存在这样的关系，但还是建议使用 <code>instanceof</code> 来检查对象类型。这是因为构造函数属性可以被覆盖。（person.constructor = “”）。</p>
<p>当你调用构造函数时，new 会自动自动创建 this 对象，且其类型就是构造函数的类型（构造函数就好像类，相当于一种数据类型）。</p>
<blockquote>
<p>你也可以在构造函数中显式调用 return。如果返回值是一个对象，它会代替新创建的对象实例而返回，如果返回值是一个原始类型，它会被忽略，新创建的对象实例会被返回。</p>
</blockquote>
<p>始终确保要用 new 调用构造函数；否则，你就是在冒着改变全局对象的风险，而不是创建一个新的对象。</p>
<pre><code>var person = Person(&quot;Nicholas&quot;); // 缺少 new

console.log(person instanceof Person); // false
console.log(person); // undefined，因为没用 new，就相当于一个普通函数，默认返回 undefined
console.log(name); // &quot;Nicholas&quot;
</code></pre><p>当Person不是被 new 调用时，构造函数中的 this 对象等于全局 this 对象。</p>
<blockquote>
<p>在严格模式下，会报错。因为严格模式下，并没有为全局对象设置 this，this 保持为 undefined。</p>
</blockquote>
<p>以下代码，通过 new 实例化 100 个对象，则会有 100 个函数做相同的事。因此可用 <code>prototype</code> 共享同一个方法会更高效。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;,
    sayName: function(){
        console.log(this.name);
    }
}
</code></pre><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>可以把原型对象看作是对象的基类。几乎所有的函数（除了一些内建函数）都有一个名为 prototype 的属性，该属性是一个原型对象用来创建新的对象实例。所有创建的对象实例（同一构造函数，当然，可能访问上层的原型对象）<strong>共享</strong>该原型对象，且这些对象实例可以访问原型对象的属性。例如，hasOwnProperty()定义在 Object 的原型对象中，但却可被任何对象当作自己的属性访问。</p>
<pre><code>var book = {
    title : &quot;book_name&quot;
}

&quot;hasOwnProperty&quot; in book; // true
book.hasOwnProperty(&quot;hasOwnProperty&quot;); // false
Object.property.hasOwnProperty(&quot;hasOwnProperty&quot;); // true
</code></pre><p><strong>鉴别一个原型属性</strong></p>
<pre><code>function hasPrototypeProperty(object, name){
    return name in object &amp;&amp; !object.hasOwnProperty(name);
}
</code></pre><h4 id="Prototype-属性"><a href="#Prototype-属性" class="headerlink" title="[[Prototype]] 属性"></a>[[Prototype]] 属性</h4><p>一个对象实例通过内部属性 [[Prototype]] 跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针。当你用 new 创建一个新的对象时，构造函数的原型对象就会被赋给该对象的 [[Prototype]] 属性。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/prototype.jpg" alt="prototype"></p>
<p>由上图可以看出，[[Prototype]] 属性是如何让多个对象实例引用同一个原型对象来减少重复代码。</p>
<p>Object.getPrototypeOf() 方法可读取 [[Prototype]] 属性的值。</p>
<pre><code>var obj = {};
var prototype = Object.getPrototypeOf(Object);

console.log(prototype === Object.prototype); // true
</code></pre><blockquote>
<p>大部分JavaScript引擎在所有对象上都支持一个名为 <code>__proto__</code> 的属性。该属性使你可以直接读写 [[Prototype]] 属性。</p>
</blockquote>
<p>isPrototypeOf() 方法会检查某个对象是否是另一个对象的原型对象，该方法包含在所有对象中。</p>
<pre><code>var obj = {}
console.log(Object.prototype.isPrototypeOf(obj)); // true
</code></pre><p>当读取一个对象的属性时，JavaScript 引擎首先在该对象的自有属性查找属性名。如果找到则返回。否则会搜索 [[Prototype]] 中的对象，找到则返回，找不到则返回 undefined。</p>
<pre><code>var obj = new Object();
console.log(obj.toString()); // &quot;[object Object]&quot;

obj.toString = function(){
    return &quot;[object Custom]&quot;;
}
console.log(obj.toString()); // &quot;[object Custom]&quot;

delete obj.toString; // true
console.log(obj.toString()); // &quot;[object Object]&quot;

delete obj.toString; // 无效，delete不能删除一个对象从原型继承而来的属性
cconsole.log(obj.toString()); // // &quot;[object Object]&quot;
</code></pre><blockquote>
<p>MDN：delete 操作符不能删除的属性有：①显式声明的全局变量不能被删除,该属性不可配置（not configurable）； ②内置对象的内置属性不能被删除； ③不能删除一个对象从原型继承而来的属性(不过你可以从原型上直接删掉它)。</p>
</blockquote>
<p>一个重要概念：无法给一个对象的原型属性赋值。但我们可以通过 <code>obj.constructor.prototype.sayHi = function(){console.log(&quot;Hi!&quot;)}</code> 向原型对象添加属性。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E6%97%A0%E6%A0%87%E9%A2%98.jpg" alt="此处输入图片的描述"><br>（图片中间可以看出，为对象obj添加的toString属性代替了原型属性）</p>
<h4 id="在构造函数中使用原型对象"><a href="#在构造函数中使用原型对象" class="headerlink" title="在构造函数中使用原型对象"></a>在构造函数中使用原型对象</h4><h5 id="在原型对象上定义公用方法"><a href="#在原型对象上定义公用方法" class="headerlink" title="在原型对象上定义公用方法"></a>在原型对象上定义公用方法</h5><h5 id="在原型对象上定义数据类型"><a href="#在原型对象上定义数据类型" class="headerlink" title="在原型对象上定义数据类型"></a>在原型对象上定义数据类型</h5><p>开发中需要注意原型对象的数据是否共享。</p>
<pre><code>function Person(name){
    this.name = name
}

Person.prototype.sayName = function(){
    console.log(this.name);
}

Person.prototype.position = &quot;school&quot;;
Person.prototype.arr = [];

var person1 = new Person(&quot;xiaoming&quot;);
var person2 = new Person(&quot;Jc&quot;);

console.log(&quot;原始类型&quot;)
console.log(person1.position); // &quot;school&quot;
console.log(person2.position); // &quot;school&quot;

person1.position = 2; // 这是在当前属性设置position，引用类型同理
console.log(person1.hasOwnProperty(&quot;position&quot;)); // true
console.log(person2.hasOwnProperty(&quot;position&quot;)); // false

console.log(&quot;引用类型&quot;);
person1.arr.push(&quot;pizza&quot;); // 这是在原型对象上设置，而不是直接在对象上
person2.arr.push(&quot;quinoa&quot;); // 这是在原型对象上设置
console.log(person1.hasOwnProperty(&quot;arr&quot;)); // false
console.log(person2.hasOwnProperty(&quot;arr&quot;)); // false
console.log(person1.arr); // [&quot;pizza&quot;, &quot;quinoa&quot;]
console.log(person2.arr); // [&quot;pizza&quot;, &quot;quinoa&quot;]
</code></pre><p>上面是在原型对象上一一添加属性，下面一种更简洁的方式：以一个对象字面形式替换原型对象</p>
<pre><code>function Person(name){
    this.name
}

Person.prototype = {
    sayName: function(){
        console.log(this.name);
    },
    toString: function(){
        return &quot;[Person ]&quot; + this.name + &quot;]&quot;;
    }
}
</code></pre><p>这种方式有一种副作用：因为原型对象上具有一个 <code>constructor</code> 属性，这是其他对象实例所没有的。当一个函数被创建时，它的  <code>prototype</code> 属性也会被创建，且该原型对象的 <code>constructor</code> 属性指向该函数。当使用字面量时，因没显式设置原型对象的 <code>constructor</code> 属性，因此其 <code>constructor</code> 属性是指向 <code>Object</code> 的。<br>因此，当通过此方式设置原型对象时，可手动设置 <code>constructor</code> 属性。</p>
<pre><code>function Person(name){
    this.name
}

// 建议第一个属性就是设置其 constructor 属性。
Person.prototype = {
    constructor: Person,

    sayName: function(){
        console.log(this.name);
    },
    toString: function(){
        return &quot;[Person ]&quot; + this.name + &quot;]&quot;;
    }
}
</code></pre><p>构造函数、原型对象和对象实例之间的关系最有趣的一方面也许是：<br>对象实例和构造函数直接没有直接联系。（对象实例只有 <code>[[Prototype]]</code> 属性指向其相应的原型对象，而原型对象的 <code>constructor</code> 属性指向构造函数，而构造函数的 <code>prototype</code> 指向原型对象）<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/obj_constructor_prototype.jpg" alt="obj_constructor_prototype"></p>
<h4 id="改变原型对象"><a href="#改变原型对象" class="headerlink" title="改变原型对象"></a>改变原型对象</h4><p>因为每个对象的 <code>[[Prototype]]</code> 只是一个指向原型对象的指针，所以原型对象的改动会立刻反映到所有引用它的对象。<br>当对一个对象使用封印 <code>Object.seal()</code> 或冻结 <code>Object.freeze()</code> 时，完全是在操作对象的自有属性，但任然可以通过在原型对象上添加属性来扩展这些对象实例。</p>
<h4 id="内建对象（如Array、String）的原型对象"><a href="#内建对象（如Array、String）的原型对象" class="headerlink" title="内建对象（如Array、String）的原型对象"></a>内建对象（如Array、String）的原型对象</h4><pre><code>String.prototype.capitalize = function(){
    return this.charAt(0).toUpperCase() + this.substring(1);
}
</code></pre><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>构造函数就是用 <code>new</code> 操作符调用的普通函数。可用过 <code>instanceof</code> 操作符或直接访问 <code>constructor</code>(实际上是原型对象的属性) 来鉴别对象是被哪个构造函数所创建的。</li>
<li>每个函数都有一个 <code>prototype</code> 对象，它定义了该构造函数创建的所有对象共享的属性。而 <code>constructor</code> 属性实际上是定义在原型对象里，供所有对象实例共享。</li>
<li>每个对象实例都有 <code>[[Prototype]]</code> 属性，它是指向原型对象的指针。当访问对象的某个属性时，先从对象自身查找，找不到的话就到原型对象上找。</li>
<li>内建对象的原型对象也可被修改</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型对象链和-Object-prototype"><a href="#原型对象链和-Object-prototype" class="headerlink" title="原型对象链和 Object.prototype"></a>原型对象链和 Object.prototype</h3><p>JavaScript内建的继承方法被称为 原型对象链（又叫原型对象继承）。<br>原型对象的属性可经由对象实例访问，这就是继承的一种形式。对象实例继承了原型对象的属性，而原型对象也是一个对象，它也有自己的原型对象并继承其属性，以此类推。这就是原型对象链。</p>
<p>所有对象（包括自义定的）都自动继承自 <code>Object</code>，除非你另有指定。更确切地说，所有对象都继承自 <code>Object.prototype</code>。任何以对象字面量形式定义的对象，其 <code>[[Prototype]]</code> 的值都被设为 <code>Object.prototype</code>，这意味着它继承 <code>Object.prototype</code> 的属性。</p>
<h4 id="继承自-Object-prototype-的方法"><a href="#继承自-Object-prototype-的方法" class="headerlink" title="继承自 Object.prototype 的方法"></a>继承自 Object.prototype 的方法</h4><p>Object.prototype 一般有以下几个方法</p>
<ul>
<li>hasOwnProperty()             检测是否存在一个给定名字的自有属性</li>
<li>propertyIsemumerable()       检查一个自有属性是否可枚举</li>
<li>isPrototypeOf                检查一个对象是否是另一个对象的原型对象</li>
<li>valueOf()                    返回一个对象的值表达</li>
<li>toString()                   返回一个对象的字符串表达</li>
</ul>
<p>这 5 种方法经由继承出现在所有对象中。<br>因为所有对象都默认继承自 <code>Object.prototype</code>，所以改变它就会影响所有的对象。所以不建议。</p>
<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>对象继承是最简单的继承类型。你唯需要做的是指定哪个对象是新对象的 <code>[[Prototype]]</code>。对象字面量形式会隐式指定 <code>Object.prototype</code> 为其 <code>[[Protoype]]</code>。当然我们可以用 ES5 的 <code>Object.create()</code> 方法显式指定。该方法接受两个参数，第一个是新对象的的 <code>[[Prototype]]</code> 所指向的对象。第二个参数是可选的一个属性描述对象，其格式与 <code>Object.definePrototies()</code>一样。</p>
<pre><code>var obj = {
    name: &quot;Ljc&quot;
};

// 等同于
var obj = Object.create(Object.prototype, {
    name: {
        value: &quot;Ljc&quot;,
        configurable: true,
        enumberable: true,
        writable: true
    }
});
</code></pre><p>下面是继承其它对象：</p>
<pre><code>var person = {
    name: &quot;Jack&quot;,
    sayName: function(){
        console.log(this.name);
    }
}

var student = Object.create(person, {
    name:{
        value: &quot;Ljc&quot;
    },
    grade: {
        value: &quot;fourth year of university&quot;,
        enumerable: true,
        configurable: true,
        writable: true
    }
});

person.sayName(); // &quot;Jack&quot;
student.sayName(); // &quot;Ljc&quot;

console.log(person.hasOwnProperty(&quot;sayName&quot;)); // true
console.log(person.isPrototypeOf(student)); // true
console.log(student.hasOwnProperty(&quot;sayName&quot;)); // false
console.log(&quot;sayName&quot; in student); // true
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF.jpg" alt="对象继承"></p>
<p>当访问一个对象属性时，JavaScript引擎会执行一个搜索过程。如果在对象实例存在该自有属性，则返回，否则，根据其私有属性 <code>[[Protoype]]</code> 所指向的原型对象进行搜索，找到返回，否则继承上述操作，知道继承链末端。末端通常是 <code>Object.prototype</code>，其 <code>[[Prototype]]</code> 是 <code>null</code>。</p>
<p>当然，也可以用 <code>Object.create()</code> 常见一个 <code>[[Prototype]]</code> 为 <code>null</code> 的对象。</p>
<pre><code>var obj = Object.create(null);

console.log(&quot;toString&quot; in obj); // false
</code></pre><p>该对象是一个没有原型对象链的对象，即是一个没有预定义属性的白板。</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>JavaScript 中的对象继承也是构造函数继承的基础。<br>第四章提到，几乎所有函数都有 <code>prototype</code> 属性，它可被修改或替换。该 <code>prototype</code> 属性被自动设置为一个新的继承自 <code>Object.prototype</code> 的泛用对象，该对象(原型对象)有一个自有属性 <code>constructor</code>。实际上，JavaScript 引擎为你做了下面的事情。</p>
<pre><code>// 你写成这样
function YourConstructor(){
    // initialization
}

// JavaScript引擎在背后为你做了这些处理
YourConstructor.prototype = Object.create(Object.prototype, {
    constructor: {
        configurable: true,
        enumerable: true,
        value: YourConstructor,
        writable: true
    }
})
</code></pre><p>你不需要做额外的工作，这段代码帮你把构造函数的 <code>prototype</code> 属性设置为一个继承自 <code>Object.prototype</code> 的对象。这意味着 <code>YourConstructor</code> 创建出来的任何对象都继承自 <code>Object.prototype</code>。</p>
<p>由于 prototype 可写，你可以通过改变它来改变原型对象链。</p>
<blockquote>
<p>MDN:instanceof 运算符可以用来判断某个构造函数的 prototype 属性是否存在另外一个要检测对象的原型链上。</p>
</blockquote>
<pre><code>function Rectangle(length, width){
    this.length = length;
    this.width = width
}

Rectangle.prototype.getArea = function(){
    return this.length * this.width
}

Rectangle.prototype.toString = function(){
    return &quot;[Rectangle &quot; + this.length + &quot;x&quot; + this.width + &quot;]&quot;;
}


// inherits from Rectangle
function Square(size){
    this.length = size;
    this.width = size;
}

Square.prototype = new Rectangle(); // 尽管是 Square.prototype 是指向了 Rectangle 的对象实例，即Square的实例对象也能访问该实例的属性（如果你提前声明了该对象，且给该对象新增属性）。
// Square.prototype = Rectangle.prototype; // 这种实现没有上面这种好，因为Square.prototype 指向了 Rectangle.prototype，导致修改Square.prototype时，实际就是修改Rectangle.prototype。
console.log(Square.prototype.constructor); // 输出 Rectangle 构造函数

Square.prototype.constructor = Square; // 重置回 Square 构造函数
console.log(Square.prototype.constructor); // 输出 Square 构造函数

Square.prototype.toString = function(){
    return &quot;[Square &quot; + this.length + &quot;x&quot; + this.width + &quot;]&quot;;
}

var rect = new Rectangle(5, 10);
var square = new Square(6);

console.log(rect.getArea()); // 50
console.log(square.getArea()); // 36

console.log(rect.toString()); // &quot;[Rectangle 5 * 10]&quot;, 但如果是Square.prototype = Rectangle.prototype，则这里会&quot;[Square 5 * 10]&quot;
console.log(square.toString()); // &quot;[Square 6 * 6]&quot;

console.log(square instanceof Square); // true
console.log(square instanceof Rectangle); // true
console.log(square instanceof Object); // true
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF.jpg" alt="构造函数继承"></p>
<p><code>Square.prototype</code> 并不真的需要被改成为一个 <code>Rectangle</code> 对象。事实上，是 <code>Square.prototype</code> 需要指向 <code>Rectangle.prototype</code> 使得继承得以实现。这意味着可以用 <code>Object.create()</code> 简化例子。</p>
<pre><code>// inherits from Rectangle
function Square(size){
    this.length = size;
    this.width = size;
}

Square.prototype= Object.create(Rectangle.prototype, {
    constructor: {
        configurable: true,
        enumerable: true,
        value: Square,
        writable: true
    }
})
</code></pre><blockquote>
<p>在对原型对象添加属性前要确保你已经改成了原型对象，否则在改写时会丢失之前添加的方法（因为继承是将被继承对象赋值给需要继承的原型对象，相当于重写了需要继承的原型对象）。</p>
</blockquote>
<h3 id="构造函数窃取"><a href="#构造函数窃取" class="headerlink" title="构造函数窃取"></a>构造函数窃取</h3><p>由于JavaScript中的继承是通过原型对象链来实现的，因此不需要调用对象的父类的构造函数。如果确实需要在子类构造函数中调用父类构造函数，那就可以在子类的构造函数中利用 <code>call</code>、<code>apply</code>方法调用父类的构造函数。</p>
<pre><code>// 在上面的代码基础上作出修改
// inherits from Rectangle
function Square(size){
    Rectangle.call(this, size, size);

    // optional: add new properties or override existing ones here
}
</code></pre><p>一般来说，需要修改 <code>prototyp</code> 来继承方法并用构造函数窃取来设置属性，由于这种做法模仿了那些基于类的语言的类继承，所以这通常被称为伪类继承。</p>
<h3 id="访问父类方法"><a href="#访问父类方法" class="headerlink" title="访问父类方法"></a>访问父类方法</h3><p>其实也是通过指定 <code>call</code> 或 <code>apply</code> 的子对象调用父类方法。</p>
<h2 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h2><h3 id="私有成员和特权成员"><a href="#私有成员和特权成员" class="headerlink" title="私有成员和特权成员"></a>私有成员和特权成员</h3><p>JavaScipt 对象的所有属性都是公有的，没有显式的方法指定某个属性不能被外界访问。</p>
<h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>模块模式是一种用于创建<strong>拥有私有数据的单件对象</strong>的模式。<br>基本做法是使用立即调用函数表达式（IIFE）来返回一个对象。原理是利用闭包。</p>
<pre><code>var yourObj = (function(){
    // private data variables

    return {
        // public methods and properties
    }
}());
</code></pre><p>模块模式还有一个变种叫暴露模块模式，它将所有的变量和方法都放在 <code>IIFE</code> 的头部，然后将它们设置到需要被返回的对象上。</p>
<pre><code>//  一般写法
var yourObj = (function(){
    var age = 25;

    return {
        name: &quot;Ljc&quot;,

        getAge: function(){
            return agel
        }
    }
}());

// 暴露模块模式
var yourObj = (function(){
    var age = 25;
    function getAge(){
        return agel
    };
    return {
        name: &quot;Ljc&quot;,
        getAge: getAge
    }
}());
</code></pre><h4 id="构造函数的私有成员（不能通过对象直接访问）"><a href="#构造函数的私有成员（不能通过对象直接访问）" class="headerlink" title="构造函数的私有成员（不能通过对象直接访问）"></a>构造函数的私有成员（不能通过对象直接访问）</h4><p>模块模式在定义单个对象的私有属性十分有效，但对于那些同样需要私有属性的自定义类型呢？你可以在构造函数中使用类似的模式来创建每个实例的私有数据。</p>
<pre><code>function Person(name){
    // define a variable only accessible inside of the Person constructor
    var age = 22;

    this.name = name;
    this.getAge = function(){
        return age;
    };
    this.growOlder = function(){
        age++;
    }
}

var person = new Person(&quot;Ljc&quot;);

console.log(person.age); // undefined
person.age = 100;
console.log(person.getAge()); // 22

person.growOlder();
console.log(person.getAge()); // 23
</code></pre><p>这里有个问题：如果你需要<strong>对象实例</strong>拥有私有数据，就不能将相应方法放在 <code>prototype</code> 上。</p>
<p>如果你需要所有实例共享私有数据。则可结合模块模式和构造函数，如下：</p>
<pre><code>var Person = (function(){
    var age = 22;

    function InnerPerson(name){
        this.name = name;
    }

    InnerPerson.prototype.getAge = function(){
        return age;
    }
    InnerPerson.prototype.growOlder = function(){
        age++;
    };

    return InnerPerson;
}());

var person1 = new Person(&quot;Nicholash&quot;);
var person2 = new Person(&quot;Greg&quot;);

console.log(person1.name); // &quot;Nicholash&quot;
console.log(person1.getAge()); // 22

console.log(person2.name); // &quot;Greg&quot;
console.log(person2.getAge()); // 22

person1.growOlder();
console.log(person1.getAge()); // 23
console.log(person2.getAge()); // 23
</code></pre><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><p>这是一种伪继承。一个对象在不改变原型对象链的情况下得到了另外一个对象的属性被称为“混入”。因此，和继承不同，混入让你在创建对象后无法检查属性来源。<br>纯函数实现：</p>
<pre><code>function mixin(receiver, supplier){
    for(var property in supplier){
        if(supplier.hasOwnProperty(property)){
            receiver[property] = supplier[property];
        }
    }
}
</code></pre><p>这是浅拷贝，如果属性的值是一个引用，那么两者将指向同一个对象。</p>
<h3 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h3><p>构造函数也是函数，所以不用 new 也能调用它们来改变 <code>this</code> 的值。在非严格模式下， <code>this</code> 被强制指向全局对象。而在严格模式下，构造函数会抛出一个错误（因为严格模式下没有为全局对象设置 <code>this</code>，<code>this</code> 保持为 <code>undefined</code>）。<br>而很多内建构造函数，例如 <code>Array</code>、<code>RegExp</code> 不需要 <code>new</code> 也能正常工作，这是因为它们被设计为作用域安全的构造函数。<br>当用 <code>new</code> 调用一个函数时，<code>this</code> 指向的新创建的对象是属于该构造函数所代表的自定义类型。因此，可在函数内用 <code>instanceof</code> 检查自己是否被 <code>new</code> 调用。</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        // called with &quot;new&quot;
    }else{
        // called without &quot;new&quot;
    }
}
</code></pre><p>具体案例：</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        this.name = name;
    }else{
        return new Person(name);
    }
}
</code></pre><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>看了两天的书，做了两天的笔记。当然这只是ES5的。过几天 ES6 新书又来了。最后感谢 <a href="http://www.epubit.com.cn/" target="_blank" rel="external">异步社区</a> 送我这本好书 <a href="http://www.epubit.com.cn/book/details/1798" target="_blank" rel="external">《JavaScript面向对象精要》</a>，让我的前端根基更加稳固，希望自己的前端之路越走越顺。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年1月16日-17日两天看完了《JavaScript面向对象精要》（参加异步社区的活动送的），这本书虽然不够100页，但都是精华，不愧是《JavaScript高级程序设计》作者 Nicholas C.Zakas 的最新力作。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
      <category term="object-oriented" scheme="http://yoursite.com/tags/object-oriented/"/>
    
  </entry>
  
  <entry>
    <title>细说JavaSript单线程的一些事</title>
    <link href="http://yoursite.com/2016/01/08/2016-1-8-javascript-thread/"/>
    <id>http://yoursite.com/2016/01/08/2016-1-8-javascript-thread/</id>
    <published>2016-01-08T01:58:07.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>首发地址：<a href="http://www.codeceo.com/article/javascript-threaded.html" target="_blank" rel="external">码农网《细说JavaScript单线程的一些事》</a></p>
<p>最近被同学问道 JavaScript 单线程的一些事，我竟回答不上。好吧，感觉自己的 JavaScript 白学了。下面是我这几天整理的一些关于 JavaScript 单线程的一些事。</p>
<a id="more"></a>
<h2 id="首先，说下为什么-JavaScript-是单线程？"><a href="#首先，说下为什么-JavaScript-是单线程？" class="headerlink" title="首先，说下为什么 JavaScript 是单线程？"></a>首先，说下为什么 JavaScript 是单线程？</h2><p>总所周知，JavaScript是以单线程的方式运行的。说到线程就自然联想到进程。那它们有什么联系呢？</p>
<blockquote>
<p>进程和线程都是操作系统的概念。进程是应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据和其它系统资源所组成；进程在运行过程中能够申请创建和使用系统资源（如独立的内存区域等），这些资源也会随着进程的终止而被销毁。而线程则是进程内的一个独立执行单元，在不同的线程之间是可以共享进程资源的，所以在多线程的情况下，需要特别注意对临界资源的访问控制。在系统创建进程之后就开始启动执行进程的主线程，而进程的生命周期和这个主线程的生命周期一致，主线程的退出也就意味着进程的终止和销毁。主线程是由系统进程所创建的，同时用户也可以自主创建其它线程，这一系列的线程都会并发地运行于同一个进程中。</p>
</blockquote>
<p>显然，在多线程操作下可以实现应用的<strong>并行处理</strong>，从而以更高的CPU利用率提高整个应用程序的性能和吞吐量。特别是现在很多语言都支持多核并行处理技术，然而JavaScript却以单线程执行，为什么呢？</p>
<p>其实这与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。若以多线程的方式操作这些DOM，则可能出现操作的冲突。假设有两个线程同时操作一个DOM元素，线程1要求浏览器删除DOM，而线程2却要求修改DOM样式，这时浏览器就无法决定采用哪个线程的操作。当然，我们可以为浏览器引入“锁”的机制来解决这些冲突，但这会大大提高复杂性，所以 JavaScript 从诞生开始就选择了单线程执行。</p>
<p>另外，因为 JavaScript 是单线程的，在某一时刻内只能执行特定的一个任务，并且会阻塞其它任务执行。那么对于类似I/O等耗时的任务，就没必要等待他们执行完后才继续后面的操作。在这些任务完成前，JavaScript完全可以往下执行其他操作，当这些耗时的任务完成后则以回调的方式执行相应处理。这些就是JavaScript与生俱来的特性：异步与回调。</p>
<p>当然对于不可避免的耗时操作（如：繁重的运算，多重循环），HTML5提出了<strong>Web Worker</strong>，它会在当前JavaScript的执行主线程中利用Worker类新开辟一个额外的线程来加载和运行特定的JavaScript文件，这个新的线程和JavaScript的主线程之间并不会互相影响和阻塞执行，而且在Web Worker中提供了这个新线程和JavaScript主线程之间数据交换的接口：postMessage和onMessage事件。但在HTML5 Web Worker中是不能操作DOM的，任何需要操作DOM的任务都需要委托给JavaScript主线程来执行，所以虽然引入HTML5 Web Worker，但仍然没有改线JavaScript单线程的本质。</p>
<h2 id="并发模式与Event-Loop"><a href="#并发模式与Event-Loop" class="headerlink" title="并发模式与Event Loop"></a>并发模式与Event Loop</h2><p><strong>JavaScript 有个基于“Event Loop”并发的模型。</strong><br>啊，并发？不是说 JavaScript是单线程吗？ 没错，的确是单线程，但是并发与并行是有区别的。<br>前者是逻辑上的同时发生，而后者是物理上的同时发生。所以，单核处理器也能实现并发。</p>
<p><img src="http://images.51cto.com/files/uploadimg/20090804/1503300.jpg" alt="并发与并行"><br>并发与并行</p>
<p>并行大家都好理解，而<strong>所谓“并发”是指两个或两个以上的事件在同一时间间隔中发生。</strong>如上图的第一个表，由于计算机系统只有一个CPU，故ABC三个程序从“微观”上是交替使用CPU，但交替时间很短，用户察觉不到，形成了“宏观”意义上的并发操作。</p>
<h3 id="Runtime-概念"><a href="#Runtime-概念" class="headerlink" title="Runtime 概念"></a>Runtime 概念</h3><p>下面的内容解释一个理论上的模型。现代 JavaScript 引擎已着重实现和优化了以下所描述的几个概念。</p>
<p><img src="https://developer.mozilla.org/files/4617/default.svg" alt="Stack、Heap、Queue"></p>
<h4 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a>Stack（栈）</h4><p>这里放着JavaScript正在执行的任务。每个任务被称为帧（stack of frames）。</p>
<pre><code>function f(b){
  var a = 12;
  return a+b+35;
}

function g(x){
  var m = 4;
  return f(m*x);
}

g(21);
</code></pre><p>上述代码调用 <code>g</code> 时，创建栈的第一帧，该帧包含了 <code>g</code> 的参数和局部变量。当 <code>g</code> 调用 <code>f</code> 时，第二帧就会被创建，并且置于第一帧之上，当然，该帧也包含了 <code>f</code> 的参数和局部变量。当 <code>f</code> 返回时，其对应的帧就会出栈。同理，当 <code>g</code> 返回时，栈就为空了（<strong>栈的特定就是后进先出</strong> Last-in first-out (LIFO)）。</p>
<h4 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h4><p>一个用来表示内存中一大片非结构化区域的名字，对象都被分配在这。</p>
<h4 id="Queue（队列）"><a href="#Queue（队列）" class="headerlink" title="Queue（队列）"></a>Queue（队列）</h4><p>一个 JavaScript runtime 包含了一个任务队列，该队列是由一系列待处理的任务组成。而每个任务都有相对应的函数。当栈为空时，就会从任务队列中取出一个任务，并处理之。该处理会调用与该任务相关联的一系列函数（因此会创建一个初始栈帧）。当该任务处理完毕后，栈就会再次为空。<strong>（Queue的特点是先进先出 First-in First-out (FIFO)）。</strong></p>
<p>为了方便描述与理解，作出以下约定：</p>
<ul>
<li>Stack栈为<strong>主线程</strong></li>
<li>Queue队列为<strong>任务队列（等待调度到主线程执行）</strong></li>
</ul>
<p>OK，上述知识点帮助我们理清了一个 JavaScript runtime 的相关概念，这有助于接下来的分析。</p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>之所以被称为Event loop，是因为它以以下类似方式实现：</p>
<pre><code>while(queue.waitForMessage()){
  queue.processNextMessage();
}
</code></pre><p>正如上述所说，“任务队列”是一个事件的队列，如果I/O设备完成任务或用户触发事件（该事件指定了回调函数），那么相关事件处理函数就会进入“任务队列”，当主线程空闲时，就会调度“任务队列”里第一个待处理任务，（FIFO）。当然，对于定时器，当到达其指定时间时，才会把相应任务插到“任务队列”尾部。</p>
<h4 id="“执行至完成”"><a href="#“执行至完成”" class="headerlink" title="“执行至完成”"></a>“执行至完成”</h4><p>每当某个任务执行完后，其它任务才会被执行。也就是说，当一个函数运行时，它不能被取代且会在其它代码运行前先完成。<br>当然，这也是Event Loop的一个<strong>缺点</strong>：当一个任务完成时间过长，那么应用就不能及时处理用户的交互（如点击事件），甚至导致该应用奔溃。一个比较好解决方案是：将任务完成时间缩短，或者尽可能将一个任务分成多个任务执行。</p>
<h4 id="绝不阻塞"><a href="#绝不阻塞" class="headerlink" title="绝不阻塞"></a>绝不阻塞</h4><p>JavaScript与其它语言不同，其Event Loop的一个特性是永不阻塞。I/O操作通常是通过事件和回调函数处理。所以，当应用等待 indexedDB 或 XHR 异步请求返回时，其仍能处理其它操作（如用户输入）。</p>
<p>例外是存在的，如alert或者同步XHR，但避免它们被认为是最佳实践。注意的是，例外的例外也是存在的（但通常是实现错误而非其它原因)。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="定时器的一些概念"><a href="#定时器的一些概念" class="headerlink" title="定时器的一些概念"></a>定时器的一些概念</h4><p>上面也提到，在到达指定时间时，定时器就会将相应回调函数插入“任务队列”尾部。这就是“定时器(timer)”功能。</p>
<p><a href="http://dev.w3.org/html5/spec-preview/timers.html" target="_blank" rel="external">定时器</a> 包括setTimeout与setInterval两个方法。它们的第二个参数是指定其回调函数推迟\每隔多少毫秒数后执行。<br>对于第二个参数有以下需要注意的地方：</p>
<ul>
<li>当第二个参数缺省时，默认为0；</li>
<li>当指定的值小于4毫秒，则增加到4ms（4ms是HTML5标准指定的，对于2010年及之前的浏览器则是10ms）；</li>
</ul>
<p>如果你理解上述知识，那么以下代码就应该对你没什么问题了：</p>
<pre><code>console.log(1);
setTimeout(function(){
    console.log(2);
},10);
console.log(3);
// 输出：1 3 2
</code></pre><h4 id="深入了解定时器"><a href="#深入了解定时器" class="headerlink" title="深入了解定时器"></a>深入了解定时器</h4><h5 id="零延迟-setTimeout-func-0"><a href="#零延迟-setTimeout-func-0" class="headerlink" title="零延迟 setTimeout(func, 0)"></a>零延迟 setTimeout(func, 0)</h5><p>零延迟并不是意味着回调函数立刻执行。它取决于主线程当前是否空闲与“任务队列”里其前面正在等待的任务。</p>
<p>看看以下代码：</p>
<pre><code>(function () {

  console.log(&apos;this is the start&apos;);

  setTimeout(function cb() {
    console.log(&apos;this is a msg from call back&apos;);
  });

  console.log(&apos;this is just a message&apos;);

  setTimeout(function cb1() {
    console.log(&apos;this is a msg from call back1&apos;);
  }, 0);

  console.log(&apos;this is the  end&apos;);

})();

// 输出如下：
this is the start
this is just a message
this is the end
undefined // 立即调用函数的返回值
this is a msg from callback
this is a msg from a callback1
</code></pre><h5 id="setTimeout-func-0-的作用"><a href="#setTimeout-func-0-的作用" class="headerlink" title="setTimeout(func, 0)的作用"></a><strong>setTimeout(func, 0)的作用</strong></h5><ul>
<li>让浏览器渲染当前的变化（很多浏览器UI render和js执行是放在一个线程中，线程阻塞会导致界面无法更新渲染） </li>
<li>重新评估”scriptis running too long”警告</li>
<li>改变执行顺序</li>
</ul>
<p>再看看以下代码：</p>
<pre><code>&lt;button id=&apos;do&apos;&gt; Do long calc!&lt;/button&gt;
&lt;div id=&apos;status&apos;&gt;&lt;/div&gt;
&lt;div id=&apos;result&apos;&gt;&lt;/div&gt;


$(&apos;#do&apos;).on(&apos;click&apos;, function(){

  $(&apos;#status&apos;).text(&apos;calculating....&apos;);// 此处会触发redraw事件，但会放到队列里执行，直到long()执行完。

  // 没设定定时器，用户将无法看到“calculating...”
  long();// 执行长时间任务，造成阻塞

  // 设定了定时器，用户就如期看到“calculating...”
  //setTimeout(long,50);// 大约50ms后，将耗时长的long回调函数插入“任务队列”末尾，根据先进先出原则，其将在redraw之后被调度到主线程执行

 });

function long(){
  var result = 0
  for (var i = 0; i&lt;1000; i++){
    for (var j = 0; j&lt;1000; j++){
      for (var k = 0; k&lt;1000; k++){
        result = result + i+j+k
      }
    } 
  }
  $(&apos;#status&apos;).text(&apos;calclation done&apos;); // 在本案例中，该语句必须放到这里，这将使它与回调函数的行为类似
}
</code></pre><h6 id="正版与翻版setInterval的区别"><a href="#正版与翻版setInterval的区别" class="headerlink" title="正版与翻版setInterval的区别"></a><strong>正版与翻版setInterval的区别</strong></h6><p>大家都可能知道通过setTimeout可以模仿setInterval的效果，下面我们看看以下代码的区别：</p>
<pre><code>// 利用setTimeout模仿setInterval
setTimeout(function(){
    /* 执行一些操作. */
    setTimeout(arguments.callee, 10);
}, 1000);

setInterval(function(){
    /* 执行一些操作 */
}, 1000);
</code></pre><p>可能你认为这没什么区别。的确，当回调函数里的操作耗时很短时，并不能看出它们有什么区别。<br>其实：上面案例中的 setTimeout 总是会在其回调函数执行后延迟 10ms（或者更多，但不可能少）再次执行回调函数，从而实现setInterval的效果，而 setInterval 总是 10ms 执行一次，而不管它的回调函数执行多久。</p>
<p>所以，如果 setInterval 的回调函数执行时间比你指定的间隔时间相等或者更长，那么其回调函数会连在一起执行。</p>
<p>你可以试试运行以下代码：</p>
<pre><code>var counter = 0;
var initTime = new Date().getTime();
var timer = setInterval(function(){
    if(counter===2){
        clearInterval(timer);
    }
    if(counter === 0){
        for(var i = 0; i &lt; 1990000000; i++){
            ;
        }
    }

    console.log(&quot;第&quot;+counter+&quot;次：&quot; + (new Date().getTime() - initTime) + &quot; ms&quot;);

    counter++;
},1000);
</code></pre><p>我电脑Chrome浏览器的输入如下：</p>
<pre><code>第0次：2007 ms
第1次：2013 ms
第2次：3008 ms
</code></pre><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="浏览器不是单线程的"><a href="#浏览器不是单线程的" class="headerlink" title="浏览器不是单线程的"></a>浏览器不是单线程的</h4><p>上面说了这么多关于JavaScript是单线程的，下面说说其宿主环境——浏览器。<br><strong>浏览器的内核是多线程</strong>的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：</p>
<ol>
<li>javascript引擎线程 javascript引擎是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。</li>
<li>GUI渲染线程 GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>
<li>浏览器事件触发线程 事件触发线程，当一个事件被触发时该线程会把事件添加到“任务队列”的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS是单线程执行的，所有这些事件都得排队等待JS引擎处理。</li>
</ol>
<p>在Chrome浏览器中，为了防止因一个标签页奔溃而影响整个浏览器，其每个标签页都是一个<strong>进程</strong>。当然，对于同一域名下的标签页是能够相互通讯的，具体可看 <a href="http://web.jobbole.com/82225/" target="_blank" rel="external">浏览器跨标签通讯</a>。在Chrome设计中存在很多的进程，并利用进程间通讯来完成它们之间的同步，因此这也是Chrome快速的法宝之一。对于Ajax的请求也需要特殊线程来执行，当需要发送一个Ajax请求时，浏览器会开辟一个新的线程来执行HTTP的请求，它并不会阻塞JavaScript线程的执行，当HTTP请求状态变更时，相应事件会被作为回调放入到“任务队列”中等待被执行。</p>
<p>看看以下代码：</p>
<pre><code>document.onclick = function(){
    console.log(&quot;click&quot;)
}

for(var i = 0; i&lt; 100000000; i++);
</code></pre><p>解释一下代码：首先向document注册了一个click事件，然后就执行了一段耗时的for循环，在这段for循环结束前，你可以尝试点击页面。当耗时操作结束后，console控制台就会输出之前点击事件的”click”语句。这视乎证明了点击事件（也包括其它各种事件）是由额外单独的线程触发的，事件触发后就会将回调函数放进了“任务队列”的末尾，等待着JavaScript主线程的执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>JavaScript是单线程的，同一时刻只能执行特定的任务。而浏览器是多线程的。</li>
<li>异步任务（各种浏览器事件、定时器等）都是先添加到“任务队列”（定时器则到达其指定参数时）。当Stack栈（JS主线程）为空时，就会读取Queue队列（任务队列）的第一个任务（队首），然后执行。</li>
</ul>
<p>JavaScript为了避免复杂性，而实现单线程执行。而今JavaScript却变得越来越不简单了，当然这也是JavaScript迷人的地方。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="http://www.cnblogs.com/whitewolf/p/javascript-single-thread-and-browser-event-loop.html" target="_blank" rel="external">JavaScript单线程和浏览器事件循环简述</a></li>
<li><a href="http://www.cnblogs.com/Mainz/p/3552717.html" target="_blank" rel="external">Javascript是单线程的深入分析</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">Concurrency model and Event Loop</a></li>
<li><a href="http://imweb.io/topic/56642e21d91952db73b41f52" target="_blank" rel="external">也谈setTimeout</a></li>
<li><a href="https://leohxj.gitbooks.io/front-end-database/content/theory/single-thread.html" target="_blank" rel="external">单线程的Javascript</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首发地址：&lt;a href=&quot;http://www.codeceo.com/article/javascript-threaded.html&quot;&gt;码农网《细说JavaScript单线程的一些事》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近被同学问道 JavaScript 单线程的一些事，我竟回答不上。好吧，感觉自己的 JavaScript 白学了。下面是我这几天整理的一些关于 JavaScript 单线程的一些事。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>让footer固定在页面（或视口）底部</title>
    <link href="http://yoursite.com/2015/12/21/2015-12-21-css-sticky-footer/"/>
    <id>http://yoursite.com/2015/12/21/2015-12-21-css-sticky-footer/</id>
    <published>2015-12-21T06:51:31.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个让网站footer固定在浏览器(页面内容小于浏览器高度时)/页面底部的技巧。由HTML和CSS实现，没有令人讨厌的hacks。所以这就能在所有主流浏览器上正常运行（甚至包括IE5和IE6）。<br><a id="more"></a></p>
<h3 id="如何通过用CSS让Footer固定在页面顶部。"><a href="#如何通过用CSS让Footer固定在页面顶部。" class="headerlink" title="如何通过用CSS让Footer固定在页面顶部。"></a>如何通过用CSS让Footer固定在页面顶部。</h3><p>在样式表单里添加下面几行CSS代码。<code>.wrapper</code> 的负外边距与 <code>.footer</code> 和 <code>.push</code> 的高度相等。负外边距应该与footer的整体高度相等（包括padding、border）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    margin: 0;</div><div class="line">&#125;</div><div class="line">html, body &#123;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">.wrapper &#123;</div><div class="line">    min-height: 100%;</div><div class="line">    height: auto !important; /* 如果你不需要考虑IE6，则可以把这行与下一行代码删除 */</div><div class="line">    height: 100%;</div><div class="line">    margin: 0 auto -4em;</div><div class="line">&#125;</div><div class="line">.footer, .push &#123;</div><div class="line">    height: 4em;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照此 HTML 结构。没有内容会超出 .wrapper 和 .footer 的 <code>div</code> 标签，除非超出内容是通过CSS的绝对定位。另外，<code>.push</code> 的 <code>div</code> 标签也不应该含有内容，毕竟它是作为一个将footer“推”下去的隐藏元素。否则会与footer的内容重叠。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;link rel=&quot;stylesheet&quot; href=&quot;layout.css&quot; /&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;div class=&quot;wrapper&quot;&gt;</div><div class="line">            &lt;p&gt;Your website content here.&lt;/p&gt;</div><div class="line">            &lt;div class=&quot;push&quot;&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div class=&quot;footer&quot;&gt;</div><div class="line">            &lt;p&gt;Copyright (c) 2008&lt;/p&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<hr>
<h4 id="多列布局（通过浮动）"><a href="#多列布局（通过浮动）" class="headerlink" title="多列布局（通过浮动）"></a>多列布局（通过浮动）</h4><p>为 <code>.push</code> div 添加 clear 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.footer, .push &#123;</div><div class="line">    clear: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="height-auto-important-和-height-100-属性"><a href="#height-auto-important-和-height-100-属性" class="headerlink" title="height:auto!important; 和 height:100%;属性"></a>height:auto!important; 和 height:100%;属性</h4><p>这两个属性是为了在IE6及以下的浏览器实现 <a href="http://caniuse.com/#search=min-height" target="_blank" rel="external">min-height</a> 效果(min-height只兼容IE7及以上)。所以，当你不需要考虑IE6时，可把这两个属性删除。</p>
<blockquote>
<p>因为IE6是考虑元素内容的尺寸，而不是元素本身尺寸。在符合标准的浏览器中，如果元素的内容太大，它只会超出框之外。但是在IE6中，如果元素内容太大，则整个元素就会扩展(包括宽和高)。即设定的width表现得像min-width。</p>
</blockquote>
<p>完整代码：<a href="https://github.com/JChehe/CSS-Sticky-Footer/blob/master/CSS%20Sticky%20Footer.html" target="_blank" rel="external">https://github.com/JChehe/CSS-Sticky-Footer/blob/master/CSS%20Sticky%20Footer.html</a><br>参考：<a href="http://ryanfait.com/resources/footer-stick-to-bottom-of-page/" target="_blank" rel="external">http://ryanfait.com/resources/footer-stick-to-bottom-of-page/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个让网站footer固定在浏览器(页面内容小于浏览器高度时)/页面底部的技巧。由HTML和CSS实现，没有令人讨厌的hacks。所以这就能在所有主流浏览器上正常运行（甚至包括IE5和IE6）。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="translation" scheme="http://yoursite.com/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>其实闭包并不高深莫测</title>
    <link href="http://yoursite.com/2015/12/10/2015-12-10-closures-are-not-magic/"/>
    <id>http://yoursite.com/2015/12/10/2015-12-10-closures-are-not-magic/</id>
    <published>2015-12-10T03:24:47.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>几年前，我还是一名高中生时，我的一个朋友向我讲述了闭包的概念。虽然我当时一点也不明白他想表达的内容，但他在向我讲述时却表现得非常高大上。对于当时的我来说，闭包看来是一个深不可测的魔法。即使 Google 后也不能解除我的疑惑。而所有我能查阅的科技文章，都为高中生所难以理解。</p>
<a id="more"></a>
<p>现在的我回想起高中编程时光，我都会不禁一笑。这是一篇试图用一些简单项目去解释闭包的文章，这会帮助我的学弟学妹们能轻易地驾驭强大的闭包。</p>
<h2 id="计数事件"><a href="#计数事件" class="headerlink" title="计数事件"></a>计数事件</h2><p>我们将从一个简单的问题开始。如果将闭包引入到该程序中，将能轻易解决这个问题。<br>我们为计数事件创建一个机制。该机制将有助于我们跟踪代码的执行，甚至去调试一些问题。例如，我会以下面的方式调用计数器：</p>
<pre><code>increment();  // Number of events: 1
increment();  // Number of events: 2
increment();  // Number of events: 3
</code></pre><p>正如你所看到的上述案例，我们希望代码会在我们每次执行 <code>increment()</code> 函数时，会显示一条信息“Number of events: x”。下面以简单的方式实现该函数：</p>
<pre><code>var counter = 0;

function increment() {
  counter = counter + 1;
  console.log(&quot;Number of events: &quot; + counter);
}
</code></pre><h2 id="多个计数器"><a href="#多个计数器" class="headerlink" title="多个计数器"></a>多个计数器</h2><p>上述代码非常简单明确。然而，当我们引入第二个计数器时，就会很快遇到问题。当然，我们能实现两个单独的计数器机制，如下面的代码，但很明显有需要改进的地方：</p>
<pre><code>var counter1 = 0;

function incrementCounter1() {
  counter1 = counter1 + 1;
  console.log(&quot;Number of events: &quot; + counter1);
}

var counter2 = 0;

function incrementCounter2() {
  counter2 = counter2 + 1;
  console.log(&quot;Number of events: &quot; + counter2);
}

incrementCounter1();  // Number of events: 1
incrementCounter2();  // Number of events: 1
incrementCounter1();  // Number of events: 2
</code></pre><p>上述代码出现了不必要的重复。明显地，这种解决办法并不适用于超过二或三个记数器的情况。我们需要想出更好的解决方案。</p>
<h2 id="引入我们第一个闭包"><a href="#引入我们第一个闭包" class="headerlink" title="引入我们第一个闭包"></a>引入我们第一个闭包</h2><p>在保持与上述例子相似的情况下，我们以某种方式引入新的计数器，该计数器捆绑了一个能自增的函数，而且没有大量重复的代码。下面尝试使用闭包：</p>
<pre><code>function createCounter() {
  var counter = 0;

  function increment() {
    counter = counter + 1;
    console.log(&quot;Number of events: &quot; + counter);
  }

  return increment;
}
</code></pre><p>让我们看看这是如何工作的。我们将创建两个计数器，并让它们跟踪两个独立的事件：</p>
<pre><code>var counter1 = createCounter();
var counter2 = createCounter();

counter1(); // Number of events: 1
counter1(); // Number of events: 2

counter2(); // Number of events: 1

counter1(); // Number of events: 3
</code></pre><p>啊，这看起来有点复杂…然而，这实际上是非常简单的。我们只需将实现逻辑分成几个易于理解的块。下面就看看我们实现了什么：</p>
<ul>
<li>首先，创建了一个名为 <code>counter</code> 的局部变量。</li>
<li>然后，创建了一个名为 <code>increment</code> 的局部函数，它能增加 <code>counter</code> 变量值。如果你从未接触过将函数作为数据来处理的函数式编程，这也许对你非常陌生。然而，这是非常常见的，而且只需要一些练习就能适应这一概念。</li>
</ul>
<p>你应该注意到这一点，<code>createCounter()</code> 的实现与我们原先的计数器实现几乎一致。唯一不同的是它被包装或封装在一个函数体内。因此，这些构造器都被称为闭包。</p>
<p>现在是棘手的部分：</p>
<ul>
<li>在 <code>createCounter()</code> 的最后一步返回了局部函数 <code>increment</code>。请注意，这并不是返回调用函数的运行结果，而是函数本身。</li>
</ul>
<p>这就意味着，当我们在这个代码段下面创建新的计数器时，实际上是生成新函数。</p>
<pre><code>// fancyNewCounter is a function in this scope
// fancyNewCounter 是当前作用域的一个函数

var fancyNewCounter = createCounter();
</code></pre><p>这就是闭包生命周期的力量所在。每个生成的函数，都会保持在 <code>createCounter()</code> 所创建的 <code>counter</code> 变量的引用。在某种意义上，被返回的函数记住了它所被创建时的环境。</p>
<p>在这里需要提醒大家注意的是，内部变量 <code>counter</code> 都是独立存在于每个作用域！例如，如果我们创建两个计数器，那么它们都会在闭包体内会分配一个新的 <code>counter</code> 变量。我们观察以下代码：</p>
<p>每个计数器都会从 1 算起：</p>
<pre><code>var counter1 = createCounter();
counter1(); // Number of events: 1
counter1(); // Number of events: 2

var counter2 = createCounter();
counter2(); // Number of events: 1
</code></pre><p>第二个计数器并不会干扰第一个计数器的值：</p>
<pre><code>counter1(); // Number of events: 3
</code></pre><h2 id="为我们的计数器命名"><a href="#为我们的计数器命名" class="headerlink" title="为我们的计数器命名"></a>为我们的计数器命名</h2><p>信息“Number of events: x” 是没问题的，但如果能描述每个计数事件的类型，那么这将会更好。如以下例子，我们为计数器添加名字：</p>
<pre><code>var catCounter = createCounter(&quot;cats&quot;);
var dogCounter = createCounter(&quot;dogs&quot;);

catCounter(); // Number of cats: 1
catCounter(); // Number of cats: 2
dogCounter(); // Number of dogs: 1
</code></pre><p>我们仅需通过为闭包传递参数就能达到这种目的。</p>
<pre><code>function createCounter(counterName) {
  var counter = 0;

  function increment() {
    counter = counter + 1;

    console.log(&quot;Number of &quot; + counterName + &quot;: &quot; + counter);
  }

  return increment;
}
</code></pre><p>非常棒！请注意上述 <code>createCounter()</code> 函数的一个有趣行为。返回函数不仅记住了局部变量 <code>counter</code>，而且记住了传递进来的参数。</p>
<h2 id="改善公用接口"><a href="#改善公用接口" class="headerlink" title="改善公用接口"></a>改善公用接口</h2><p>我所说的公用接口是指，我们如何使用计数器。这并不单纯指，当被创建的计数器被调用时会增加值。</p>
<pre><code>var dogCounter = createCounter(&quot;dogs&quot;);

dogCounter.increment(); // Number of dogs: 1
</code></pre><p>让我们创建这样的一个实现：</p>
<pre><code>function createCounter(counterName) {
  var counter = 0;

  function increment() {
    counter = counter + 1;

    console.log(&quot;Number of &quot; + counterName + &quot;: &quot; + counter);
  };

  return { increment : increment };
}
</code></pre><p>在上述代码段，我们简单地返回一个对象，该对象包含了该闭包的所有功能。在某种意义下，我们能定义闭包能返回的一系列信息。</p>
<h2 id="增加一个减量"><a href="#增加一个减量" class="headerlink" title="增加一个减量"></a>增加一个减量</h2><p>现在，我们能非常简单地为我们的计数器引入减量（decrement）。</p>
<pre><code>function createCounter(counterName) {
  var counter = 0;

  function increment() {
    counter = counter + 1;

    console.log(&quot;Number of &quot; + counterName + &quot;: &quot; + counter);
  };

  function decrement() {
    counter = counter - 1;

    console.log(&quot;Number of &quot; + counterName + &quot;: &quot; + counter);
  };

  return {
    increment : increment,
    decrement : decrement
  };
}

var dogsCounter = createCounter(&quot;dogs&quot;);

dogsCounter.increment(); // Number of dogs: 1
dogsCounter.increment(); // Number of dogs: 2
dogsCounter.decrement(); // Number of dogs: 1
</code></pre><h2 id="隐藏计数器行为"><a href="#隐藏计数器行为" class="headerlink" title="隐藏计数器行为"></a>隐藏计数器行为</h2><p>上述代码有两处冗余的代码行。没错，就是 <code>console.log</code>。如果能创建一个专门用于显示计数器值的函数将会更好。让我们调用 <code>display</code> 函数。</p>
<pre><code>function createCounter(counterName) {
  var counter = 0;

  function display() {
    console.log(&quot;Number of &quot; + counterName + &quot;: &quot; + counter);
  }

  function increment() {
    counter = counter + 1;

    display();
  };

  function decrement() {
    counter = counter - 1;

    display();
  };

  return {
    increment : increment,
    decrement : decrement
  };
}

var dogsCounter = createCounter(&quot;dogs&quot;);

dogsCounter.increment(); // Number of dogs: 1
dogsCounter.increment(); // Number of dogs: 2
dogsCounter.decrement(); // Number of dogs: 1
</code></pre><p><code>display()</code>与<code>increment()</code>和 <code>decrement()</code> 函数看起来非常相似，然而这是大相径庭的。我们没有在结果对象里返回它！这意味着以下代码将会调用失败：</p>
<pre><code>var dogsCounter = createCounter(&quot;dogs&quot;);

dogsCounter.display(); // ERROR !!!
</code></pre><p>我们让 <code>display()</code> 函数对外部来说是不可见的。它仅在 <code>createCounter()</code> 内可用。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>正如你所见，我们通过闭包能非常简单地引入抽象数据类型。例如，让我们通过闭包实现一个 <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type" target="_blank" rel="external">堆栈</a>)。</p>
<pre><code>function createStack() {
  var elements = [];

  return {
    push: function(el) { elements.unshift(el); },
    pop: function() { return elements.shift(); }
  };
}

var stack = createStack();

stack.push(3);
stack.push(4);
stack.pop(); // 4
</code></pre><p>注意：在 JavaScript 中，闭包并不是堆栈数据类型的最佳实现方式。用 Prototype 实现会对内存更友好（译者注：在当前对象实例找不会相应属性或方法时，会到相应实例共同引用的 Prototype 属性寻找相应属性或方法（如果在当前Prototype属性找不到时，会沿着当前原型链向上查找），而Prototype 上的属性或方法是公用的，而不像实例的属性或方法那样，各自单独创建属性或方法，从而节省更多的内存）。</p>
<h2 id="闭包与面向对象编程"><a href="#闭包与面向对象编程" class="headerlink" title="闭包与面向对象编程"></a>闭包与面向对象编程</h2><p>如果你具有 <a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="external">面向对象编程</a> 的经历，那么你应该会注意到上述构造器看来非常像类、对象、实例值和私有/公有方法。</p>
<p>闭包与类相似，都会将一些能操作内部数据的函数联系在一起。因此，你能在任何地方像使用对象一样使用闭包。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>闭包是编程语言一个很棒的属性。当我们想在 JavaScript 创建“真正的”隐藏域，或者需要创建简单的构造器时，闭包这个属性是非常好用的。不过对于一般的类来说，闭包可能还是有点太重了。</p>
<p>感谢您的阅读。 如果你觉得这篇文章对您有帮助或者觉得我翻译得不错，那给我个 <a href="https://github.com/JChehe/translation" target="_blank" rel="external">star</a> 吧。</p>
<hr>
<p>本文由 <a href="http://web.jobbole.com/" target="_blank" rel="external">伯乐在线</a> - <a href="http://www.jobbole.com/members/q574805242" target="_blank" rel="external">刘健超-J.c</a> 翻译，<a href="http://www.jobbole.com/members/namco1992" target="_blank" rel="external">Namco</a> 校稿。未经许可，禁止转载！</p>
<p>英文出处：<a href="http://renderedtext.com/blog/2015/11/18/closures-are-not-magic/" target="_blank" rel="external">Igor Šarčević</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几年前，我还是一名高中生时，我的一个朋友向我讲述了闭包的概念。虽然我当时一点也不明白他想表达的内容，但他在向我讲述时却表现得非常高大上。对于当时的我来说，闭包看来是一个深不可测的魔法。即使 Google 后也不能解除我的疑惑。而所有我能查阅的科技文章，都为高中生所难以理解。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="closure" scheme="http://yoursite.com/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>脱离jQuery，使用原生Ajax</title>
    <link href="http://yoursite.com/2015/12/05/2015-12-5-vanilla-ajax-without-jquery/"/>
    <id>http://yoursite.com/2015/12/05/2015-12-5-vanilla-ajax-without-jquery/</id>
    <published>2015-12-05T02:51:31.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Ajax_%28programming%29" target="_blank" rel="external">Ajax</a> 是异步的JavaScript和XML的简称，是一种更新页面某部分的机制。它赋予了你从服务器获取数据后，更新页面某部分的权力，从而避免了刷新整个页面。另外，以此方式实现页面局部更新，不仅能有效地打造流畅的用户体验，而且减轻了服务器的负载。<br><a id="more"></a><br>下面是对一个基本的 Ajax 请求进行剖析：</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&apos;GET&apos;, &apos;send-ajax-data.php&apos;);
xhr.send(null);
</code></pre><p>在这里， 我们创建了一个能向服务器发出 HTTP 请求的类的实例。然后调用其 <code>open</code> 方法，其中第一个参数是 HTTP 请求方法，第二个参数是请求页面的 URL。最后，我们调用参数为 null 的 <code>send</code> 方法。假如使用 POST 请求方法（这里我们使用了 GET），那么 send 方法 的参数应该包含任何你想发送的数据。</p>
<p>下面是我们如何处理服务器的响应：</p>
<pre><code>xhr.onreadystatechange = function(){
    var DONE = 4; // readyState 4 代表已向服务器发送请求
    var OK = 200; // status 200 代表服务器返回成功
    if(xhr.readyState === DONE){
        if(xhr.status === OK){
            console.log(xhr.responseText); // 这是返回的文本
        } else{
            console.log(&quot;Error: &quot;+ xhr.status); // 在此次请求中发生的错误
        }
    }
}
</code></pre><p><code>onreadystatechange</code> 是异步的，那么这就意味着它将可在任何时候被调用。这种类型的函数被称为回调函数——一旦某些处理完成后，它就会被调用。在此案例中，这个处理发生在服务器。</p>
<p>对于想学习更多关于 Ajax 基础知识的同学，可关注 MDN 的这篇<a href="https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started" target="_blank" rel="external">教程</a>。</p>
<h3 id="到底选择-jQuery-还是选择原生-JavaScript-呢？"><a href="#到底选择-jQuery-还是选择原生-JavaScript-呢？" class="headerlink" title="到底选择 jQuery 还是选择原生 JavaScript 呢？"></a>到底选择 jQuery 还是选择原生 JavaScript 呢？</h3><p>嗯，好消息是上述代码兼容所有最新的主流浏览器。而坏消息是使用起来十分复杂。的确令人恶心！我已经苦思出一个优雅的解决方案了。</p>
<p>如果使用 jQuery，则能把上述代码压缩成这样：</p>
<pre><code>$.ajax({
    url: &quot;send-ajax-data.php&quot;
}).done(function(res){
    console.log(res);
}).fail(function(){
    console.log(&quot;Error: &quot; + err.status);
})
</code></pre><p>非常简洁易懂。对于大多数人（我想也包括你）来说，jQuery 已经成为了解决 Ajax 的默认标准。但你知道吗？情况不一定是这样的。jQuery 的存在是为了解决丑陋的 DOM API。但 Ajax 真的是丑陋或复杂的吗？</p>
<p>在文章的剩余部分，我打算用原生 JavaScript 使 Ajax API 有所改善。关于 Ajax 的完整文档可以在 <a href="http://www.w3.org/TR/XMLHttpRequest/" target="_blank" rel="external">W3C</a> 找到。然而这份说明的标题使我非常受打击。竟然不是“XMLHttpRequest Level 2”，而是“XMLHttpRequest Level 1”——因为在2011年已将两个文档合并。展望未来，它们将被视为单一实体，而现存标准将其称为 <a href="https://xhr.spec.whatwg.org/" target="_blank" rel="external">XMLHttpRequest</a>。这表明社区坚持承诺只有一个标准，这对于想脱离 jQuery 的开发人员来说，是个好消息。</p>
<p>所以，让我们一起开始吧！</p>
<p>在这篇文章，我使用 <a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>作为后端。没错，这就可以全栈（浏览器和服务器）JS了。Node.js 是很简洁的，我鼓励你能在 <a href="https://github.com/sitepoint-editors/VanillaAjaxNojQuery" target="_blank" rel="external">Github</a>下载demo，并关注该项目。下面是服务器端的代码：</p>
<pre><code>// app.js
var app = http.createServer(function(req, res){
    if(req.url.indexOf(&quot;/scripts/&quot;) &gt;= 0){
        render(req.url.slice(1), &quot;application/javascript&quot;, httpHandler);
    } else if(req.headers[&apos;x-requested-with&apos;] === &apos;XMLHttpRequest&apos;){
        // Send Ajax response
    } else{
        render(&apos;views/index.html&apos;, &apos;text/html&apos;, httpHandler);
    }
}
</code></pre><p>该代码段通过检测请求 URL，确定该app返回的相应内容。如果该请求来自 <code>scripts</code> 目录，那么服务器将返回内容类型（content type）为 <code>application/javascript</code> 的相应文件。如果请求头部的 <code>x-requested-with</code> 被设为 <code>XMLHttpRequest</code>，那么该请求是 Ajax 请求，然后返回相应数据。除了以上两种情况，服务器将会返回 <code>views/index.html</code>。</p>
<p>下面我将会展开上一代码段处理 Ajax 请求的注释部分进行深入讲解。在 Node.js端，我已处理了 <code>render</code> 和 <code>httpHandler</code> 的体力活：</p>
<pre><code>// app.js
function render(path, contentType, fn) {
    fs.readFile(__dirname + &apos;/&apos; + path, &apos;utf-8&apos;, function (err, str) {
        fn(err, str, contentType);
    });
}
var httpHandler = function (err, str, contentType) {
    if (err) {
        res.writeHead(500, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
        res.end(&apos;An error has occured: &apos; + err.message);
    } else {
        res.writeHead(200, {&apos;Content-Type&apos;: contentType});
        res.end(str);
    }
};
</code></pre><p><code>render</code> 函数异步读取被请求文件的内容。该函数向被作为回调函数的 <code>httpHandler</code> 传递一个引用。<br><code>httpHandler</code> 函数检测 error 对象是否存在（如：被请求文件不能被打开，该对象就会存在）。另外，指定类型是好的做法，那么服务器返回的文件内容就会拥有适当的 HTTP 状态码（status code）和内容类型（content type）。</p>
<h3 id="测试-API"><a href="#测试-API" class="headerlink" title="测试 API"></a>测试 API</h3><p>让我们为后端API编写一些单元测试，从而确保它们能正确运行。对于这类测试，我会请求 <a href="https://www.npmjs.com/package/supertest" target="_blank" rel="external">supertest</a> 和 <a href="https://www.npmjs.com/package/mocha" target="_blank" rel="external">mocha</a>帮助。</p>
<pre><code>// test/app.request.js
it(&quot;responds with html&quot;, function(done){
    request(app)
        .get(&quot;/&quot;)
        .expect(&quot;Content-Type&quot;, /html/)
        .expect(200, done);
});
it(&apos;responds with javascript&apos;, function (done) {
request(app)
    .get(&apos;/scripts/index.js&apos;)
    .expect(&apos;Content-Type&apos;, /javascript/)
    .expect(200, done);
});
it(&apos;responds with json&apos;, function (done) {
request(app)
    .get(&apos;/&apos;)
    .set(&apos;X-Requested-With&apos;, &apos;XMLHttpRequest&apos;)
    .expect(&apos;Content-Type&apos;, /json/)
    .expect(200, done);
});
</code></pre><p>这些测试确保了我们的 app 对于不同请求能返回正确的内容类型(content type)和HTTP 状态码（status code）。一旦你安装了这些依赖，那么你就能使用命令 <code>npm test</code> 运行这些测试。</p>
<h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>现在，让我们看看用户界面的 HTML 代码：</p>
<pre><code>// views/index.html
&lt;h1&gt;Vanilla Ajax without jQuery&lt;/h1&gt;
&lt;button id=&quot;retrieve&quot; data-url=&quot;/&quot;&gt;Retrieve&lt;/button&gt;
&lt;p id=&quot;results&quot;&gt;&lt;/p&gt;
</code></pre><p>上述的 HTML 代码看起来很简洁。没错，正如你所看到的，所有令人兴奋的事情都发生在 JavaScript。</p>
<h3 id="onreadystate-vs-onload"><a href="#onreadystate-vs-onload" class="headerlink" title="onreadystate vs onload"></a>onreadystate vs onload</h3><p>如果你看过任何一本权威的、关于 Ajax 的书，你可能会发现 <code>onreadystate</code> 在书上随处可见。该回调函数需要通过嵌套的 ifs 或多个 case 语句完成，这使得难以记忆。让我们再次回顾 <code>onreadystate</code> 和  <code>onload</code> 事件。</p>
<pre><code>(function() {
    var retrieve = document.getElementById(&apos;retrieve&apos;),
        results = document.getElementById(&apos;results&apos;),
        toReadyStateDescription = function(state) {
            switch (state) {
                case 0:
                    return &apos;UNSENT&apos;;
                case 1:
                    return &apos;OPENED&apos;;
                case 2:
                    return &apos;HEADERS_RECEIVED&apos;;
                case 3:
                    return &apos;LOADING&apos;;
                case 4:
                    return &apos;DONE&apos;;
                default:
                    return &apos;&apos;;
            }
        };
    retrieve.addEventListener(&apos;click&apos;, function(e) {
        var oReq = new XMLHttpRequest();
        oReq.onload = function() {
            console.log(&apos;Inside the onload event&apos;);
        };
        oReq.onreadystatechange = function() {
            console.log(&apos;Inside the onreadystatechange ev![此处输入图片的描述][1]ent with readyState: &apos; +
                toReadyStateDescription(oReq.readyState));
        };
        oReq.open(&apos;GET&apos;, e.target.dataset.url, true);
        oReq.send();
    });
}());
</code></pre><p>上述代码会在 控制台（console） 输出以下语句：</p>
<p><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2015/08/1439883041onreadystate_vs_onload.jpg" alt="此处输入图片的描述"></p>
<p> <code>onreadystatechange</code> 事件能在请求的任何过程中被触发。如能在每个请求前、请求末。但根据文档，<code>onload</code> 事件只会在请求成功后触发。又因为 <code>onload</code> 事件是一个常见的 API，所以你能在很短时间内掌握它。<code>onreadystatechange</code> 事件可作为后备（原文是backwards compatible 向后兼容？）方案。而 <code>onload</code> 事件应该是你的首选。而且 <code>onload</code> 事件与 jQuery 的 <code>success</code> 回调函数类似，难道不是吗？</p>
<h3 id="设置请求头部"><a href="#设置请求头部" class="headerlink" title="设置请求头部"></a>设置请求头部</h3><p> jQuery 私下帮你设置请求头部了，所以后端能检测这是一个 Ajax 请求。一般来说，后端并不关心 GET 请求是从哪而来，只要能返回正确的响应即可。当你相用同样的 web API 返回 Ajax 或 HTML 时，这就派上用场了。让我们看看如何通过原生 JavaScript 设置请求头部：</p>
<pre><code>var oReq = new XMLHttpRequest();
oReq.open(&apos;GET&apos;, e.target.dataset.url, true);
oReq.setRequestHeader(&apos;X-Requested-With&apos;, &apos;XMLHttpRequest&apos;);
oReq.send();
</code></pre><p>与此同时，我们在 Node.js 做一个检测：</p>
<pre><code>if (req.headers[&apos;x-requested-with&apos;] === &apos;XMLHttpRequest&apos;) {
    res.writeHead(200, {&apos;Content-Type&apos;: &apos;application/json&apos;});
    res.end(JSON.stringify({message: &apos;Hello World!&apos;}));
}
</code></pre><p>正如你所看到的，原生 Ajax 是一个灵活且现代化的前端 API。你可以利用请求头部做很多事情，其中一种是版本控制。例如，我想让某个 web API 支持多个版本。但我又不想利用 URL，取而代之的是：通过设置请求头部，使客户端能选择它们想要的版本。所以，我们能这样设置请求头部：</p>
<pre><code>oReq.setRequestHeader(&apos;x-vanillaAjaxWithoutjQuery-version&apos;, &apos;1.0&apos;);
</code></pre><p>然后，在后端写上相应代码：</p>
<pre><code>if (req.headers[&apos;x-requested-with&apos;] === &apos;XMLHttpRequest&apos; &amp;&amp;
    req.headers[&apos;x-vanillaajaxwithoutjquery-version&apos;] === &apos;1.0&apos;) {
    // Send Ajax response
}
</code></pre><p>我们能利用 Node.js 为我们提供的 headers 对象进行相应检测。而唯一需要注意的地方是：以小写字母读取它们。</p>
<h3 id="响应类型"><a href="#响应类型" class="headerlink" title="响应类型"></a>响应类型</h3><p>你可能想知道为什么 <code>responseText</code> 返回的是字符串，而不是能被我们操作的普通 JSON（Plain Old JSON）。原来是因为我没有设置合适的 <code>responseType</code> 属性。该 Ajax 属性会很好地告诉前端 API 所期望服务器返回的数据类型。所以，我们要好好利用它：</p>
<pre><code>var oReq = new XMLHttpRequest();
oReq.onload = function (e) {
    results.innerHTML = e.target.response.message;
};
oReq.open(&apos;GET&apos;, e.target.dataset.url, true);
oReq.responseType = &apos;json&apos;;
oReq.send();
</code></pre><p>哇，这样我们就不必再对返回的纯文本解析为 JSON 了，我们能告诉 API 我们期待接收的数据类型。该特性几乎得到了所有最新主流浏览器的支持。当然，jQuery 会自动帮我们转为适当的类型。但现在的原生 JavaScript 也具有方便的、完成同样事件的方法。 原生 Ajax 已经支持很多其它响应类型，如 XML。</p>
<p>但遗憾的是，到 IE11 为止，开发团队仍未对 <a href="https://connect.microsoft.com/IE/feedback/details/794808" target="_blank" rel="external">xhr.responseType=’json’</a> 进行支持。虽然该特性目前在 <a href="http://caniuse.com/#feat=xhr2" target="_blank" rel="external">Microsoft Edge</a> 得到支持。但这个 Bug 提出几乎两年了。我坚信 Microsoft 团队一直在努力地改进浏览器。让我们期待 Microsoft Edge、aka Project Spartan 当初提出的承诺。<br>当然，你可以这个解决这个 IE 问题：</p>
<pre><code>oReq.onload = function (e) {
    var xhr = e.target;
    if (xhr.responseType === &apos;json&apos;) {
        results.innerHTML = xhr.response.message;
    } else {
        results.innerHTML = JSON.parse(xhr.responseText).message;
    }
};
</code></pre><h3 id="避免缓存"><a href="#避免缓存" class="headerlink" title="避免缓存"></a>避免缓存</h3><p>对 Ajax 请求进行缓存的浏览器特性都快被我们忘记了。例如，IE 就默认是这样。我还曾因此导致我的 Ajax 不执行而苦恼了几个小时。幸运的是，jQuery 默认清除浏览器缓存。当然，你能在纯 Ajax 达到该目的，而且相当简单：</p>
<pre><code>var bustCache = &apos;?&apos; + new Date().getTime();
oReq.open(&apos;GET&apos;, e.target.dataset.url + bustCache, true);
</code></pre><p>查看 <a href="http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings" target="_blank" rel="external">jQuery 文档</a>，可知道 jQuery 在每个请求（GET）后面追加一个时间戳作为查询字符串。这在某个程度上让请求变得独一无二，并避免浏览器缓存。每当你触发 HTTP Ajax 请求，你能看到类似如下请求：<br><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2015/08/1439883644cache_busting_vanilla_ajax.jpg" alt="此处输入图片的描述"></p>
<p>OK！这就没有戏剧性的事情发生了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我希望你能喜欢这篇关于原生 Ajax 的文章。Ajax 在过去某段时间里，被人们看作是一种可怕的怪兽。而事实上，我们已经覆盖了原生 Ajax 所有基础知识。</p>
<p>最后，我会留给你一个简洁的方式进行Ajax调用：</p>
<pre><code>var oReq = new XMLHttpRequest();
oReq.onload = function (e) {
    results.innerHTML = e.target.response.message;
};
oReq.open(&apos;GET&apos;, e.target.dataset.url + &apos;?&apos; + new Date().getTime(), true);
oReq.responseType = &apos;json&apos;;
oReq.send();
</code></pre><p>不要忘记，你能在 <a href="https://github.com/sitepoint-editors/VanillaAjaxNojQuery" target="_blank" rel="external">Github</a> 找到整个案例。我希望在评论里看到你对原生 Ajax 的想法。</p>
<hr>
<p>感谢您的阅读。<br>如果你觉得这篇文章对您有帮助或者觉得我翻译得不错，那给我个 <a href="https://github.com/JChehe/translation/blob/master/%E8%84%B1%E7%A6%BBjQuery%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FAjax.md" target="_blank" rel="external">star</a> 吧.<br>英文出处：<a href="http://www.sitepoint.com/guide-vanilla-ajax-without-jquery/" target="_blank" rel="external">《A Guide to Vanilla Ajax Without jQuery》</a><br>翻译： <a href="https://github.com/JChehe" target="_blank" rel="external">刘健超 J.c</a></p>
<p>注意：未经许可，禁止转载！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt; 是异步的JavaScript和XML的简称，是一种更新页面某部分的机制。它赋予了你从服务器获取数据后，更新页面某部分的权力，从而避免了刷新整个页面。另外，以此方式实现页面局部更新，不仅能有效地打造流畅的用户体验，而且减轻了服务器的负载。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="translation" scheme="http://yoursite.com/tags/translation/"/>
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>再次阅读《精通CSS-高级Web标准解决方案（第二版）》</title>
    <link href="http://yoursite.com/2015/11/24/2015-11-24-read-css-mastery-advanced-web-standards-solutions-second-edition-again/"/>
    <id>http://yoursite.com/2015/11/24/2015-11-24-read-css-mastery-advanced-web-standards-solutions-second-edition-again/</id>
    <published>2015-11-23T16:25:31.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天（2015年11月21日） 在我们学校举行了大型招聘会。我面试了三家企业。有一家企业是先做笔试题的，做完后发现自己还是很多细节处理得不够。无论还有没有二面，我还是要重新把《精通CSS》和《JavaScript高级程序设计》这两本书重新看一遍。</p>
<a id="more"></a>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>语义化的好处：</p>
<ol>
<li>自己更易处理（搜索和避免不必要的代码膨胀）</li>
<li>利用SEO</li>
<li>屏幕阅读的用户可以依靠标题进行页面导航</li>
</ol>
<p>div（division，部分）对块级元素进行分组，span对行内元素进行分组或标识。</p>
<p>XHTML 1.0和 HTML 4.01之间主要差异是它遵守XML编码约定：<strong>所有XHTML属性必须包含引号，所有元素必须是封闭的</strong>。</p>
<p>DTD（文档类型定义）是一组机器可读的规则，它们定义XML或HTML的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施，浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个DTD。</p>
<p>DOCTYPE当前有两种风格：严格(strict) 和过渡 (transitional)。后者的目的是帮助开发人员从老版本迁移到新版本。因此，HTML 4.01和XHTML 1.0过渡版本仍然允许使用已废弃的元素（如font），但这些语言的严格版本禁止使用废弃的元素。</p>
<p>浏览器模式：标准模式和混杂模式</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="选择器："><a href="#选择器：" class="headerlink" title="选择器："></a>选择器：</h4><ol>
<li>常用选择器：<br>类型选择器（元素选择器）、后代选择器</li>
<li><p>伪类：<br>链接伪类 :link和:visited，只能用于锚元素</p>
<p>动态伪类 :hover、:active和:focus。理论上可应用于任何元素。IE6 只能对 锚链接 应用:active 和:hover选择器，完全忽略:focus （已验证）。 IE 7在任何元素上都支持:hover，但忽略:active和:focus（书上原话），但在IE11选择IE7文档模式或IETester时，a标签是支持:active。</p>
<p>最后，可以把伪类组合使用，以至可创建更复杂的行为，如 a:visited:hover{} 让已访问与未访问链接实现不同的鼠标悬停效果。</p>
</li>
<li><p>通用选择器：*</p>
</li>
<li><p>高级选择器（ CSS 2.1和CSS3选择器）：<br>大多数现代浏览器（IE7及以上）支持这些高级选择器，但IE6和更低版本不支持。</p>
<ul>
<li>子选择器&gt;（IE7及以上），但在IE7中有个小Bug，如果父元素和子元素之间有HTML注释，就会出问题（测试时，发现并没有问题）。当然，对于IE6，可以利用通用选择器 <code>*</code> 模拟这个效果，<code>div p{/*设置效果*/} div p *{/*还原原来的值*/}</code></li>
<li>相邻同胞选择器+，同样，在IE7，与自选择有同样的BUG，导致失效（已验证）。</li>
<li>后面兄弟选择器~（书上没有），经测试，IE7支持。</li>
<li>属性选择器：a[title]、a[rel=”nofollow”] 等全部属性选择器IE7都支持</li>
</ul>
</li>
</ol>
<h4 id="层叠和特殊性"><a href="#层叠和特殊性" class="headerlink" title="层叠和特殊性"></a>层叠和特殊性</h4><ul>
<li>特殊性<br> !important &gt; 行内样式 &gt; ID &gt; 类、伪类和属性选择器 &gt; 类型选择器（元素选择器）和伪元素选择器</li>
<li>层叠：当两个规则具有相同的特殊性时，后定义的规则优先</li>
<li>继承<br> 直接应用于元素的任何样式总会覆盖继承而来的样式。这是因为继承而来的样式的特殊性为空。 这就解释了“为什么a标签和标题标签要单独指定的样式”这个问题。如下图，chrome浏览器下。a标签和h2标签的默认样式。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151122142212655-260430037.jpg" alt="此处输入图片的描述"><br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151122142226390-963867854.jpg" alt="此处输入图片的描述"></li>
</ul>
<h3 id="第三章-可视化格式模型"><a href="#第三章-可视化格式模型" class="headerlink" title="第三章 可视化格式模型"></a>第三章 可视化格式模型</h3><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><p>页面上每个元素都被看作一个矩形框，该框由元素的内容、内边距、边框和外边距（透明的）组成。</p>
<p>CSS2.1的outline属性，轮廓绘制在元素框（个人认为：即不包括外边距的矩形框）上，所以不影响元素的大小或定位（这里，对我产生一个误区，即定位是按元素框定位（即不包括外边距），其实定位是包括外边距的，即矩形框）。支持IE8及以上。</p>
<p>IE6的混杂模式下，拥有类似box-sizing:border-box的特性，即指定的宽度是内容、内边距和边框的宽度总和。</p>
<p>外边距叠加：即当两个或更多垂直外边距相遇时，它们将形成一个外边距（高度为较大者）。情况有如下几种：</p>
<pre><code>1. 两个同级上下元素
2. 祖先元素与内嵌元素（没有内边距或边框隔开,就祖先元素overflow:hidden/auto/scroll可有隔开的作用，避免叠加）
3. 本身是空元素时,自身上下外边距也会重合（没有边框或内边距隔开）
4. 当然前面几种情况可以结合发生。
</code></pre><p>只有普通文档流中，块框的垂直外边距才回发生叠加。行内框、浮动框或绝对（个人认为包括绝对定位和固定定位）定位框之间的外边距不会发生叠加。</p>
<h4 id="可视化格式模型"><a href="#可视化格式模型" class="headerlink" title="可视化格式模型"></a>可视化格式模型</h4><p>CSS中有3种基本的定位机制：普通流、浮动和绝对定位。</p>
<p>行内框：垂直内边距、边框和外边距不影响行内框的高度。同样，显式设置高度或宽度也没有影响。修改行内框尺寸的唯一方法是修改行高或水平内边距、边框、外边距。</p>
<p>行框：由一行形成的水平框称为行框。行框的高度总是足以容纳它包含的所有行内框。</p>
<p>display:inline-block; 让元素像行内元素一样水平依次排列，但框的内容仍然符合块级框的行为。<strong>支持IE8及以上。</strong></p>
<p>绝对定位：绝对定位的元素的位置是相对于最近的已定位祖先元素，如无，则根据用户代理的不同，初始包含块可能是画布（是iframe吗？）或HTML元素。</p>
<p>在IE6中有个BUG：相对于相对定位的框的右边或顶部设置绝对定位的框的位置，那么需要确保相对定位的框已设定了尺寸（测试时发现，块级元素只需设置高度）。否则，绝对定位元素会错误地相对于画布定位这个框（已验证）</p>
<p>固定定位：IE6不支持，IE7部分支持，但是实现中有许多bug。</p>
<p>浮动：浮动的框可左右移动，直到它的外边缘（包括外边距）碰到包含框或另外一个浮动框的边缘。因为浮动框不在文档的普通流，所以文档的普通流中的块框表现得就像浮动框不存在一样。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151122161707983-603474969.jpg" alt="此处输入图片的描述"><br>如果包含块太窄，以致不能同时水平排列3个浮动元素，且浮动元素的高度不同，那么当它们向下移动时，可能被其它浮动元素卡主。</p>
<p>前面说到浮动会让元素脱离文档流，不再影响不浮动的元素。实际上，框的文本内容（不止文本）会受到浮动元素的影响，会移动以留出空间，用技术术语来说，浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151122162756624-498882882.jpg" alt="此处输入图片的描述"><br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151122164038233-621267712.jpg" alt="此处输入图片的描述"><br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151122164048999-1126569143.jpg" alt="此处输入图片的描述">  </p>
<p>要想阻止行框围绕在浮动框的外边，需要对包行这些行框的元素应用clear属性。清除浮动时，浏览器给元素顶上添加足够的外边距，使元素的顶边缘下降到浮动框下面。</p>
<p>子元素浮动后，脱离文档流，不能撑起父元素高度，要撑起父元素高度的方法有：</p>
<ol>
<li>overflow：hidden/auto</li>
<li>父元素也浮动</li>
<li><code>.clearfix:after{content:&quot; &quot;;height:0;visibility:hidden;display:block;clear:both}</code> 或 <code>.clearfix:after{content:&quot; &quot;;display:table;clear:both}。</code>由于IE6/7不支持:after伪元素，所以要使用以下hack: <code>.clearfix{zoom:1; //trigger IE haslayout}</code></li>
<li>增加额外标签，然后clear</li>
</ol>
<h3 id="第四章-背景图像效果"><a href="#第四章-背景图像效果" class="headerlink" title="第四章 背景图像效果"></a>第四章 背景图像效果</h3><p>CSS规范不允许混合使用多种单位。实际上，浏览器是支持的。</p>
<p>opacity：IE8及以下不支持，但是可以用  filter:alpha(opacity=80) 指定透明度。opacity 是继承的，它的后台元素都会受影响。另外也是可以叠加的，父元素0.8，子元素0.8，那么子元素是0.64。</p>
<p>rgba：IE8及以下不支持，是针对opacity而生的，不影响后代元素。</p>
<p>IE7 支持 min-height、max-height</p>
<p>许多流行的屏幕阅读器会忽略那些display值为none或visibility为hidden的元素。所以这会造成严重的可访问性问题。  </p>
<p>解决办法是：通过设置非常大的负值文本缩进：text-indent:-5000em;（text-indent适用于块级元素）</p>
<p>IE6不直接支持PNG透明度的，对于IE6，书上列出两种方法（网上更多）：</p>
<ol>
<li>在针对IE6的CSS文件里：<br><code>filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;/img/my-image.png&#39;, sizingMethod=&#39;crop&#39;);/* 网上说，路径是相对于html的，而不是CSS的。*/ 
background:none;/* 取消原来的背景图，防止遮住该过滤器。*/</code></li>
<li><p>IE PNG fix技术。利用Microsoft专有的CSS扩展——行为（behavior）。下载合适的.htc文件，并在IE6专用的样式表引用。</p>
<pre><code>img, div{
　　behavior:url(iepngfix.htc)
}
</code></pre></li>
</ol>
<p>备注：屏幕阅读器是指将屏幕显示内容转为声音或布莱叶盲文显示，以帮助视力障碍者使用电脑的软件。</p>
<h3 id="第五章-对链接应用样式"><a href="#第五章-对链接应用样式" class="headerlink" title="第五章 对链接应用样式"></a>第五章 对链接应用样式</h3><p>为提高页面的可访问性，在定义鼠标悬停状态时，最好在链接上添加:focus伪类。在通过键盘移动到链接时，也可以让链接显示的样式与鼠标悬停时相同。</p>
<p>a:hover, ac:foucs{} /<em> 这也是bootstrap用到的 </em>/</p>
<p>正确写法：</p>
<p>a:link, a:visited{text-decoration: none;}</p>
<p>a:hover, a:focus, a:active{text-decoration:underline}</p>
<p>如果次序反过来，则下划线效果就不起作用（因为层叠造成的，当两个规则具有相同的特殊性时，后定义的规则优先）：</p>
<p>对于a标签，最好按以下顺序： a:link, a:visited, a:hover, a:focus, a:active (LVHFA)</p>
<p>对于不支持背景图动画的，常会显示第一帧，以确保平稳退化。（连IE5都支持 –！）</p>
<h3 id="第六章-对列表应用样式和创建导航条"><a href="#第六章-对列表应用样式和创建导航条" class="headerlink" title="第六章 对列表应用样式和创建导航条"></a>第六章 对列表应用样式和创建导航条</h3><p>初始化 ul{margin:0;padding:0;list-style-type:none;}</p>
<p>不对应用列表项应用样式，而是对其中包含的锚链接应用样式，由此提供更好的浏览器兼容性。</p>
<h3 id="第七章-对表单和数据表格应用样式"><a href="#第七章-对表单和数据表格应用样式" class="headerlink" title="第七章 对表单和数据表格应用样式"></a>第七章 对表单和数据表格应用样式</h3><h4 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h4><p>表格特有的元素：capiton用于指定表格的标题；summary属性用于描述表格内容。 </p>
<pre><code>&lt;table summary=&quot;I am a Description&quot;&gt;
    &lt;caption&gt;表格标题&lt;/caption&gt;
&lt;/table&gt;
</code></pre><p>　一个table里，tbody 、tfooter只能使用一个，而tbody可以将复杂的表格划分为多个部分。</p>
<p>CSS的border-spacing属性可以控制单元格之间的距离。但IE7及以下不支持。因此需要老式但可靠的cellspacing属性（支持IE6和IE7）。严格来说，该属性是表现性的。</p>
<h4 id="表单："><a href="#表单：" class="headerlink" title="表单："></a>表单：</h4><p>对于表单，对于必填域和提示，最适合用em或strong元素。</p>
<p>OS X等许多系统为了保持一致，禁止修改input按钮样式，但button不受限制。</p>
<p>对于需要隐藏的label，将display设置为none会住址许多屏幕阅读器访问它们。其中有两种方法：</p>
<ol>
<li>设置较大的负文本缩进将标签定位到屏幕外（书上的）</li>
<li><p>Bootstrap的.sr-only</p>
<pre><code>.sr-only{
    position:absolute;
    width:1px;
    height:1px;
    padding:0;
    margin: -1px;
    overflow:hidden;
    clip:react(0,0,0,0);
    border:0;  
}
</code></pre></li>
</ol>
<h3 id="第八章-布局"><a href="#第八章-布局" class="headerlink" title="第八章 布局"></a>第八章 布局</h3><p>IE6 不支持margin:auto居中（在IETester是支持的），解决办法是：body{text-align:center}　.wrapper{text-align:left} /<em> 因为IE将text-align误解为让所有东西居中，而不只是文本 </em>/</p>
<p>IE6 因为是考虑元素内容的尺寸，而不是元素本身尺寸。在符合标准的浏览器中，如果元素的内容太大，它只会超出框之外。但是在IE6中，如果元素内容太大，则整个元素就会扩展(包括宽和高)。即设定的width表现得像 min-width<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151123214534686-1472015437.jpg" alt="此处输入图片的描述"><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151123214541967-166102166.jpg" alt="此处输入图片的描述"></p>
<p>流式布局：百分比</p>
<p>弹性布局：字号em</p>
<p>创建高度相等的列：关键点是给每个框设置大的padding-bottom，然后用数值相近的负margin-bottom抵消这个高度。然后在#wrapper设置 overflow:hidden。</p>
<p>从这个案例可以看出：加入把框看作是一个垂直于屏幕的立体，那么margin是最底层的，而元素之间的间距是靠margin隔开的。又因为padding-bottom在margin之上，所以处于外层padding让我们看到背景色，而负值margin则让旁边的元素处于其padding下方。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151123222336264-1720178800.jpg" alt="此处输入图片的描述"><br>（Firefox 3D布局）</p>
<pre><code>&lt;div id=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>// 假设.box因为内容不一样而高度不同</p>
<pre><code>#wrapper{
  overflow:hidden;
}
.box{
  width:   30%;
  float:left;
  padding-bottom:520px;
  margin-bottom: -500px;
}
</code></pre><h3 id="第九章-bug和修复bug"><a href="#第九章-bug和修复bug" class="headerlink" title="第九章 bug和修复bug"></a>第九章 bug和修复bug</h3><p>　拥有布局：IE6的bug最多，IE6与其它浏览器表现不同的原因之一是，显示引擎使用一个称为布局（layout）的内部概念。布局问题是许多IE/WIN显示BUG的根源。</p>
<p>   什么是布局？ Window上的IE使用布局概念来控制元素的尺寸和定位。那些“拥有布局（haslayout）”的元素负责本身及其子元素的尺寸设置和定位。如果一个元素“没有拥有布局”，那么它的尺寸和位置由最近的拥有布局的祖先元素控制。</p>
<p>　　IE显示引擎利用布局概念减少它的处理开销。在理想的情况下，所有元素都控制自己的尺寸和定位。但是，这会在IE中导致很大的性能问题。因为，IE开发团队决定只将布局应用于实际需要它的那些元素，这样就可以充分地减少性能开销。</p>
<p>在默认情况下拥有布局的元素包括：body、html（标准模式中）、table、tr、td、img、hr、input、select、textarea、button、iframe、embed、object、applet、marquee。</p>
<p>布局概念是Window上的IE特有的，而且它不是CSS属性。尽管设置某些CSS属性会使元素拥有布局，但是在CSS中无法显示地设置布局。可以使用JavaScript函数hasLayout查看一个元素是否拥有布局。如果元素拥有布局，这个返回true，反之，返回false。hasLayout是一个只读属性，所以无法使用JavaScript进行设置。</p>
<p>设置以下CSS属性会自动地使元素拥有布局：</p>
<ol>
<li>float:left或right </li>
<li>display:inline-block </li>
<li>width:任何值  </li>
<li>height:任何值  ⑤zoom:任何值  </li>
<li>writing-mode:tb-rl</li>
</ol>
<p>在IE7中，以下属性也成了布局触发器：</p>
<ol>
<li>overflow:hidden、scroll或auto </li>
<li>min-width:任何值  </li>
<li>max-width:除了none之外的值。</li>
</ol>
<p>布局的效果</p>
<p>布局是许多IE显示BUG的根源。</p>
<ol>
<li>一个文本段落靠着一个浮动元素，那么我们期望文本围绕这个元素。但是在Window上的IE6，如果段落拥有布局（如设置高度），那么它就被限制为矩形，因此阻止文本围绕浮动元素。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151123232532967-1416854027.jpg" alt="此处输入图片的描述">  </li>
<li>在IE6中，拥有布局的元素会错误地扩展以便适应内容的尺寸。width和height更像是min-width和min-height。</li>
<li>其他问题：<ol>
<li>拥有布局的元素不会收缩（什么意思？）</li>
<li>布局元素对浮动元素自动清理（所以.clearfix{zoom:1}）</li>
<li>相对定位的元素没有布局</li>
<li>在拥有布局的元素之间外边距不叠加</li>
<li>在没有布局的块级链接上，单机区域只覆盖文本</li>
<li>在滚动时，列表项上的背景图像间歇性地显示和消失。</li>
</ol>
</li>
</ol>
<p>所以，如果遇到一个IE BUG，首先应该做的一件事情是尝试通过应用规则迫使元素拥有布局。</p>
<p>在IE7中，已经修复大多数与布局相关的问题。但是该团队的解决方法是找到常见的显示BUG，然后通过在代码中创建列外来处理它们，而不是解决顶层问题。因此，可能有一些不显著的布局bug还没有被发现。 </p>
<p>IE8使用全新的显示引擎，据称不使用hasLayout属性，因此解决了这些问题的根源。</p>
<p>IE条件注释， 在IE5首次出现。</p>
<p><code>&lt;!--[if IE]&gt;&lt;![endif]--&gt;</code></p>
<p>CSS被设计成具有很强的向前兼容性。如果浏览器不理解某个选择器，则会忽略整个规则。如果不理解某个属性或值，则会忽略整个声明（某个CSS声明）。</p>
<p>应用星号HTML hack。针对IE6。因为IE6有一个匿名的根元素，它包围着HTML元素。所以针对IE6 可以这样应用规则：  * html #content{}</p>
<h4 id="常见bug及其修复方法"><a href="#常见bug及其修复方法" class="headerlink" title="常见bug及其修复方法"></a>常见bug及其修复方法</h4><ol>
<li><p>双外边距浮动BUG（IE6）：使任何浮动元素上的外边距（左右两侧外边距）加倍。<br>解决方法： display:inline</p>
</li>
<li><p>3像素文本偏移BUG（IE6）：当文本与一个浮动元素相邻时，这个bug就会表现出来，例如，假设将一个元素向左浮动，并且不希望相邻段落中文本围绕浮动元素。你可能会在段落上应用一个左外边距，其宽度等于浮动元素的宽度：</p>
<pre><code>.myFloat{float:left;width:200px}

p{margin-left:200px}    
</code></pre><p>如果这么做，在文本和浮动元素之间就会出现一个莫名其妙的3像素间隙。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/615180-20151124111613202-673126870.jpg" alt="此处输入图片的描述"><br>修复这个Bug需要双管齐下。</p>
<p>首先，针对IE6 为文本框设置height:1%(IE6会把height当成min-height)，这样文本框就会拥有布局，由前面可知，拥有布局的元素被限制为矩形。并且出现在浮动元素的旁边而不是它们的下面。添加200px的外边距实际上会在IE6中在浮动元素和段落之间产生200像素的间隙（在IETester并没有）。为了避免这个间隙，需要为IE6专门设置margin-left为0(还是要设置为0的，否则取消不了这3px)。这样文本偏移被修复了，但是现在另外一个3px间隙出现了，这一次是在浮动元素上。为了去掉这个间隙，需要在浮动元素上设置一个负的3px右外边距 .myFloat{margin-right:3px}</p>
</li>
<li><p>IE6的重复字符bug</p>
<p>在某些情况下，一系列浮动元素的最后一个元素中的最后几个字符会在浮动元素下面重复出现。当在一系列浮动元素的第一个和最后一个元素之间有多个注释时，就会出现这个BUG。前两个注释没有影响，但是后续的每个注释会导致两个字符重复出现。所以3个注释会导致两个重复字符，4个注释会导致4个重复字符，5个注释会导致6个重复字符。</p>
<p>这个BUG似乎与前面的3px文本偏移bug相关。为了修复这个bug，可以通过设置负的右外边距从最后一个浮动元素上去掉3px，或者使容器扩大3px。但是，这两种方法可能在IE7中造成问题最好的方法是删除注释。</p>
</li>
<li><p>IE6的“藏猫猫”bug</p>
<p>因为在某些条件下问来看起来消失了，只有在重新加载页面时才再度出现。</p>
<p>出现这个bug的条件是：一个浮动元素后面跟着一些非浮动元素，然后是一个清理元素，所有这些元素都包含在一个设置了背景颜色或图像的父元素中。如果清理元素碰到了浮动元素，那么中间的非浮动元素看起来消失了，隐藏到了父元素的背景颜色或图像后面，只有在刷新页面时才重新出现。</p>
<p>解决办法：</p>
<ol>
<li>去掉父元素上的背景颜色或图像。但是这常常不可行。</li>
<li>避免清理元素与浮动元素接触</li>
<li>容器应用了特定的尺寸，那么这个BUG视乎就不会出现</li>
<li>给容器指定行高 </li>
<li>将浮动元素和容器元素的position属性设置为relative也会减轻这个问题。</li>
</ol>
</li>
<li><p>相对容器中的绝对定位（IE6BUG前面有提过）</p>
<p>这bug的原因在于相对定位的元素没有获得IE/win的内容layout属性。因此它不创建新的定位上下文，所有绝对定位元素相对于视口进行定位。</p>
<p>解决办法：让相对容器拥有布局，height:1%。</p>
</li>
</ol>
<h3 id="第10章-研究案例"><a href="#第10章-研究案例" class="headerlink" title="第10章 研究案例"></a>第10章 研究案例</h3><p>Reset CSS ：<a href="http://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="external">http://meyerweb.com/eric/tools/css/reset/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天（2015年11月21日） 在我们学校举行了大型招聘会。我面试了三家企业。有一家企业是先做笔试题的，做完后发现自己还是很多细节处理得不够。无论还有没有二面，我还是要重新把《精通CSS》和《JavaScript高级程序设计》这两本书重新看一遍。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>如何成为一个JavaScript 大牛？</title>
    <link href="http://yoursite.com/2015/09/01/2015-9-1-how-to-be-a-great-javascript-software-developer/"/>
    <id>http://yoursite.com/2015/09/01/2015-9-1-how-to-be-a-great-javascript-software-developer/</id>
    <published>2015-09-01T03:23:45.000Z</published>
    <updated>2016-11-13T11:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在成长的过程中，我的兴趣点不断发散，而且都是看似不相关的领域。我喜欢数学正如我喜欢历史一样。我的目标是成为一个 多才多艺的人 – 博学者-，能在多个领域成为优秀人才。这证实是一项艰巨的任务，我忽然面临着行行皆通，样样稀松的危险。</p>
<a id="more"></a>
<p>我开始考虑专注于某些领域，这样即使不能成为像文艺复兴时期的通才，但至少能精通某些方面。那我怎么样才能专注于某一领域的同时，掌握软件开发所需的庞大的知识体系呢？</p>
<p>本帖内容是基于我过去 5 年经验编写的，概述了我成为一个优秀的 JavaScript 开发者所用到的技术和资源。</p>
<p>当今大多数 web 开发者都面临着同样的问题：他们不得不擅长多个不同领域，从数据库到后端架构，再到前端的用户界面，用所精通的 CSS 知识去修改 UI 。</p>
<h2 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h2><p>为了达到精通，专注与努力是首要条件。如果不投入全身心工作，最后你只会一知半解。例如通过阅读一些博客文章，因为初期时间投入较低，所以看起来会比较简单。但从长远来看，这种学习模式将会比专注于学习精髓的过程花费更多的时间。解决这个难题的方法很简单：看书。</p>
<p>书籍让我们站在文明的肩膀上。而精炼的文字让我们的知识代代相传。而对于如何成为 web 技术专家这个问题，你在学习的过程中就要与 web 本身保持一定距离。因为 web 对于学习来说，其本身就是一个混杂且分散的媒介，所以我的第一个建议是阅读相关专业的书籍。</p>
<p>对于 JavaScript，从 <a href="http://shop.oreilly.com/product/9780596517748.do" target="_blank" rel="external">《JavaScript 语言精髓》</a> 这本被称为 JavaScript 圣经的书开始。这本书虽然比较旧，但非常适合入门。<a href="http://shop.oreilly.com/product/9780596805531.do" target="_blank" rel="external">《JavaScript权威指南》</a> 也是必备的，尽管你可能会将它作为一个参考书籍。另外，jQuery 作者 John Resig 的 <a href="http://blog.ustunozgur.com/javascript/programming/books/videos/2015/06/17/www.manning.com/resig/" target="_blank" rel="external">《JavaScript 忍者禁术》</a> 也是不容错过的。如果你在寻找好（在线免费的）书，可以看看 <a href="https://leanpub.com/javascript-allonge/" target="_blank" rel="external">《JavaScript Allongé》</a> 、<a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">《You Don’t Know JS》</a> 和 <a href="http://eloquentjavascript.net/" target="_blank" rel="external">《Eloquent JavaScript》</a>（<a href="https://watchandcode.com/courses/eloquent-javascript-the-annotated-version" target="_blank" rel="external">点击这里</a> 可以看它的注释版本）。这些都能以电子书或印刷版的形式购买。另外，Mozilla’s Developer Network 也有很好的 “<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide" target="_blank" rel="external">JavaScript 指南</a>”。</p>
<h2 id="学习、使用并阅读库"><a href="#学习、使用并阅读库" class="headerlink" title="学习、使用并阅读库"></a>学习、使用并阅读库</h2><p>接下来最重要的一步是了解库。如果书籍教会你如何理解语言，则库教你如何表达它。对于库，你有两个重要的事情要做：使用它们并阅读它们的源代码。</p>
<p>通过使用库，开始知道：jQuery、Backbone、underscore 和 React、Angular 、Ember 中的一个。当然，这不是说你必须使用这些库，但称职的 JavaScript 开发者都应该至少有这些库的使用经验（不管好坏）。</p>
<p>对于提高 JavaScript 技能，第二重要的是阅读这些库的源代码。其中，我特别推荐 Backbone 和 underscore 的源代码，因为它们的代码写得特别漂亮。通过阅读和理解 underscore，你的函数编程能力将会得到提高。另一个是其他几个开发者推荐给我的库是 mootools （我个人没有 mootools 的使用和阅读经验，仅仅是传达信息。）</p>
<p>理解上述列表里的其它库，如 React、Ember 等，可能有点难，但值得付出努力。至少略读其它库的源代码，看看它们是如何组织基础代码并尽量发现一些模式。其它一些值得使用和阅读源代码的库还有 d3、 highcharts 和 moment.js。</p>
<h2 id="练习与问自己问题"><a href="#练习与问自己问题" class="headerlink" title="练习与问自己问题"></a>练习与问自己问题</h2><p>成为优秀 JavaScript 开发者的下一步是做大量的实践。理论上，这些实践的重点不在 DOM，而是语言，所以确保有测试工具能在 node.js 上运行。在 node.js 上做大量小练习。通过不同的方式使用 JavaScript 的闭包、原型、array-extras (map, filter) 等。当你经过大量练习后，头脑里就会对 JavaScript 有基本的想法。</p>
<p>我朋友 Armagan 是一名杰出的 JavaScript 程序员兼老师，他在课堂里使用的课本 <a href="http://www.apress.com/9781590599082" target="_blank" rel="external">《JavaScript 设计模式》</a> 也是值得一看的。</p>
<p>试着回答诸如：原型继承是如何工作的？闭包的定义是什么？this 关键字是如何改变的？如何使用 apply/bind/map/filter/call？收集一些 JavaScript 开发者常见问题并尝试用自己的语言解释它。用书面或口头的方式向别人解释这些概念，能极大地提高能力。在做实践的同时，尝试做“假设分析”。例如，“如果使用两次 bind，this 将会代表什么？jQuery 是如何确保 this 关键字是引用 jQuery 对象，而不是全局对象？这个库如何完成某个特性？”这些都是值得思考的常见问题。</p>
<h2 id="学习标准"><a href="#学习标准" class="headerlink" title="学习标准"></a>学习标准</h2><p>下一步是学习更多关于 EcmaScript 标准。找到一份最新的 EcmaScript 标准并尝试阅读它。除了这些，也要尝试学习即将推出的 JavaScript 特性，如 ES 6 和 ES 7 新增的。最近有一些新特性如：promises、modules、generators、comprehensions 和 again。可以通过专门的书来学习标准，如 Zakas 的 ( <a href="https://leanpub.com/understandinges6" target="_blank" rel="external">Understanding EcmaScript 6</a> ) 或 Dr. Axel Rauschmayer 的 ES6 书 ( <a href="http://exploringjs.com/" target="_blank" rel="external">Exploring JS</a> ) 。阅读标准是获取专业知识和发现语言新特性的主要来源。</p>
<h2 id="使用-web-上的资源"><a href="#使用-web-上的资源" class="headerlink" title="使用 web 上的资源"></a>使用 web 上的资源</h2><p>我之前提到使用 web 获取 web 知识的危险性，所以最后的建议是具体如何在 web 中获取最好的资源。Hacker News 是一个很好的资源，然而如果时刻关注它的话，将会花费较多时间，因为信噪比较低（表示 JavaScript 文章比例较低）。取而代之的是，关注 <a href="http://javascriptweekly.com/" target="_blank" rel="external">JavaScript Weekly</a> 之类的每周文摘。随着时间的推移，你会看到哪些库或技术是备受关注的。在 Twitter，尝试去关注那些有影响力的 JavaScript 开发者。这里是 Tutsplus 列出的 <a href="http://code.tutsplus.com/articles/33-developers-you-must-subscribe-to-as-a-javascript-junkie--net-18151" target="_blank" rel="external">33 个值得关注的 JavaScript 开发者</a>。其它在 web 上的资源还包括一些博客，如 <a href="http://www.toptal.com/section/front-end" target="_blank" rel="external">Toptal Blogs</a>、<a href="http://rmurphey.com/" target="_blank" rel="external">Rebecca Murphey’s blog</a> （如果你对这个博客的帖子感兴趣，也可以看看 <a href="http://rmurphey.com/blog/2015/03/23/a-baseline-for-front-end-developers-2015/" target="_blank" rel="external">A Baseline for Front-End [JS] Developers: 2015</a>）和 <a href="http://www.nczonline.net/" target="_blank" rel="external">Nicholas Zakas’ blog</a>。（如果你有其它好博客，请 Email 我，我会将它添加到该列表里。）</p>
<p>另一个重要资源是大会视频和教育视频。对于大会，JSConf 系列都是高质量的。对于教育视频，我强烈建议 Pluralsight，因为他们拥有经验丰富的开发者准备的高质量课程。（我与 Pluralsgiht 没有隶属关系）</p>
<h2 id="浓缩版"><a href="#浓缩版" class="headerlink" title="浓缩版"></a>浓缩版</h2><ul>
<li>从阅读书籍开始，因为书籍能为你提供精华信息。</li>
<li>学习主要的库，如 jQuery、underscore、Backbone，并阅读它们的源代码。</li>
<li>多实践并尝试用自己的话解释“继承”之类的常见 JavaScript 概念。对上述主题进行演讲和交流。</li>
<li>仔细阅读最新标准，并开始使用该语言的最新特性。</li>
<li>关注 web 资源，每周关注一次文摘或博客，或观看会议视频和视频教程。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一直反复这些并完成大量项目，将会极大地提高你的 JavaScript 编程能力。只有努力不懈，才有希望在几年后成为一名专家。我觉得自己是一名优秀的 JavaScript 程序员，离专家仍有一大段路要走，有很多技术需要在我接下来的学习生涯中学到。另外，随时可以通过 <a href="">atustun@ustunozgur.com</a> 向我提出反馈和修正。</p>
<p>本文由 <a href="http://web.jobbole.com/" target="_blank" rel="external">伯乐在线</a> - <a href="http://www.jobbole.com/members/q574805242" target="_blank" rel="external">刘健超-J.c</a> 翻译，<a href="http://www.jobbole.com/members/shutear" target="_blank" rel="external">shutear</a> 校稿。未经许可，禁止转载！<br>英文出处：<a href="http://blog.ustunozgur.com/javascript/programming/books/videos/2015/06/17/how_to_be_a_great_javascript_software_developer.html" target="_blank" rel="external">Ustun Ozgur</a>。</p>
<p>感谢您的阅读。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在成长的过程中，我的兴趣点不断发散，而且都是看似不相关的领域。我喜欢数学正如我喜欢历史一样。我的目标是成为一个 多才多艺的人 – 博学者-，能在多个领域成为优秀人才。这证实是一项艰巨的任务，我忽然面临着行行皆通，样样稀松的危险。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="translation" scheme="http://yoursite.com/tags/translation/"/>
    
  </entry>
  
</feed>
